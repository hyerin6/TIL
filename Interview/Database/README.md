# Database

<br />

## 정규화(1~3차, BCNF)

정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는 것이다.
중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB 저장 용량도 줄일 수 있다.

<br />     

### 제1 정규화
테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것이다.
<br />        


### 제2 정규화
제1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것이다.
완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어서는 안된다는 것을 의미한다.

<img width="538" src="https://user-images.githubusercontent.com/33855307/145943333-1129db11-1298-4e6e-85d6-054975511377.jpg">

<img width="500" src="https://user-images.githubusercontent.com/33855307/145943994-9702743f-78e9-4ec6-ad99-cd8f232c7f48.jpg">

강의실이라는 칼럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있다.    
기본키(학생번호, 강좌이름)의 부분키인 강좌이름이 결정자가 되므로 강의실을 변도의 테이블로 관리하여 제2 정규형을 만족시킬 수 있다.  
<br />         


### 제3 정규화 
제3 정규화란 제2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해하는 것이다.        
이행적 종속이란, `A → B`, `B → C`가 성립할 때 `A → C`가 성립되는 것을 의미한다.

* 계절학기

```
학생 번호 → 강좌 이름 → 수강료 
```

학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다.  
이행적 종속을 제거하는 이유는 비교적 간단하다.  
학생이 듣는 강좌 이름이 변경되었다고 가정하자.    
수강료도 변경되었을까? 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다.   
학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해해야 한다.
<br />         


### BCNF 정규화 
BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 **모든 결정자가 후보키가 되도록 테이블을 분해**하는 것이다.  

```java
(학생번호, 특강이름) → 교수 → 특강 이름 
```

교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니다.        
BCNF 정규화를 만족시키기 위해서 특강신청 테이블과 특강교수 테이블로 분해할 수 있다.

<br />
<br />


## 트랜잭션이란? 
데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합이다.   

예) A 계좌에서 B 계좌로 계좌이체한다고 가정   
```text
1) A 계좌 잔액 확인 
2) A 계좌에서 이체할 금액을 빼고 다시 저장 
3) B 계좌 잔액 확인 
4) B 계좌의 금액에서 이체한 금액 더하고 다시 저장 
```

이러한 과정들이 모두 합쳐져 계좌이체라는 하나의 작업단위로 구성한다.   

<br />
<br />

## 트랜잭션의 성질 (ACID) 
* 원자성        
트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 or 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.   



* 일관성          
하나의 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.



* 독립성         
하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.



* 지속성         
성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다. 


<br />
<br />

## 트랜잭션의 필요성 
* 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우 
* 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우   
* 위와 같은 상황이 발생되지 않도록 방지하기 위해, 즉 트랜잭션의 성질인 ACID를 제공받기 위해 트랜잭션을 사용한다.

<br />
<br />

## 트랜잭션의 상태 
* 활동: 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태 
* 장애: 트랜잭션이 실행에 오류가 발생하여 중단된 상태 
* 철회: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태 
* 부분 완료: 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태 
* 완료: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태 

<br />
<br />

## 트랜잭션 격리 수준 
### Isolation Level
트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준   


### Isolation Level의 필요성 
* 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다. 
* 그래서 Locking 이라는 개념이 등장한다. 
    - Locking이란 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것 
* 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다. 
* 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 수 있다.
 


### Isolation Level의 종류 
* Read Uncommitted 
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 레벨 
    - 트랜잭션 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. 
    - 데이터 변경하는 동안 다른 사용자는 아직 완료되지 않은(Dirty) 데이터를 읽을 수 있다. 
    - 데이터베이스의 일관성을 유지할 수 없다. 
    - Dirty Read 
        + 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상 
        + 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 경우 

    
* Read Committed
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 레벨 
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다. 
    - Commit이 이루어진 트랜잭션만 조회할 수 있다. 
    - 데이터를 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다. 
    - SQL Server가 Default로 사용하는 Isolation Level
    - Non-Repeatable Read 
        + 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써   
          두 쿼리의 결과가 상이하게 나타나는 비일관성 현상     


* Repeatable Read 
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨 
    - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다. 
    - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다. 
    - Phantom Read 
         + 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상 
         + 이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다. 


* Serializable 
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨 
    - 완벽한 읽기 일관성 모드를 제공한다. 
    - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다. 
    

Isolation level 조정은 동시성이 증가되는데 반해 데이터 무결성 문제가 발생할 수 있고,   
데이터의 무결성을 유지하는 데 반해 동시성이 떨어질 수 있다.   
레벨이 높아질수록 비용이 높아진다.   

<br />


## 데이터베이스 풀

## Join

## Index 

## Statement와 PrepareStatement

## RDBMS vs NoSQL 

## Replication 

## DB 파티셔닝 

## 샤딩(Sharding)

## ORM 

## JDBC 


# Database

<br />

## 정규화(1~3차, BCNF)

정규화의 기본 목표는 테이블 간에 중복된 데이터를 허용하지 않는 것이다.
중복된 데이터를 허용하지 않음으로써 무결성을 유지할 수 있으며, DB 저장 용량도 줄일 수 있다.

<br />     

### 제1 정규화
테이블의 컬럼이 원자값을 갖도록 테이블을 분해하는 것이다.
<br />        


### 제2 정규화
제1 정규화를 진행한 테이블에 대해 **완전 함수 종속**을 만족하도록 테이블을 분해하는 것이다.
완전 함수 종속이란, 기본키의 부분집합이 결정자가 되어서는 안된다는 것을 의미한다.

<img width="538" src="https://user-images.githubusercontent.com/33855307/145943333-1129db11-1298-4e6e-85d6-054975511377.jpg">

<img width="500" src="https://user-images.githubusercontent.com/33855307/145943994-9702743f-78e9-4ec6-ad99-cd8f232c7f48.jpg">

강의실이라는 칼럼은 기본키의 부분집합인 강좌이름에 의해 결정될 수 있다.    
기본키(학생번호, 강좌이름)의 부분키인 강좌이름이 결정자가 되므로 강의실을 변도의 테이블로 관리하여 제2 정규형을 만족시킬 수 있다.  
<br />         


### 제3 정규화 
제3 정규화란 제2 정규화를 진행한 테이블에 대해 **이행적 종속**을 없애도록 테이블을 분해하는 것이다.        
이행적 종속이란, `A → B`, `B → C`가 성립할 때 `A → C`가 성립되는 것을 의미한다.

* 계절학기

```
학생 번호 → 강좌 이름 → 수강료 
```

학생 번호는 강좌 이름을 결정하고 있고, 강좌 이름은 수강료를 결정하고 있다.  
이행적 종속을 제거하는 이유는 비교적 간단하다.  
학생이 듣는 강좌 이름이 변경되었다고 가정하자.    
수강료도 변경되었을까? 강좌 이름에 맞게 수강료를 다시 변경할 수 있지만, 이러한 번거로움을 해결하기 위해 제3 정규화를 하는 것이다.   
학생 번호를 통해 강좌 이름을 참조하고, 강좌 이름으로 수강료를 참조하도록 테이블을 분해해야 한다.
<br />         


### BCNF 정규화 
BCNF 정규화란 제3 정규화를 진행한 테이블에 대해 **모든 결정자가 후보키가 되도록 테이블을 분해**하는 것이다.  

```java
(학생번호, 특강이름) → 교수 → 특강 이름 
```

교수가 특강이름을 결정하는 결정자이지만, 후보키가 아니다.        
BCNF 정규화를 만족시키기 위해서 특강신청 테이블과 특강교수 테이블로 분해할 수 있다.

<br />
<br />


## 트랜잭션이란? 
<https://hyerin6.github.io/2020-06-13/transaction/>

데이터베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합이다.   

예) A 계좌에서 B 계좌로 계좌이체한다고 가정   
```text
1) A 계좌 잔액 확인 
2) A 계좌에서 이체할 금액을 빼고 다시 저장 
3) B 계좌 잔액 확인 
4) B 계좌의 금액에서 이체한 금액 더하고 다시 저장 
```

이러한 과정들이 모두 합쳐져 계좌이체라는 하나의 작업단위로 구성한다.   

<br />
<br />

## 트랜잭션의 성질 (ACID) 
* 원자성        
트랜잭션의 모든 연산들은 정상적으로 수행 완료되거나 or 전혀 어떠한 연산도 수행되지 않은 상태를 보장해야 한다.   



* 일관성          
하나의 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다.



* 독립성         
하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.



* 지속성         
성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.    


<br />
<br />

## 트랜잭션 전파 (propagation)   
트랜잭션을 시작하거나 기존 트랜잭션에 참여하는 방법을 결정하는 속성이다.         
기존 트랜잭션에 참여한다는 것은 현재 트랜잭션에서 다른 트랜잭션으로 이동할 때를 이야기 한다.           

#### REQUIRED
디폴트 속성이며 모든 트랜잭션 매니저가 지원한다.        
미리 시작된 트랜잭션이 있으면 참여하고 없으면 새로 시작한다.      
자연스럽고 간단한 트랜잭션 전파 방식이지만 사용해보면 매우 강력하고 유용하다는 사실을 알 수 있다.        
하나의 트랜잭션이 시작된 후에 다른 트랜잭션 경계가 설정된 메소드를 호출하면 자연스럽게 같은 트랜잭션으로 묶인다.       

#### SUPPORTS
이미 시작된 트랜잭션이 있으면 참여하고 그렇지 않으면 트랜잭션 없이 진행한다.       
트랜잭션이 없긴 하지만 해당 경계 안에서 Connection이나 하이버네이트 Session 등을 공유할 수 있다.        

#### MANDATORY
REQUIRED와 비슷하게 이미 시작된 트랜잭션이 있으면 참여한다.        
반면에 트랜잭션이 시작된 것이 없으면 새로 시작하는 대신 예외를 발생시킨다.        
혼자서는 독립적으로 트랜잭션을 진행하면 안 되는 경우에 사용한다.       

#### REQUIRES_NEW
항상 새로운 트랜잭션을 시작한다. 이미 진행 중인 트랜잭션이 있으면 트랜잭션을 잠시 보류시킨다.       
JTA 트랜잭션 매니저를 사용한다면 서버의 트랜잭션 매니저에 트랜잭션 보류가 가능하도록 설정되어 있어야 한다.       

#### NOT_SUPPORTED
트랜잭션을 사용하지 않게 한다. 이미 진행중인 트랜잭션이 있으면 보류시킨다.       

#### NEVER
트랜잭션을 사용하지 않도록 강제한다. 이미 진행 중인 트랜잭션도 존재하면 안된다. 만약 있다면 보류시킨다.       

#### NESTED
이미 진행중인 트랜잭션이 있으면 중첩 트랜잭션을 시작한다.       
중첩 트랜잭션은 트랜잭션 안에 다시 트랜잭션을 만드는 것이다.      
하지만 독립적인 트랜잭션을 만드는 REQUIRES_NEW와는 다르다.     

중첩된 트랜잭션은 먼저 시작된 부모 트랜잭션의 커밋과 롤백에는 영향을 받지만     
자신의 커밋과 롤백은 부모 트랜잭션에게 영향을 주지 않는다.  
 
중첩 트랜잭션은 JDBC 3.0 스펙의 저장포인트(savepoint)를 지원하는 드라이버와           
DataSourceTransactionManager 를 이용할 경우에 적용 가능하다.              
또는 중첩 트랜잭션을 지원하는 일부 WAS의 JTA 트랜잭션 매니저를 이용할 때도 적용할 수 있다.              
유용한 트랜잭션 전파 방식이지만 모든 트랜잭션 매니저에 다 적용 가능한 건 아니므로,               
적용하려면 사용할 트랜잭션 매니저와 드라이버, WAS의 문서를 참조해 보고,             
미리 학습 테스트를 만들어서 검증해봐야 한다.        

<br />
<br />

## 트랜잭션의 필요성 
* 현금 인출기를 작동하는 도중에 기계오류나 정전 등과 같은 예기치 않은 상황이 발생하여 카드가 나오지 않거나 기계가 멈추는 경우 
* 각각 다른 지점의 은행에서 동시에 인출할 때, 하나의 지점이 다른 지점에서 저장한 잔액을 덮어 쓰는 경우   
* 위와 같은 상황이 발생되지 않도록 방지하기 위해, 즉 트랜잭션의 성질인 ACID를 제공받기 위해 트랜잭션을 사용한다.

<br />
<br />

## 트랜잭션의 상태 
* 활동: 트랜잭션이 실행 중에 있는 상태, 연산들이 정상적으로 실행 중인 상태 
* 장애: 트랜잭션이 실행에 오류가 발생하여 중단된 상태 
* 철회: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태 
* 부분 완료: 트랜잭션이 마지막 연산까지 실행했지만, Commit 연산이 실행되기 직전의 상태 
* 완료: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태 

<br />
<br />

## 트랜잭션 격리 수준 
### Isolation Level
트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준   


### Isolation Level의 필요성 
* 데이터베이스는 ACID 같이 트랜잭션이 원자적이면서도 독립적인 수행을 하도록 한다. 
* 그래서 Locking 이라는 개념이 등장한다. 
    - Locking이란 트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 막는 것 
* 무조건적인 Locking으로 동시에 수행되는 많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어지게 된다. 
* 반대로 응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 수 있다.
 


### Isolation Level의 종류
* Read Uncommitted 
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 레벨 
    - 트랜잭션 처리중인 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다. 
    - 데이터 변경하는 동안 다른 사용자는 아직 완료되지 않은(Dirty) 데이터를 읽을 수 있다. 
    - 데이터베이스의 일관성을 유지할 수 없다. 
    - Dirty Read 
        + 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록 허용할 때 발생하는 현상 
        + 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의한 변경 사항을 보게 되는 경우 

    
* Read Committed
    - SELECT 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 레벨 
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다. 
    - Commit이 이루어진 트랜잭션만 조회할 수 있다. 
    - 데이터를 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다. 
    - SQL Server가 Default로 사용하는 Isolation Level
    - Non-Repeatable Read 
        + 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제함으로써   
          두 쿼리의 결과가 상이하게 나타나는 비일관성 현상     


* Repeatable Read 
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨 
    - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함을 보장한다. 
    - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다. 
    - Phantom Read 
         + 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽을 때, 첫 번째 쿼리에서 없던 레코드가 두 번째 쿼리에서 나타나는 현상 
         + 이는 트랜잭션 도중 새로운 레코드가 삽입되는 것을 허용하기 때문에 나타난다. 


* Serializable 
    - 트랜잭션이 완료될 때까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 레벨 
    - 완벽한 읽기 일관성 모드를 제공한다. 
    - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정 및 입력이 불가능하다. 
    

Isolation level 조정은 동시성이 증가되는데 반해 데이터 무결성 문제가 발생할 수 있고,   
데이터의 무결성을 유지하는 데 반해 동시성이 떨어질 수 있다.   
레벨이 높아질수록 비용이 높아진다.   

<br />
<br />

## 데이터베이스 풀
<https://hyerin6.github.io/2020-06-07/자바성능튜닝-DB/>  
<br />

#### Connection Pool 
* 클라이언트의 요청에 따라 각 어플리케이션의 스레드에서 데이터베이스에 접근하기 위해서는 Connection이 필요하다.        
* Connection pool은 이런 Connection을 여러 개 생성해놓고 저장해 놓은 **공간(캐시)**,         
  또는 이 공간의 Connection을 필요할 때 꺼내 쓰고 반환하는 기법을 말한다.       

#### DB에 접근하는 단계
(1) 웹 컨테이너가 실행되면 DB와 연결된 Connection 객체들을 미리 생성하여 pool에 저장한다.          
(2) DB 요청 시, pool에서 Connection 객체를 가져와 DB에 접근한다.      
(3) 처리가 끝나면 다시 pool을 반환한다.  

#### Connection이 부족할 때 
모든 요청이 DB에 접근하고 있고 남은 Connection이 없다면, 해당 클라이언트는 대기 상태로 전환시키고        
Pool에 Connection이 반환되면 대기 상태에 있는 클라이언트에게 순차적으로 제공된다.        

#### Connection Pool을 사용하는 이유 
* 매 연결마다 Connection 객체를 생성하고 소멸시키는 비용을 줄일 수 있다. 
* 미리 생성된 Connection 객체를 사용하기 때문에 DB 접근 시간이 단축된다. 
* DB에 접근하는 Connection의 수를 제한하여, 메모리와 DB에 걸리는 부하를 조정할 수 있다. 
* 한 번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 웹 어플리케이션이 쉽게 다운되지 않는다.  

#### Thread Pool       
* 비슷한 개념으로는 Tread pool이 있다.       
* Thread Pool은 매 요청마다 요청을 처리할 Thread를 만드는 것이 아닌         
미리 생성한 pool 내의 Thread를 소멸시키지 않고 재사용하여 효율적으로 자원을 활용하는 기법          


#### Thread Pool과 Connection pool 
* WAS에서 Thread pool과 Connection pool내의 Thread와 Connection의 수는 직접적으로 메모리와 관련이 있기 때문에,
  많이 사용하면 할수록 메모리를 많이 점유하게 된다. 그렇다고 반대로 메모리를 위해 적게 지정하면, 서버에는 많은 요청을 처리하지 못하고 대기할 수밖에 없다. 

* 보통 WAS의 Thread 수가 Connection의 수보다 많은 것이 좋다.            
  그 이유는 모든 요청이 DB에 접근하는 작업이 아니기 때문이다.     

<br />
<br />

## Join
한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것이다.  
<br />

#### 조인의 필요성
관계형 데이터베이스를 구축하기 위해서다.         
→ 관계형 데이터베이스의 구조적 특징으로 **정규화**를 수행하면서 **테이블이 구성**되고 테이블끼리 관계를 갖게 된다.             
→ 이와 같은 특징으로 관계형 데이터베이스는 저장공간의 효율성과 확장성이 향상되었다.      
→ 데이터가 중복되는 현상을 막고, 데이터 UPDATE시 변경의 연산이 적어지며 처리 속도 역시 빨라진다.

<br />  

## Join 종류
#### 내부 조인 (INNER JOIN)
* 기본 조인 형식이다. 
* 테이블 2개의 교집합을 구하는 것이다.  

<br />    


#### 외부 조인(OUTER JOIN)   
* 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용하여 효고적으로 결과 집합을 생성할 수 있다.   




* 왼쪽 외부 조인 (LEFT OUTER JOIN) 
    - 오른쪽 테이블에 조인할 칼럼의 값이 없는 경우 사용 
    - 왼쪽 테이블의 모든 데이터를 포함하는 결과 집합을 생성 
    - ```
        SELECT * 
        FROM employee LEFT OUTER JOIN deparatment 
        ON employee.department_id = department.id;
      ```




* 오른쪽 외부 조인 (RIGHT OUTER JOIN)  
    - 왼쪽 테이블에 조인할 칼럼의 값이 없는 경우 사용 
    - 오른쪽 테이블의 모든 데이터를 포함하는 결과 집합을 생성  
    - ```
        SELECT * 
        FROM employee RIGHT OUTER JOIN deparatment 
        ON employee.department_id = department.id;
      ```




* 완전 외부 조인 (FULL OUTER JOIN) 
    - 양쪽 테이블 모두 OUTER JOIN이 필요할 때 사용한다. 
    - MySQL에서는 FULL OUTER JOIN을 사용할 수 없기 때문에 `UNION` 키워드를 사용해야 한다. 
    - ```
        SELECT * FROM employee LEFT OUTER JOIN deparatment ON employee.department_id = department.id
        UNION
        SELECT * FROM employee RIGHT OUTER JOIN deparatment ON employee.department_id = department.id;
      ```

<br />
<br />

## Index
인덱스는 색인이라는 뜻으로 데이터베이스에서 조회 및 검색을 더 빠르게 할 수 있는 방법/기술, 혹은 이에 쓰이는 자료구조 자체를 의미하기도 한다.   

#### 사용 이유 
`SELECT` 문을 사용하여 원하는 조건의 데이터를 검색할 때, 저장된 데이터의 양이 많으면 검색을 위한 순회에 많은 자원과 시간이 소모될 것이다.   
자주 조회되는 컬럼에 대한 인덱스 테이블을 따로 만들어 `SELECT` 문이 들어왔을 때 인덱스 테이블에 있는 값들로 결과 값을 조회해 온다.   
인덱스를 잘 사용하면 검색 연산을 실행했을 때 성능을 올릴 수 있게 된다.   

#### 동작 
* Index Table에서 `WHERE`에 포함된 값을 검색 
* 해당 값의 table_id PK를 획득 
* 가져온 table_id PK 값으로 원본 테이블에서 값을 조회 

DBMS는 인덱스를 다양한 알고리즘으로 관리하는데 일반적으로 B+ Tree 알고리즘을 사용한다.       
B+ Tree는 실제 데이터가 저장된 리프 노트까지 포인터가 저장되어 있다.     
즉 루트 노드에서 어떤 리프 노드에 이르는 한 개의 경로만 탐색하면 되므로 매우 효율적이다.     

#### B+ Tree 사용 이유 
* SELECT 질의 조건에는 부등호 연산(`<`, `>`)도 포함되어 있다. 
* Hash Table은 동등 연산에 특화된 자료구조이기 때문에 부등호 연산 사용 시 문제 발생 


#### 주의할 점 
* 인덱스는 따로 테이블의 형태로 관리가 된다. 이는 자원을 소모한다는 의미이다. 
  그렇기 때문에 무분별한 인덱스 사용은 성능에 부정적인 영향을 미칠 수 있다.

* 인덱스는 이진트리를 사용하기 때문에 기본적으로 정렬되어 있다. 
  즉 검색과 조회의 속도를 향상시킬 수 있지만 잦은 데이터의 변경은 인덱스 테이블 변경과 정렬에 드는 오버헤드 때문에 오히려 성능이 저하될 수 있다.   

* 데이터의 중복이 높은 칼럼(카디널리티가 낮은 칼럼)은 인덱스로 만들어도 무용지물이다. (ex. 성별)

* 다중 칼럼 인덱싱할 때 카디널리티가 높은 칼럼에서 낮은 칼럼 순으로 인덱싱해야 효율적이다.  

<br />
<br />


## Statement와 PrepareStatement    
이 둘의 가장 큰 차이점은 캐시(cache) 사용 여부이다.   
이 둘을 사용할 때는 다음과 같은 프로세스를 거친다.  

(1) 쿼리 문장 분석  
(2) 컴파일    
(3) 실행    
Statement를 사용하면 매번 쿼리를 수행할 때마다 1~3 단계를 거치고    
PreparedStatement는 처음 한 번만 세 단계를 거친 후 캐시에 담아서 재사용 한다는 것이다.    

만약 같은 쿼리를 반복적으로 수행한다면 PreparedStatement가 DB에 훨씬 적은 부하를 주며, 성능도 좋다.    


<br />
<br />

## RDBMS vs NoSQL 
#### RDBMS
* 데이터의 무결성 보장

* 데이터의 중복을 막을 수 있다.

* 설계가 까다롭다.

* 관계형이다 보니 Join이 복잡하다.

* scale out이 힘들다.


#### NoSQL
* 데이터가 중복될 수 있다.

* scale out이 쉽다.

* 일관된 데이터를 보장하지 않는다.

<br />
<br />

## Replication vs Clustering
|      |                                             DB 클러스터링                                             |                                                                                                                                                                                        리플리케이션                                                                                                                                                                                        |
|:----:|:-----------------------------------------------------------------------------------------------------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| 대상 |                                            DB 서버를 다중화                                           |                                                                                                                                                                               DB 서버와 데이터를 같이 다중화                                                                                                                                                                               |
| 구조 |                                        수평적 구조 (Fail Over)                                        |                                                                                                                                                                                 수직적 구조 (Master-Slave)                                                                                                                                                                                 |
| 방식 |                                          동기 방식으로 동기화                                         |                                                                                                                                                                                   비동기 방식으로 동기화                                                                                                                                                                                   |
| 종류 |                                   Active - Active, Active - Standby                                   |                                                                                                                                                                                    단순 백업, 부하 분산                                                                                                                                                                                    |
| 장점 |                         일관성, 1개의 서버가 고장나도 시스템은 계속 사용 가능                         |                                                                                                                                                                                     시간 지연 거의 없음                                                                                                                                                                                    |
| 단점 |                                            동기화 시간 소요                                           |                                                                                                                                                                           일관성 없음,  Master 오류시 복구 어려움                                                                                                                                                                          |
| 구조 | <img width="400" src="https://blog.kakaocdn.net/dn/RzlBm/btqE5eTAFqI/Tj4FXxRUGG6l8JnvPkxclk/img.png"> | <img width="420" src="https://lh3.googleusercontent.com/proxy/0Mmh0N8UWQk6VOw0_0p-8PZA_GQ5R8rAPbDrvRWgt85XvhscuUJHVo0G6-6G7rdV2pfRMkGYMYNgxH4sedOYim1EXomoM910XHQhs9z8dE8WTFmYZvSrKX-n3Lo9uAM_D2lsGrM9fhcE3Ebx2q2CZvKhaOUQTSW4ULdXYpcL4J9K274zXV1GoZgfJ2zDqrvkFHGn6SNXA1c3zOWN1gSoqHeFFeeWQ-R6gNR5-Oc6SzuAiQhK_M3CYKdXwCmFbfTQq7FSuyYl_TK6vYJdOlluFZ3glr1U-oYtcbOrCLz71Dvq-FJTDFA3Tp5c6A"> |




<br />
<br />

## DB 파티셔닝 

<https://velog.io/@gillog/MySQL-Partition>  

#### 배경 
* 서비스의 크기가 점점 커지고 DB에 저장하는 데이터의 규모 또한 대용량화 되면서 기존에 사용하는 DB 시스템의 용량의 한계와 성능 저하가 발생했다.      
* 이런 이슈를 해결하기 위한 방법으로 테이블을 파티션이라는 작은 단위로 나누어 관리하는 파티셔닝 기법이 나타난 것이다.      


#### 개념 
* DB 파티셔닝은 큰 테이블이나 인덱스를 관리하기 쉬운 partition이라는 작은 단위로 물리적으로 분할하는 것을 의미한다.   
* MySQL Server에서는 데이터를 별도의 테이블로 분리해서 저장하지만 사용자는 여전히 하나의 테이블로 읽기와 쓰기를 할 수 있게 해주는 솔루션 
* Partition은 DBMS 하나의 서버에서 테이블을 분산하는 것이다.
   - 원격 서버 간에 분산을 지원하는 것은 아님
* 파티셔닝 기법을 통해 데이터베이스를 분산처리하여 성능이 저하되는 것을 방지, 관리가 수월해졌다.   


#### 파티셔닝 목적 
  + 성능 
    - 특정 DML과 Query의 성능을 향상시킨다.
    - 주로 대용량 Data Write 환경에서 효율적이다.
    - 특히 Full Scan에서 데이터 access의 범위를 줄려 성능 향상을 가져온다.
    - 많은 INSERT가 있는 OLTP 시스템에서 INSERT 작업을 작은 단위인 partition들로 분산시켜 경합을 줄인다.     


  + 가용성 
    - 물리적인 파티셔닝으로 인해 전체 데이터의 훼손 가능성이 줄어들고 데이터 가용성이 향상된다. 
    - 각 분할 영역을 독립적으로 백업하고 복구할 수 있다. 
    - 테이블의 partition 단위로 Disk I/O을 분산하여 경합을 줄이기 때문에 UPDATE 성능을 향상시킨다. 

  
  + 관리용이성 
    - 큰 테이블을 제거하여 관리를 쉽게 해준다. 
    

#### 파티셔닝의 장점 
* 관리적 측면: partition 단위 백업, 추가, 삭제, 변경 
  - 전체 데이터를 손실할 가능성이 줄어들어 데이터 가용성이 향상된다. 
  - partition 별로 백업 및 복구가 가능하다. 
  - partition 단위로 I/O 분산이 가능하여 UPDATE 성능을 향상시킨다. 
  
    
* 성능적 측면: partition 단위 조회 및 DML 수행 
  - 데이터 전체 검색 시 필요한 부분만 탐색해 성능이 증가한다. 
  - Full Scan에서 데이터 Access 범위를 줄여 성능 향상을 가져온다. 
  - 필요한 데이터만 빠르게 조회할 수 있기 때문에 쿼리 자체가 가볍다. 
  

#### 파티셔닝의 단점 
* 테이블간 JOIN에 대한 비용이 증가한다. 
* 테이블과 인덱스를 별도로 파티셔닝할 수 없다. 


#### 파티셔닝의 종류 
* 수평 파티셔닝 
  - 샤딩과 동일한 개념 

* 수직 파티셔닝


<img width="500" src="https://user-images.githubusercontent.com/33855307/146133645-2f0b0a74-c2cd-437d-ab0f-762e80cec915.jpg">


#### Partition을 사용하는 대표적인 예 
* 하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 큰 경우

* 데이터 특성상 주기적인 삭제 작업이 필요한 경우

<br />
<br />

## 샤딩(Sharding)
* 여러 DB에 데이터를 물리적으로 수평 분할 방식으로 분산 저장/조회하는 것 


* 트래픽 분산 목적으로 사용
    - 데이터베이스에 데이터 증가 → 용량 이슈, CRUD 성능 저하


* 애플리케이션 서버 레벨에서 구현하는 경우가 많았으나 최근 플랫폼에서도 제공 
    - Hibernate Shards, Spock Proxy(MySQL Proxy 기반), Gizzard(Twitter)  


* 예) 주민 테이블 → a동 테이블은 A DB, b동 테이블은 B DB에 저장 

<br />
<br />

## ORM 
**Object Relational Mapping 객체-관계 매핑**   
객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 것을 말한다. 


#### 영속성(persistence)
* 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성 
* 영속성을 갖지 않는 데이터는 단지 메모리에서만 존재하기 때문에 프로그램을 종료하면 모두 잃어버리게 된다. 
* 파일, 데이터베이스 등을 활용하여 데이터를 영구하가ㅔ 저장하여 영속성을 부여한다. 


#### persistence framework 
JDBC 프로그래밍의 복잡함이나 번거로움 없이 간단한 작업만으로 데이터베이스와 연동되는 시스템을 빠르게 개발할 수 있으며 안정적인 구동을 보장한다. 

* Mybatis: SQL 문장을 직접 다우는 SQL 매퍼 
* Hibernate: 객체를 통해 간접적으로 데이터베이스를 다루는 객체 관계 맵퍼

#### 장점 
* 객체지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 한다.
   - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
   - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
   - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
  


* 재사용 및 유지보수의 편리성이 증가한다. 
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.
    - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.



* DBMS에 대한 종속성이 줄어든다. 
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
    - 또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.



#### 단점 
* 완벽한 ORM 으로만 서비스를 구현하기가 어렵다.
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)

  

* 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.


<br />
<br />

## JDBC 
JDBC(Java Database Connectivity)는 DB에 접근할 수 있도록 Java에서 제공하는 API이다.  


<br />
<br />
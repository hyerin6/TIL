# Network    
<br />     

* [기본 개념](https://github.com/hyerin6/TIL/blob/main/Network/기본개념.md)   
* [HTTP](https://github.com/hyerin6/TIL/blob/main/Network/HTTP.md)

<br />  

## OSI 7계층   
* 국제표준화기구에서 개발한 모델로 컴퓨터 네트워크 프로토콜 디자인과 통신을 계층으로 나누어 설명한 것이다.    
* 각 계층은 하위 계층의 기능만을 이용하고, 상위 계층에게 기능을 제공한다.   
* 따라서 각 계층이 독립되어있기때문에 다른 계층에 영향없이 수정 가능하다.
* 단점으로는, 많은 계층들로 인해 유발되는 딜레이로 발생하는 오버헤드가 있다. 

<br />    


(1) 물리 계층   
* 네트워크의 기본 네트워크 하드웨어 전송 기술을 이룬다. 
* 네트워크의 높은 수준의 기능의 논리 데이터 구조를 기초로 하는 필수 계층이다. 


(2) 데이터 링크 계층 
* 주소 값을 물리적으로 할당 받는데, 이는 네트워크 카드가 만들어질 때부터 맥 주소(MAC address)가 정해져 있다는 뜻이다. 
* 예) Ethernet
* 데이터 전송 단위는 Frame이다.   


(3) 네트워크 계층 
* 여러개의 노드를 거칠때마다 경로를 찾아주는 역할을 하는 계층으로 다양한 길이의 데이터를 네트워크들을 통해 전달한다.  
* 데이터 전송 단위는 Datagram(packet)이다. 


(4) 전송 계층 
* 양 끝단의 사용자들이 신뢰성있는 데이터를 주고 받을 수 있도록 한다.   
* 예) TCP 
* 데이터 전송 단위는 Segment 이다. 


(5) 세션 계층 
* 양 끝단의 응용 프로세스가 통신을 관리하기 위한 방법을 제공한다. 
* 이 계층은 TCP/IP 세션을 만들고 없애는 책임을 진다. 


(6) 표현 계층 
* 코드 간의 번역을 담당하여 사용자 시스템에서 데이터의 형식상 차이를 다루는 부담을 응용 계층으로부터 덜어 준다. 

(7) 응용 계층 
* 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다. 

<br />
<br />

## TCP와 UDP 
네트워크 계층 중 전송 계층에서 사용하는 프로토콜 
* TCP
    - 인터넷 상에서 데이터를 메세지 형태(세그먼트라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다. 
    - TCP와 IP를 함께 사용하는데 IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다. 
    - 연결형 서비스로 가상 회선 방식을 제공한다. 
         + 3-way handshaking 과정을 통해 연결을 설정하고, 4-way handshaking을 통해 해제한다.
    - 높은 신뢰성을 보장하지만 UDP보다 속도가 느리다. 
    - 연속성보다 신뢰성있는 전송이 중요할 때 사용된다. 
  
* UDP 
    - 데이터를 데이터그램 단위로 처리하는 프로토콜이다. 
    - 비연결형 서비스로 데이터그램 방식을 제공한다. 
    - 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다. 
    - 신뢰성이 낮지만 TCP보다 속도가 빠르다. 
    - 신뢰성보다는 연속성이 중요한 서비스, 예를들면 실시간 서비스에 사용된다. 
  
<br />
<br />

## TCP의 3 way handshake와 4 way handshake  
TCP는 장치들 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 연결형 서비스이다.   

#### 3 way handshake
* TCP 통신을 이용하여 데이터를 전송하기 위해 네트워크 연결을 설정하는 과정 
* 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작하기 전에 한쪽이 다른쪽이 준비되었다는 것을 알 수 있도록 한다.    
* 즉 TCP/IP 프로토콜을 이용해서 통신을 하는 응용 프로그램이 데이터를 전송하기 전에 
  먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.   

#### 4 way handshake
* TCP의 연결을 해제하는 과정   

####  TCP의 연결 설정 과정과 연결 종료 과정의 단계가 차이나는 이유 
Client가 데이터 전송을 마쳤다고 하더라도 Server는 아직 보낼 데이터가 남아있을 수 있기 때문에      
일단 FIN에 대한 ACK만 보내고 데이터를 모두 전송한 후에 자신도 FIN 메시지를 보내기 때문이다.        

<br />
<br />

## HTTP와 HTTPS 
#### HTTP 프로토콜 
* HyperText Transfer Protocol 
* 웹 상에서 클라이언트와 서버 간에 요청/응답으로 정보를 주고 받을 수 있는 프로토콜 
* TCP와 UDP를 사용하며, 80번 포트를 사용한다. 
* 비연결 
    - 클라이언트가 요청을 서버에 보내고 서버가 적절한 응답을 클라이언트에 보내면 바로 연결이 끊긴다. 
* 무상태 
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다. 

<br />

#### HTTPS 프로토콜 
* HyperText Transfer Protocol over Secure Socket Layer 
* 웹 통신 프로토콜인 HTTP의 보안이 강화된 버전의 프로토콜 
* HTTPS의 기본 TCP/IP 포트로 443번 포트를 사용한다. 
* HTTPS는 소켓 통신에서 일반 텍스트를 이용하는 대신에 웹 상에서 정보를 암호화하는 SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화한다.   
* 보호의 수준은 웹 브라우저에서의 구현 정확도와 서버 소프트웨어, 지원하는 암호화 알고리즘에 달려있다. 

<br />

#### HTTPS가 필요한 이유
* 클라이언트인 웹브라우저가 서버에 HTTP를 통해 웹 페이지나 이미지 정보를 요청하면 서버는 이 요청에 응답하여 요구하는 정보를 제공하게 된다.   
* 웹 페이지는 텍스트이고 HTTP를 통해 이런 텍스트 정보를 교환하는 것이다.  
* 이때 주고받는 텍스트 정보에 주민등록번호나 비밀번호와 같은 민감한 정보가 포함된 상태에서 네트워크 상에서 중간에 제 3자가 정보를 가로챈다면 큰 문제가 발생한다.    
* 즉 중간에서 정보를 볼 수 없도록 주고받는 정보를 암호화하는 방법인 HTTPS를 사용하는 것이다.   

<br />

#### HTTPS 장단점 
* 장점 
  - 네트워크 상에서 열람, 수정이 불가능하므로 안전하다. 
  
* 단점 
  - 암호화하는 과정이 웹 서버에 부하를 준다. 
  - HTTPS는 설치 및 인증서를 유지하는데 추가 비용이 발생한다. 
  - HTTP에 비해 느리다. 
  - 인터넷 연결이 끊긴 경우 재인증 시간이 소요된다. 
  
<br />
<br />


## HTTP와 HTTPS 동작 과정 
#### HTTP 동작 과정 
`서버 접속` → `클라이언트` → `요청` → `서버` → `응답` → `클라이언트` → `연결 종료`  
<br />  

1) 사용자가 웹 브라우저에 URL 주소 입력    


2) DNS 서버에 웹 서버의 호스트 이름을 IP 주소로 변경 요청 


3) 웹 서버와 TCP 연결 시도      
    * 3way-handshaking    

    
4) 클라이언트가 서버에게 요청 
    * HTTP Request Message = Request Header + 빈줄 + Request Body 
    * Request Header 
         - 요청 메소드 + 요청 URI + HTTP 프로토콜 버전 
         - ex) `GET /background.png HTTP/1.0` `POST / HTTP 1.1`
         - Header 정보 (key-value 구조)
    * 빈줄: 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도 
    * Request Body 
         - GET, HEAD, DELETE, OPTIONS 처럼 리소스를 가져오는 요청은 바디 미포함 
         - 데이터 업데이터 요청과 관련된 내용(HTML form 컨텐츠 등)  
    

5) 서버가 클라이언트에게 데이터 응답
    * HTTP Response Message = Response Header + 빈줄 + Response Body 
    * Response Header 
        - HTTP 프로토콜 버전 + 응답 코드 + 응답 메시지 
        - ex) `HTTP/1.1 404 Not Found.`
        - Header 정보 (key-value 구조)
    * 빈줄: 요청에 대한 모든 메타 정보가 전송되었음을 알리는 용도 
    * Response Body: 응답 리소스 데이터 (201, 204 상태 코드는 바디 미포함)


6) 서버 클라이언트 간 연결 종료 
    * 4way-handshaking 


7) 웹 브라우저가 웹 문서 출력 

<br />

#### HTTPS(SSL) 동작 과정 
공개키 암호화 방식과 대칭키 암호화 방식의 장점을 활용해 하이브리드 사용    
데이터를 대칭키 방식으로 암복호화하고, 공개키 방식으로 대칭키 전달    
<br />

1) 클라이언트가 서버 접속하여 Handshaking 과정에서 서로 탐색   
    1-1) Client Hello 
      * 클라이언트가 서버에게 전송할 데이터 
        - 클라이언트 측에서 생성한 랜덤 데이터 
        - 클라이언트-서버 암호화 방식 통일을 위해 클라이언트가 싸용할 수 있는 암호화 방식 
        - 이전에 이미 Handshaking 기록이 있다면 자원 절약을 위해 기존 세션을 재활용하기 위한 세션 아이디     
        
    1-2) Server Hello       
    * Client Hello에 대한 응답으로 전송할 데이터     
      - 서버 측에서 생성한 랜덤 데이터   
      - 서버가 선택한 클라이언트의 암호화 방식      
      - SSL 인증서     
      
    1-3) Client 인증 확인 
      * 서버로부터 받은 인증서가 CA에 의해 발급되었는지 본인이 가지고 있는 목록에서 확인하고,   
        목록에 있다면 CA 공개키로 인증서 복호화 
      * 클라이언트-서버 각각의 랜덤 데이터를 조합해 pre master secret 값 생성 (데이터 송수신 시 대칭키 암호화에 사용할 키)
      * pre master secret 값을 공개키 방식으로 서버 전달 (공개키는 서버로부터 받은 인증서에 포함)
      * 일련의 과정을 거쳐 session key 생성 
   
    1-4) Server 인증 확인 
      * 서버는 비공개키로 복호화하여 pre master secret 값 취득 (대칭키 공유 완료)
      * 일련의 과정을 거쳐 session key 생성 
   
    1-5) Handshaking 종료 


2) 데이터 전송  
서버와 클라이언트는 session key를 활용해 데이터를 암복호화하여 데이터 송수신 


3) 연결 종료 및 session key 폐기 


<br />
<br />

## CORS
CORS(Cross Origin Resource Sharing)란 웹 서버에게 보안 cross-domain 데이터 전송을 활성화하는 cross-domain 접근 제어권을 부여한다.       

#### 배경
처음 전송되는 리소스의 도메인과 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청에 의해 요청된다.           
보안 상의 이유로 브라우저들은 스크립트 내에서 초기화되는 cross-origin HTTP 요청을 제한한다.            

예) XMLHttpRequest는 same-origin 정책을 따르기 때문에            
XMLHttpRequest을 사용하는 웹 애플리케이션은 자신과 동일한 도메인으로 HTTP 요청을 보내는 것만 가능했다.         

웹 애플리케이션을 개선시키기 위해, 개발자들은 벤더사들에게 XMLHttpRequest가 cross-domain 요청을 할 수 있도록 요청했고 이에따라 CORS가 생겼다. 

#### 과정 
* CORS 요청 시 미리 OPTIONS 주소로 서버가 CORS를 허용하는지 물어본다. 
* 이때 Access-Control-Request-Method로 보내고자 하는 메서드를 알리고,
* Access-Control-Request-Headers로 보내고자 하는 레더들을 알린다. 
* Allow 항목들은 Request에 대응되는 것으로, 서버가 허용하는 메서드와 헤더를 응답하는데 사용된다 
* Reuqest랑 Allow가 일치하면 CORS 요청이 이루어진다. 

<br />
<br />

## GET 메서드와 POST 메서드 
HTTP 프로토콜을 이용해서 서버에 데이터(요청 정보)를 전달할 때 사용하는 방식 

* GET 메서드 
  - 정보를 조회하기 위한 메서드 
  - URL에 데이터를 포함시켜 요청한다. (query string)
  - 요청 정보를 사용자가 쉽게 확인이 가능하다. 
  - POST 방식보다 보안이 취약하다.
  - HTTP 패킷의 Body는 비어 있는 상태로 전송한다. 
    즉 Body의 데이터 타입을 표현하는 `Content-Type` 필드도 HTTP Request Header에 들어가지 않는다. 
  - GET 방식은 캐싱을 사용할 수 있어 GET 요청과 그에 대한 응답이 브라우저에 의해 캐시된다. (POST 보다 빠르다.)

* POST 메서드 
  - 서버의 값이나 상태를 바꾸기 위한 용도의 메서드 
  - 요청 정보를 HTTP 패킷의 Body 안에 숨겨서 서버로 전송한다. 
  - Request Header의 `Content-Type`에 해당 데이터 타입이 표현되며, 전송하고자 하는 데이터 타입을 적어주어야 한다. 
  - Body 안에 숨겨서 요청 정보를 전송하기 때문에 대용량의 데이터를 전송하기에 적합하다. 
  - 클라이언트 쪽에서 데이터를 인코딩하여 서버로 전송하고, 이를 받은 서버 쪽이 해당 데이터를 디코딩한다. 
  - GET 방식보다 보안상 안전하다. 


#### 조회하기 위해 POST 방식이 아닌 GET 방식을 사용하는 이유
* 설계 원칙에 따라 GET 방식은 서버에게 여러 번 요청을 하더라도 동일한 응답이 돌아와야 한다. (Idempotent, 멱등성)        
* Get 방식은 가져오는 것으로 서버의 데이터나 상태를 변경시키지 않아야 한다.         
* POST 방식은 수행하는 것으로 서버의 값이나 상태를 바꾸기 위한 용도이다.        
* 웹에서 모든 리소스는 Link할 수 있는 URL을 가지고 있어야 한다.      
    - 어떤 웹페이지를 보고 있을 때 다른 사람한테 그 주소를 주기 위해서 주소창의 URL을 복사해서 줄 수 있어야 한다.       
    - 즉 어떤 웹페이지를 조회할 때 원하는 페이지로 바로 이동하거나 이동시키기 위해서는 해당 링크의 정보가 필요하다.      
    - 이때 POST 방식을 사용할 경우 값(링크의 정보)이 Body에 있기 때문에 URL만 전달할 수 없으므로 GET 방식을 사용해야 한다.         
      그러나 글을 저장하는 경우에는 URL을 제공할 필요가 없기 때문에 POST 방식을 사용한다.   

<br />
<br />

## 쿠키와 세션 
#### HTTP 프로토콜의 특징 
* 비연결 지향(Connectionless) 
    - 클라이언트가 Request를 서버에 보내고 서버가 클라이언트의 요청에 맞는 Response를 보내ㅐ면 바로 연결을 끊는다. 
* 상태정보 유지 안함(Stateless)
    - 연결을 끊는 순간 클라이언트와 서버의 통신은 끝나며 상태 정보를 유지하지 않는다. 

<br />

#### 쿠키와 세션의 필요성 
* HTTP 프로토콜은 위와 같은 특징으로 모든 요청 간 의존관계가 없다. 
* 즉 현재 접속한 사용자가 이전에 접속했던 사용자와 같은 사용자인지 아닌지 알 수 있는 방법이 없다. 
* 계속해서 연결을 유지하지 않기 때문에 리소스 낭비가 줄어드는 것이 큰 장점이지만, 
  통신할 때마다 새로 연결하기 때문에 클라이언트는 매 요청마다 인증을 해야 한다는 단점이 있다. 
* 이전 요청과 현재 요청이 같은 사용자의 요청인지 알기 위해서는 상태를 유지해야 한다. 
* HTTP 프로토콜에서 상태를 유지하기 위한 기술로 쿠키와 세션이 있다. 

<br />

#### 쿠키(cookie) 
* 클라이언트 로컬에 저장되는 키와 값이 들어있는 파일 
* 이름, 값, 유효시간, 경로 등을 포함 
* 클라이언트의 상태 정보를 브라우저에 저장하여 참조한다. 
* 동작 방식 
    - a. 웹브라우저가 서버에 요청 
    - b. 상태를 유지하고 싶은 값을 쿠키로 생성 
    - c. 서버가 응답할 때 HTTP 헤더(set-cookie)에 쿠키를 포함해서 전송
    - d. 전달받은 쿠키는 웹브라우저에서 관리하고 있다가 다음 요청 때 쿠키를 HTTP 헤더에 넣어서 전송
    - e. 서버에서는 쿠키 정보를 읽어 이전 상태 정보를 확인한 후 응답 
* 예) 아이디, 비밀번호 저장 / 쇼핑몰 장바구니 

<br />

#### 세션(session)
* 일정 시간 동안 같은 브라우저로부터 들어오는 요청을 하나의 상태로 보고 그 상태를 유지하는 기술이다. 
* 웹 브라우저를 통해 서버에 접속한 이후부터 브라우저를 종료할 때까지 유지되는 상태이다. 
* 동작 방식 
    - a. 웹 브라우저가 서버에 요청 
    - b. 서버가 해당 웹브라우저(클라이언트)에 유일한 ID(Session ID)를 부여함 
    - c. 서버가 응답할 때 HTTP 헤더에 Session ID를 포함해서 전송 
      쿠키에 Session ID를 JSESSIONID라는 이름으로 저장 
    - d. 웹브라우저는 이후 웹브라우저를 닫기까지 다음 요청 때 부여된 Session ID가 담겨있는 쿠키를 HTTP 헤더에 넣어서 전송 
    - e. 서버는 세션 ID를 확인하고, 해당 세션에 관련된 정보를 확인한 후 응답 
* 예) 로그인 

<br />

#### 쿠키와 세션의 차이점 
* 저장 위치 
* 보안 
    - 쿠키: 클라이언트에 저장되므로 보안에 취약하다. 
    - 세션: 쿠키를 이용해 Session ID만 저장하고 이 값으로 구분해서 서버에서 처리하므로 비교적 보안성이 좋다. 
* 라이프사이클 
    - 쿠키: 만료시간에 따라 브라우저를 종료해도 계속해서 남아 있을 수 있다. 
    - 세션: 만료시간을 정할 수 있지만 브라우저가 종료되면 만료시간에 상관없이 삭제된다. 
* 속도 
    - 쿠키: 클라이언트에 저장되어 있어 서버에 요청 시 빠르다. 
    - 세션: 실제 저장된 정보가 서버에 있으므로 서버의 처리가 필요해 쿠키보다 느리다. 


<br />
<br />

## REST와 RESTful 
#### REST 
* Representational State Transfer의 약자 
* REST는 기본적으로 웹의 기존 기술과 HTTP 프로토콜을 그대로 활용하기 때문에 웹의 장점을 최대한 활용할 수 있는 아키텍처 스타일이다. 
* REST는 네트워크 상에서 Client와 Server 사이의 통신 방식 중 하나이다. 
* HTTP URL을 통해 자원을 명시하고, HTTP method를 통해 해당 자원에 대한 CRUD 연산을 적용하는 것을 의미한다. 
* 특징 
  - server-client 구조 
  - stateless(무상태)
  - 캐시 처리 가능 
  - 계층화 
  - code-on-demand(optional)
  - 인터페이스 일관성 

<br />

#### REST API
* REST 기반으로 서비스 API를 구현한 것 
* REST 기반으로 시스템을 분산해 확장성과 재사용성을 높여 유지보수 및 운용을 편리하게 할 수 있다. 
* REST는 HTTP 표준을 기반으로 구현하므로 HTTP를 지원하는 프로그램 언어로 클라이언트, 서버를 구현할 수 있다. 
* REST API를 제작하면 델파이 클라이언트 뿐 아니라 자바, C#, 웹 등을 이용해 클라이언트를 제작할 수 있다. 

<br />

#### REST API 설계 기본 규칙 
* URI는 정보의 자원을 표현해야 한다. 
* 자원에 대한 행위는 HTTP Method로 표현한다. 

<br />

#### RESTful
* RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. 
* RESTful의 목적 
  - 이해하기 쉽고 사용하기 쉬운 REST API를 만드는 것 
  - RESTful API를 구현하는 근본적인 목적이 퍼포먼스 향상에 있는게 아니라, 일관적인 컨벤션을 통한 API의 이해도 및 호환성을 높이는 것 
* RESTful 하지 못한 경우 
  - CRUD 전부 POST로만 처리하는 API
  - route에 resource, id 외의 정보가 들어가는 경우 (/students/updateName)

<br />
<br />


## Forward와 Redirect 차이
#### Forward 
forward는 Web Container 차원에서 페이지의 이동만 존재한다.    
실제로 웹 브라우저는 다른 페이지로 이동했음을 알 수 없고,   
웹 브라우저에 최초에 호출한 URL이 표시되고 이동한 페이지의 URL 정보는 확인할 수 없다.    
현재 실행 중인 페이지와 forward에 의해 호출될 페이지는 Request 객체와 Response 객체를 공유한다.   

예를 들어 게시판을 작성하는 과정이라고 할 때, 사용자가 보낸 요청 정보를 이용하여 글쓰기 기능을 수행한다고 할 때,      
forward를 사용하여 응답 페이지를 부르면 요청 정보가 그대로 살아있기 때문에 요청이 여러 번 전달되어   
동일한 게시물이 여러 번 등록될 수 있다.     

시스템에 변화가 생기지 않는 단순 조회 요청(글 목록 보기, 검색)의 경우 forward로 응답하는 것이 바람직합니다.

<br />

#### Redirect  
redirect은 Web Container로 명령이 들어오면, 웹 브라우저에게 다른 페이지로 이동하라고 명령을 내린다.     
웹 브라우저는 URL을 지시된 주소로 바꾸고 해당 주소로 이동한다.          
다른 Web Container에 있는 주소로 이동하며 새로운 페이지에서는 Request와 Response 객체가 새롭게 생성된다.       

redirect의 경우 최초 요청을 받은 URL1에서 클라이언트에게 redirect할 URL2를 반환하고  
클라이언트에서는 새로운 요청을 생성하여 URL2에 다시 요청을 보낸다.   
따라서 최초의 Request와 Response 객체는 유효하지 않고 새롭게 생성된다.    

시스템에 변화가 생기는 요청(회원가입, 글쓰기 등)의 경우 리다이렉션을 사용하는 것이 바람직하다.   

<br />
<br />

## DNS  
도메인 이름을 IP 주소로 변환하여 브라우저에 전달하는 역할을 하는 시스템이다.   
`208.201.239.101`과 같이 숫자로 된 인터넷 주소를 `www.oreilly.com`처럼 사람이 쉽게 기억할 수 있는 호스트 네임으로 변환해준다.   

* 내부 DNS: 여러 도메인 항목이 있는 경우 내부 도메인 이름 확인을 위해 작동한다.
* 외부 DNS: 동일한 네트워크에 있지 않거나 인터넷 탐색 시 외부 DNS 확인이 필요하다.  

<br />
<br />

## Gateway 
컴퓨터 네트워크에서 서로 다른 통신망, 프로토콜을 사용하는 네트워크 간의 통신을 가능하게 하는 컴퓨터나 소프트웨어를 말한다.     
넓은 의미로 종류가 다른 네트워크 간의 통로의 역할을 하는 장치이다.      
즉 게이트웨이는 서로 다른 네트워크 상의 통신 프로토콜을 적절히 변환해주는 역할을 한다.     


<br />
<br />

## Proxy  
<https://github.com/hyerin6/TIL/blob/main/Network/기본개념.md#4-proxy-서버>  

프록시 서버는 내부와 외부 사이의 중계자 역할을 한다.       

* 프록시 서버는 애플리케이션에서 동작한다.      
* 프록시 서버는 캐시(cache)를 구현하기 위해 사용되기도 한다.    
 

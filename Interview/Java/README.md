# Java
### 특징
* 객체지향 프로그래밍 언어
* 컴파일 언어
* JVM만 있으면 OS와 상관없이 동작 가능 (운영체제에서 독립적)
* 고성능: 바이트코드로 변환되어 실행
* 멀티 스레딩 지원

<br />

### JVM
* 자바 프로그램을 실행하는 역할
* 컴파일러를 통해 바이트코드로 변환된 파일을 JVM에 로딩하여 실행
* Garbage Collection 수행 (메모리 관리)
* Class Loader - JVM내 (Runtime Data Area)로 class 파일을 로드하고 링크(Linking)
* Excution Engine - 메모리(Runtime Data Area)에 적재된 클래스들을 기계어로 변경해 실행
* Garbage Collector - 힙 메모리에서 참조되지 않는 객체를 제거
* Runtime Data Area - 자바 프로그램을 실행할 때, 데이터를 저장

<br />

### Java 프로그램 실행 과정
(1) JVM은 OS로부터 메모리(Runtime Data Area)를 할당받는다.    
(2) 컴파일러(javac)가 소스코드(.java)를 읽어서 바이트코드(.class)로 변환   
(3) Class Loader를 통해 Class 파일을 JVM 내의 Runtime Data Area에 로딩      
(4) 로딩된 Class 파일을 Excution Engine을 사용해 해석 및 실행

<br />

### JVM 메모리 (Runtime Data Area) 구조
메소드(static)영역, JVM 스택, JVM힙

* 메소드 영역
    - 클래스가 사용되면 해당 클래스의 클래스 파일(.class)을 읽어들여, 클래스에 대한 정보(바이트코드)를 static 영역에 저장
    - 클래스와 인터페이스(타입 정보), 메소드(이름, 리턴 타입, 접근 제어자 등), 필드, static 변수, final class 변수
    - 런타임 상수 풀(클래스와 인터페이스의 상수, 메소드/필드에 대한 모든 레퍼런스): JVM이 이를 이용해 실제 메모리 주소를 찾아 참조


* JVM 스택
    - 스레드마다 존재, 스레드가 시작할 때 할당, LIFO
    - 지역변수, 매개변수, 연산 중 발생하는 임시 데이터 저장
    - 메소드 호출 시마다 개별적 스택 생성
    - 기본 타입 변수: 스택에 값 저장
    - 참조 타입 변수: 힙이나 메소드 영역 객체의 주소 저장


* JVM 힙
    - 런타임 시 동적으로 할당하여 사용하는 영역
    - New 연산자로 생성된 객체와 배열 저장
    - 힙 영역의 객체와 배열은 스택의 변수나 다른 객체에서 참조, 참조가 없으면 GC의 대상

<br />

### 변수 종류 & 메모리 구조
* 인스턴스 변수: 객체에서 사용되는 변수, 힙 영역
* 클래스 변수: static 변수, 메소드 영역 
* 지역변수: 메소드 내에서 선언되는 변수, 스택 영역 

<br />

### Java에서 GC가 필요한 이유  
자바는 메모리를 명시적으로 해제하지 않기 때문에 GC를 통해서 필요없는 객체를 지운다.   
더이상 사용하지 않는 동적 할당된 메모리 블럭(heap)을 찾아 다시 사용 가능한 자원으로 회수한다.   

<br />

### Java GC 동작 방식   
(1) 새롭게 생성된 객체는 Young의 Eden 영역에 저장     

(2) Eden 영역이 다 차면 Minor GC가 발생하여 참조 횟수에 따라 증가하는 age bit을 보고   
불필요한 객체는 삭제하고 생존하는 객체는 S0으로 이동한다.     

(3) Minor GC가 발생할 때마다 Young 영역의 객체들은 삭제와 이동을 한다.     
(Eden ➡️ S0 / S0 ➡️ S1 / S0 ⬅️ S1) 

(4) S1이 가득차면 불필요한 객체는 Old 영역으로 이동하고 Old 영역이 가득차면 Major GC를 통해서 값을 삭제한다.   

(5) GC가 실행될 때마다 STOP THE WORLD가 발생하여 프로그램이 중지된다.   

<br />

### 추상 클래스와 인터페이스   
#### Q. 추상 클래스란?   
* 반드시 구현(오버라이딩)해야하는 추상 메소드를 1개 이상 갖고 있는 클래스 
* 사용이유 
    - 필드와 메소드 통일 - 유지보수성 향상 및 통일성 유지   
    - 규격에 맞는 실체 클래스 구현   
    - 상속 받아서 기능을 확장시키는게 목적이다.


#### Q. 인터페이스란?     
* 어떤 메소드를 제공하는지 알려주는 명세 (Specification)    
* 상속 관계가 없는 클래스에서 공통되는 로직을 구현하여 사용   
* 사용이유 
    - 동일한 목적 하에 동일한 기능을 보장하는 것 - 메소드를 구현하는 것에 초점 
    - 다형성 극대화 - 코드 수정 감소, 유지보수성 증가  
  

#### 공통점 
* 독립적으로 객체 생성 불가, 상속을 목적으로 사용   
* 추상 메소드는 오버라이딩 필요  


#### 차이점 
* 추상 클래스는 상속을 통해 기능을 확장하는 것이 목적 
* 인터페이스는 추상 클래스와 달리 구현을 강제함으로써 구현 객체의 같은 동작을 보장하며   
인터페이스를 이용하여 표준화를 확립시킬 수 있으므로 서로 관계가 없는 객체들이 상호작용을 가능하게 한다.   

<br />

### Vector와 ArrayList 차이
* Vector: Thread-Safe
* ArrayList: Thread-Safe 하지 않음 

<br />

### Hash Map과 Hash Table의 차이
* Hash Map: 메소드 동기화를 지원하지 않음, Thread Safe 아님, 성능 빠름
* Hash Table: 메소드 동기화 지원, Thread Safe, 성능 느림

<br />

### Hash Map과 Tree Map의 차이
* Hash Map: 해싱 구현, 랜덤 정렬(순서 유지안됨), Null 키 가능, 훨씬 빠름
* Tree Map: 레드블랙트리(이진탐색트리)로 구현, key로 자동 정렬, Null 키 불가능

<br />

### Hash Set과 Tree Set의 차이
* Hash Set: 해싱으로 구현, 삽입된 요소는 랜덤 정렬, Null 저장 가능, 성능 빠름, 값 비교에 equals 사용
* Tree Set: 레드블랙트리(이진탐색트리) 구현, 정렬 순서 유지(자동 정렬), Null 저장 불가, 성능 느림, 값 비교에 comparedTo 사용

<br />

### Generic  
* 제네릭은 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에서 사용하는 것으로, 컴파일 과정에서 타입을 체크하는 기능
* 클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법
* 사용 이유
    - 잘못된 타입이 사용될 문제를 컴파일 과정에서 제거 가능
    - 코드 재사용성 증가

<br />

### Access Modifier(접근 제한자)  
* public: 모든 클래스에서 접근할 수 있다는 것을 의미(패키지가 달라도 허용)
* protected: 같은 클래스 내에서 접근 허용, 같은 패키지의 다른 클래스에서 접근 허용, 다른 패키지의 상속받은 클래스에서 접근 허용, 다른 패키지의 다른 클래스에서 접근 불가
* default: 같은 패키지 내에서만 접근 허용
* private: 동일 패키지라도 접근 불가, 같은 클래스 내에서만 접근 허용
* 사용 이유
    - 정보은닉(민감 정보 유출 안하기), 외부에서 알 필요 없는 값은 노출하지 않는다. 
    - 응집도 높이고 결합도 낮추기 위함   

<br />

### final 키워드
* final 키워드는 상수로 정의하는 키워드
* final class: 다른 클래스에서 상속하지 못함
* final method: 다른 메소드에서 오버라이딩하지 못함 (오버로딩 가능)
* final variable: 변하지 않는 상수값이 되어 새로 할당할 수 없는 변수가 됨
* 생성자: final이 될 수 없음

<br />

### non-static과 static 멤버의 차이
#### non-static
* 객체마다 멤버가 존재
* 객체 생성 시에 멤버 생성
* 객체가 생성될 때 멤버 생성, 객체가 사라질 때 멤버가 사라짐
* 공유X

#### static
* 객체를 많이 생성해도 해당 변수는 한개만 존재(객체와 무관한 키워드), 클래스당 1개 존재
* 클래스를 로딩할 때, 멤버 생성, 처음 설정된 메모리 공간이 변하지 않음을 의미
* 객체가 생성되기 전에 사용 가능, 객체가 사라져도 멤버는 사라지지 않음 → 프로그램 종료 시 사라짐
* 동일한 클래스의 모든 객체들에 의해 공유

<br />

### 람다 표현식
* 식별자 없이 실행이 가능한 함수
* 함수를 따로 만들지 않고 코드 한 줄에 함수를 써서 그것을 호출
* 자바8부터 지원, 코드가 간결하고 가독성이 높음
* 재사용이 불가능하고 디버깅이 어려움
* 예시: Optional, Stream

<br />

### Reflection
JVM에서 실행되는 애플리케이션의 런타임 동작을 검사하거나 수정할 수 있는 기능이 필요한 프로그램에서 사용

<br />

### ThreadLocal
* 오직 한 쓰레드에 의해 읽고 쓰여질 수 있는 변수를 생성
* 오직 한 쓰레드 당 한 번의 실행을 허용

<br />

### Java7에서 Java8 
* 람다 표현식 추가: 함수형 프로그래밍
* Permanent Generation: Java7버전까지는 Heap에 존재, 8부터는 Native Method Stack에 Meta Space로 변경
* 인터페이스에 default 메소드, static 메소드 추가
* Stream API: 데이터의 추상화
* `java.time` 패키지: Joda-Time을 이용한 새로운 날짜와 시간 API
  
<br />

### 직렬화(serialization)란?        
자바에서 입출력을 할 때에는 스트림이라는 통로를 통해 데이터가 이동한다.      
하지만 객체는 바이트형이 아니라서 스트림을 통해 파일에 저장하거나 네트워크로 전송할 수 없다.           

따라서 객체를 스트림을 통해 입출력하려면 바이트 배열로 변환하는 것이 필요한데, 이를 '직렬화' 라고 한다.          
반대로 스트림을 통해 받은 직렬화된 객체를 원래 모양으로 만드는 과정을 역직렬화라고 한다.        

<br />

### 정적멤버를 `클래스명.정적멤버`로 접근해야 하는 이유  

```java
public class Test {
    static int f;

    public static void main(String[] args) {
        System.out.println(Test.f);  // 클래스명.정적멤버
    }
}
```

(1) 일관된 형식으로 접근     
(2) 메모리의 물리적 접근  

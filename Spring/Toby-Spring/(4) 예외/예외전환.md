# 예외 전환   

예외를 다른 것으로 바꿔서 던지는 에외 전환의 목적은 두 가지였다.   

(1) 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것          
(2) 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것          


스프링의 JdbcTemplate이 던지는 DataAccessException은 일단 런타임 예외로 SQLException을 포장해주는 역할을 한다. 그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해주는 것이다.   
또한 SQLException에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰이기도 한다.         


<br />       


## JDBC의 한계      

표준화된 JDBC API가 DB 프로그램 개발 방법을 학습하는 부담을 확실히 줄여주지만 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 못한다. 현실적으로 DB를 자유롭게 바꿔 사용할 수 있는 DB 프로그램을 작성하는 데 두 가지 걸림돌이 있다.    


#### 비표준 SQL          

첫 번째 문제는 JDBC 코드에서 사용하는 SQL이다. SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만, 대부분의 DB는 표준을 따르지 않는 문법과 기능도 제공한다. 이런 비표준 특정 DB 전용 문법은 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하다.     

작성된 비표준 SQL은 결국 DAO 코드에 들어가고, 해당 DAO는 특정 DB에 대해 종속적인 코드가 되고 만다. 다른 DB로 변경하려면 DAO에 담긴 SQL을 적지 않게 수정해야 한다. 

이 문제의 해결책을 생각해보면, 호환 가능한 표준 SQL만 사용하는 방법과 DB별로 별도의 DAO를 만들거나 SQL을 외부에 독립시켜서 DB에 따라 변경해 사용하는 방법이 있다.     

표준 SQL만을 사용하는 경우, 당장에 웹 프로그램에서 자주 필요로 하는 페이징 쿼리에서부터 문제가 된다. 따라서 표준 SQL만 사용하는 방법은 현실성이 없다. 결국 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 해야한다. (스프링 DI 적용 - 7장 참고)    



#### 호환성 없는 SQLException의 DB 에러정보         

두 번째 문제는 바로 SQLException이다. DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다.    
SQL의 문법 오류, DB 커넥션을 가져오지 못한 경우, 테이블이나 필드 존재하지 않음, 키가 중복되거나 다양한 제약조건을 위배하는 시도, 데드락에 걸렸거나 락을 얻지 못했을 경우 등 수백여 가지에 이른다.   

문제는 DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이다. 그래서 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 그냥 SQLException 하나에 모두 담아버린다. 그래서 예외가 발생한 원인은 SQLException 안에 담긴 에러 코드와 SQL 상태정보를 참조해봐야 한다. 그런데 SQLException의 getErrorCode()로 가져올 수 있는 DB 에러 코드는 DB별로 모두 다르다. DB 벤더가 정의한 고유한 에러 코드를 사용하기 때문이다.         

예전에 add() 메소드에서 새로운 사용자 등록 시 키가 중복돼서 예외가 발생하는 경우를 확인하기 위해 다음과 같은 방법을 사용했다.   


```
if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY) { ...  
```


SQLException의 에러 코드를 이용해 중복된 값이 등록이 원인인지 확인하는 것이다.     
그런데 여기서 사용한 에러 코드는 MySQL 전용 코드일 뿐이다. DB가 MySQL에서 오라클이나 SQLServer로 바뀐다면 에러 코드가 달라지므로 이 코드는 기대한 대로 작동하지 않을 것이다.      

그래서 SQLException은 예외가 발생했을 때 DB 상태를 담은 SQL 상태정보를 부가적으로 제공한다.   
getSQLState() 메소드로 예외상황에 대한 상태정보를 가져올 수 있다.   
예를 들면 통신장애로 DB 연결에 실패했을 경우에는 08S01, 테이블이 존재하지 않는 경우에는 42S02와 같은 식으로 표준 상태 코드가 정의되어 있다.   

SQLException이 이러한 상태 코드를 제공하는 이유는 DB에 독립적인 에러정보를 얻기 위해서다.    
그런데 문제는 DB의 JDBC 드라이버에서 SQLException을 담을 상태 코드를 정확하게 만들어주지 않는다는 점이다. 어떤 경우에는 아예 표준 코드와는 상관없는 엉뚱한 값이 들어 있기도 하고, 클래스 코드까지 바로 오지만 서브클래스 코드는 일체 무시하고 값을 다 0으로 넣는 경우도 있다. 결과적으로 SQL 상태 코드를 믿고 결과를 파악하도록 구현하는 것은 위험하다.        

결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능에 가깝다.        



<br />       


## DB 에러 코드 매핑을 통한 전환         

DB 종류가 바뀌더라고 DAO를 수정하지 않으려면 이 두 가지 문제를 해결해야 한다.       
일단 SQLException의 비표준 에러 코드와 SQL 상태정보에 대한 해결책을 알아보자.        


SQLException에 담긴 SQL 상태 코드는 신뢰할 만한 게 아니다. 차라리 DB 업체별로 만들어 유지해오고 있는 DB 전용 에러 코드가 더 정확하다. SQL 상태 코드는 JDBC 드라이버를 만들 때 들어가는 것이므로 같은 DB라고 해도 드라이버를 만들 때마다 달라지기도 하지만, DB 에러 코드는 DB에서 직접 제공해주는 것이라 어느 정도 일관성이 유지된다.        


해결 방법은 DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만드는 것이다. 키 값이 중복돼서 중복 오류가 발생하는 경우 Mysql은 1062, 오라클은 1, DB2는 -803이라는 에러 코드를 받게 된다. 이런 에러 코드 값을 확인할 수 있다면, 키 중복 때문에 발생하는 SQLException을 DuplicatekeyException이라는 의미가 분명히 드러나는 예외로 전환할 수 있다.      
DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달받을 수 있다면 효과적인 대응이 가능하다.   


스프링은 DataAccessException이라는 SQLException을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라 DataAccessException의 서브클래스로 세분화된 예외 클래스들을 정의하고 있다. 그 중에서도 중복 키 때문에 발생한 경우는 DuplicateKeyException을 사용할 수 있다. 이 외에도 데이터 액세스 작업 중에 발생할 수 있는 예외상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한 다양한 예외 클래스를 제공한다.   

문제는 DB마다 에러 코드가 제각각이라는 점이다. DAO 메소드나 JdbcTemplate 등의 코드에서 일일이 DB별로 에러 코드의 종류를 확인하는 작업을 수행하는 건 부담이 너무 크다. 대신 스프링은 DB별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다.   

다음은 오라클 에러 코드 매핑 파일 예시 코드이다.     

```
<bean id="Oracle" class="org.springframework.jdbc.support.SQLErrorCodes">
	<property name="badSqlGrammarCodes"> // 예외 클래스 종류   
		<value>900,903,904,917,936,942,17006</value> // 매핑되는 DB 에러 코드 
	</property>

 . . .

```

JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException으로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException 계층구조의 클래스 중 하나로 매핑해준다. 전환되는 JdbcTemplate에서 던지는 예외는 모두 DataAccessException의 서브클래스 타입이다.       
드라이버나 DB 메타정보를 참고해서 DB 종류를 확인하고 DB별로 미리 준비된 매핑정보를 참고해서 적절한 예외 클래스를 선택하기 때문에 DB가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있는 것이다.   

다음은 JdbcTemplate이 제공하는 예외 전환 기능을 이용하는 add() 메소드이다.         

```
public void add() throws DuplicateKeyException {
	// JdbcTemplate을 이용해 User를 add 하는 코드   
}
```

 
중복 키 에러가 발생했을 때 애플리케이션에서 직접 정의한 예외를 발생시키고 싶을 수 있다. 애플리케이션 레벨의체크 예외인 DuplicateUserIdException을 던지게 하고 싶다면 예외를 전환해주는 코드를 DAO안에 넣으면 된다.    

다음은 중복 키 예외의 전환 코드이다.   

```
public void add() throws DuplicateUserIdException {
	try {
		// jdbcTemplate을 이용해 User를 add 하는 코드 
	} catch(DuplicateKeyException e) {
		// 로그를 남기는 등의 작업이 필요함 
		throw new DuplicateUserIdException(e); // 예외를 전환할 때는 원인이 되는 예외를 중첩하는 것이 좋다.   
	}
}
```


<br />       


## DAO 인터페이스와 DataAccessException 계층구조        

DataAccessException은 JDBC의 SQLException을 전환하는 용도로만 만들어진 건 아니다.   
JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용된다. 자바에는 JDBC 외에도 데이터 액세스를 위한 표준 기술이 존재한다.   

DataAccessException은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것이다. 스프링이 왜 이렇게 DataAccessException 계층구조를 이용해 기술에 독립적인 예외를 정의하고 사용하게 하는지 생각해보자.          


#### DAO 인터페이스와 구현의 분리        

DAO를 굳이 따로 만들어 사용하는 이유는 뭘까? 가장 중요한 이유는 데이터 액세스 로직을 담은 코드를 **성격이 다른 코드에서 분리해놓기 위해서다.** 또한 분리된 DAO는 **전략 패턴을 적용해 구현 방법을 변경해서 사용**할 수 있게 만들기 위해서이기도 하다.    
DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경쓰지 않아도 된다. User와 같은 자바빈으로 만들어진, 특정 기술에 독립적인 단순한 오브젝트를 주고받으면서 데이터 액세스 기능을 사용하기만 하면 된다. 그런 면에서 DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고, DI를 통해 제공되도록 만드는 것이 바람직하다.     

```
public interface UserDao {
	public void add(User user); // 이렇게 선언하는 것이 가능할까?      
}
```

위 메소드 선언은 사용할 수 없다. DAO에서 사용하는 데이터 액세스 기술의 API가 예외를 던지기 때문이다. 인터페이스의 메소드 선언에는 없는 예외를 구현 클래스 메소드의 throws에 넣을 수는 없다. 따라서 인터페이스 메소드도 다음과 같이 선언돼야 한다.   

```
public void add(User user) throws SQLException;
```

이렇게 정의한 인터페이스는 JDBC가 아닌 데이터 액세스 기술로 DAO 구현을 전환하면 사용할 수 없다. 데이터 액세스 기술의 API는 자신만의 독자적인 예외를 던지기 때문에 결국 인터페이스로 메소드의 구현은 추상화했지만 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라기지 때문이다.     

```
public void add(User user) throws HibernateException; // Hibernate 
public void add(User user) throws PersistentException; // JPA
public void add(User user) throws JdoException; // JDO   
```

DAO 인터페이스를 기술에 완전히 독립적으로 만들려면 예외가 일치하지 않는 문제도 해결해야 한다.     
가장 단순한 해결 방법은 모든 예외를 다 받아주는 `throws Exception`으로 선언하는 것이다.   

```
public void add(User user) throws Exception;
```

하지만 무책임한 선언이다.     
다행히 JDBC보다는 늦게 등장한 JDO, Hibernate, JPA 등의 기술은 런타임 예외를 사용하기 때문에 SQLException만 메소드 내에서 런타임 예외로 포장해서 던져주면 처음 의도했던 대로 다음과 같이 선언해도 된다.     

```
public void add(User user);
```

이제 DAO에서 사용하는 기술에 완전히 독립적인 인터페이스 선언이 가능해졌다. 이것만으로 충분할까?       


대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것이다. 하지만 시스템 레벨에서 데이터 액세스를 의미 있게 분류할 필요도 있다. 문제는 데이터 액세스 기술이 달라지면 같은 상황이라도 다른 종류의 예외가 던져진다는 점이다.   
따라서 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 한다. 결국 클라이언트가 DAO의 기술에 의존적이 될 수밖에 없다.   
단지 인터페이스로 추상화하고 일부 기술에서 발생하는 체크 예외를 런타임 예외로 전환하는 것만으로는 불충분하다.        



#### 데이터 액세스 예외 추상화 DataAccessException 계층구조      

그래서 스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층구조 안에 정리해놓았다.         

결국 인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수가 있다.       


<br />              


# 정리        

엔터프라이즈 애플리케이션에서 사용할 수 있는 바람직한 예외처리 방법은 무엇인지를 살펴봤다. 또한 JDBC 예외의 단점이 무엇인지 살펴보고, 스프링이 제공하는 효과적인 데이터 액세스 기술의 예외처리 전략과 기능에 대해서도 알아봤다. 주요 내용은 다음과 같다.         

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.   
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야 한다.   
- 좀 더 의미 있는 에외로 변경하거나, 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.   
- 복구할 수 없는 예외는 가능한 빨리 런타임 예외로 전환하는 것이 바람직하다.     
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.        
- JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.   
- SQLException의 에러 코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환할 필요가 있다.    
- 스프링은 DataAccessException을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.   
- DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환, 기술에 독립적인 추상화된 예외로 전환이 필요하다.     


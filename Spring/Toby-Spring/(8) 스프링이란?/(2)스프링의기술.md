## 스프링의 기술        

기술과 비즈니스 로직을 분리하고 POJO 방식의 애플리케이션 개발을 가능하게 한다는 스프링의 목적을 쉽게 이루려면   
스프링과 같은 POJO 프레임워크가 필요하다.   
스프링에는 POJO 프로그래밍을 손쉽게 할 수 있게 지원하는 세 가지 기능기술이 있다. -> IoC/DI, AOP, PSA         

<br />     

#### 제어의 역전(IoC) / 의존관계 주입(DI)           

**Q.** 왜 두개의 오브젝트를 분리해서 만들고 인터페이스를 두고 느근하게 연결해   
실제로 사용할 대상은 DI를 통해 외부에서 지정하는걸까?   

**A.** 유연한 확장을 가능하게 하기 위해서다.   
폐쇄 관점에서 볼 때 장점은 '재사용이 가능하다.' 라고 볼 수도 있다.    

<br />     

#### DI의 활용 방법     
**- 핵심 기능 변경**   
DI의 가장 대표적인 적용 방법은 의존 대상의 구현을 바꾸는 것이다.    


**- 핵심기능의 동적인 변경**    
DI도 기본적으로 런타임 시에 동적으로 의존 오브젝트를 연결해주는 것이긴 하지만 일단 DI되면 그 후로는 바뀌지 않는다.    
그러나 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경할 수 있다.           
<br />
예를들면 사용자의 등급에 따라서 다른 DataSource를 사용하게 만들 수 있다.        
DAO는 Datasource에 의존한다. `DAO -> DataSource` 이렇게 관계가 만들어진다.   
이 DAO 하나가 여러 개의 DataSource에 의존하게 만들 수도 있다.        
<br />
동적인 방식으로 핵심기능을 변경하는 건, 기술적으로 보자면 다이내믹 라우팅 프록시나 프록시 오브젝트 기법을 사용한 것이다.      
이런 기법을 적용할 수 있는 것은 DI가 있기 때문이고 DI 없이는 불가능하다.     


**- 부가기능의 추가**       
DI의 세 번쨰 활용 방법은 핵심기능은 그대로 둔 채로 부가기능을 추가하는 것이다.       
데코레이터 패턴을 생각해보면 인터페이스를 두고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 두는 것이다.        
그래서 핵심기능과 클라이언트 코드에 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.
<br />
트랜잭션이 대표적인 예다.   
부가기능의 추가 방식을 특정 오브젝트가 아니라 좀 더 많은 대상으로 일반화해서 적용하면 AOP가 된다.         
<br />
부가기능 추가도 DI 덕분이고 DI 구조로 만들었기 때문에 DI의 핵심 원칙인 OCP에도 충실하게 잘 들어맞는다.       
OCP가 말하는 확장에 열려 있다는 것은 전략 패턴에서처럼 핵심기능을 변경해서 쓰는 수준만을 말하는 게 아님을 기억해야 한다.          


**- 인터페이스의 변경**     
때로 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 있다.     
또는 여러 종류의 인터페이스를 가졌지만 사실 비슷한 기능을 담당하는 오브젝트를 바꿔가면서 사용하고 싶을 때도 있다.    
이렇게 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용하다.    
<br />
A가 C오브젝트를 사용하려고 한다. 하지만 A는 원래 B 인터페이스를 사용하도록 만들어졌고 C는 B 인터페이스를 구현하지 않았다.    
이떄 A가 DI로 B의 구현 오브젝트를 받도록 만들어져 있다면 B 인터페이스를 구현했으면서 내부에서 C를 호출해주는 기능을 가진   
어댑터 오브젝트를 만들어 A에 DI 해주면 된다. `A -> B(C로 위임) -> C`   
<br />
이를 좀 더 일반화해서 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록, 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법도 있다.    
DI의 응용 방법 중 하나이자 스프링의 대표적인 기술로 분류되는 서비스 추상화가 그런 방법이다.   
PSA는 클라이언트가 일관된 방법으로 사용할 수 있게 인터페이스를 정의하고 DI를 통해 어댑터 역할을 하는 오브젝트를 이용하게 해준다.    
이를 통해 다른 인터페이스를 가진 로우레벨의 기술을 변경하거나 확장해가면서 사용할 수 있는 것이다.    


**- 프록시**   
필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩(Lazy loading)을 적용하려면 프록시가 필요하다.    
원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 필요하다.    
두 가지 방법 모두 DI를 필요로 한다. 

**- 템플릿과 콜백**   
반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해   
지저분하게 매번 만들어야 하는 코드를 간결하게 만들 수 있다.    
<br />
콜백을 얼마든지 만들어서 사용할 수 있다는 것은 개방을 통한 유연한 확장성을 보여주는 것이며,    
템플릿은 한 번 만들어두면 계속 재사용할 수 있다는 기능의 확장에도 변하지 않는다는 OCP의 폐쇄 원칙에 가장 잘 들어맞는다.    


**- 싱글톤과 오브젝트 스코프**       
DI가 필요한 중요한 이유 중 한 가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다는 것이다.   
가장 기본이 되는 스코프는 역시 싱글톤이다.    
<br />
떄론 단일 싱글톤이 아니라 임의의 생명주기를 갖는 오브젝트가 필요할 때가 있는데      
스프링에서 싱글톤 외에도 다양한 스코프를 갖는 오브젝트를 만들어 DI에 사용할 수도 있다.       
HTTP 요청당 하나의 오브젝트가 만들어지거나, HTTP 세션당 하나의 오브젝트가 만들어기제 할 수 있다.   

<br />      

## 애스펙트 지향 프로그래밍(AOP)          
스프링의 목적인 POJO만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터프라이즈 서비스를 선언적으로 제공하는 데 반드시 필요한 것이 바로 이 AOP 기술이다.      
스프링의 AOP는 스프링이 POJO 프로그래밍을 지원하려는 그 핵심 목적을 위해 중요한 역할을 하고 있다.        

#### AOP의 적용 기법       
AOP를 자바 언어에 적용하는 기법은 크게 두 가지로 분류할 수 있다.        

**- 첫번째는 스프링과 같이 다이내믹 프록시를 사용하는 방법이다.**   
이 방법은 기존 코드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터 패턴을 응용한 것이다.   
자바의 객체지향 패턴을 활용한 방법이라 만들기 쉽지만 부가기능을 부여할 수 있는 곳은 메소드의 호출이 일어나는 지점뿐이라는 제약이 있다.    
인터페이스와 DI를 활용하는 데코레이터 패턴이 기반원리이기 때문이다.    
<br/>
부가기능을 구현한 코드나 기능을 적용할 대상을 찾는 바아법 모두 평범한 자바 클래스로 만들면 된다.   
스프링의 기본적인 AOP 구현 방법은 다이내믹 프록시를 이용하는 프록시 AOP 방식이다.   


**- 두 번째는 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법이다.**     
AspectJ라는 오픈소스 AOP 툴이 있다. AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인 포인트를 제공한다.      
메소드 호출뿐 아니라 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메소드 호출 등에도 부가기능을 제공할 수 있다.       

<br />      


## 포터블 서비스 추상화(PSA)       
세 번째 가능기술은 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 PSA이다.   
POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 한다.     
<br />
트랜잭션을 예로 들자면, 트랜잭션 서비스 추상화는 코드를 이용해 트랜잭션을 제어하지 않는다면 직접 이용할 이유가 없다.   
트랜잭션은 대부분 AOP를 이용해 적용하기 때문에 직접 코드를 만들지 않기 때문이다.   
대신 설정에서는 스프링의 트랜잭션 추상화 인터페이스인 `PlatformTransactionManager`를 구현한 구체적인 서비스 클래스를 빈으로 등록해줘야 한다.   
<br />
서비스 추상화를 위해 필요한 기술은 DI뿐이다.      
서비스 추상화는 단지 구체적인 기술에 종속되지 않게 하기 위해서만 사용되는 건 아니다.   
테스트가 어렵게 만들어진 API나 설정을 통해 주요 기능을 외부에서 제어하게 만들고 싶을 때도 이용할 수 있다.    












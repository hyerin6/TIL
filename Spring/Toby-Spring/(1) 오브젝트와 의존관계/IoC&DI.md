# 스프링의 IoC   

<br />    
 
## 1. 오브젝트 팩토리를 이용한 스프링 IoC       

### 애플리케이션 컨텍스트와 설정정보     
스프링에서 스프링이 **제어권**을 가지고 직접 만들고 관계를 부여하는 오브젝트를 **빈(bean)**이라고 부른다.     
동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.      

빈 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리(Bean Factory)라고 부른다.   
보통 빈 팩토리보다는 좀 더 확장한 애플리케이션 컨텍스트(application context)를 주로 사용한다.   
  
애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다.     
별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어작업을 총괄한다.     
그 설정정보를 만드는 방법은 여러가지가 있는데 앞서 만든 오브젝트 팩토리인 DaoFactory도 조금만 손을 보면 설정정보로 사용할 수 있다.     

DaoFactory 자체가 설정정보까지 담고 있는 IoC 엔진이다. **DaoFactory = 설계도**         
설계도라는 게 바로 애플리케이션 컨텍스트와 그 설정정보이다.       


### DaoFactory를 사용하는 애플리케이션 컨텍스트   
DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정정보를 만들자.    

스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 `@Configuration` 이라는 어노테이션을 추가한다.   
그리고 오브젝트를 만들어주는 메소드에는 `@Bean` 이라는 어노테이션을 붙여준다.        


**예)**  UserDao() 메소드는 UserDao 타입 오브젝트를 생성하고 초기화해서 돌려주는 것이므로 `@Bean`이 붙는다.   
ConnectionMaker 타입의 오브젝트를 생성해주는 connection() 메소드에도 `@Bean`을 붙여준다.       


이 어노테이션만으로 스프링 프레임워크의 빈 팩토리 또는 애플리케이션 컨텍스트가 IoC 방식의 기능을 제공할 때 사용할 완벽한 설정정보가 된 것이다.   


 
`@Configuration` - 애플이케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시   
`@Bean` - 오브젝트 생성을 담당하는 IoC용 메소드라는 표시   



애플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트이다.     
ApplicationContext를 구현한 클래스는 여러가지가 있는데 DaoFactory처럼   
`@Configuration`이 붙은 자바 코드를 설정정보로 사용하려면     
AnnotationConfigApplicationContext를 이용하면 된다.     


```  
ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);  
UserDao dao = context.getBean("userDao", UserDao.class); // userDao() 메소드를 호출해서 그 결과를 가져온다.   
```  


**Q.** UserDao를 가져오는 메소드는 하나뿐인데 왜 굳이 이름을 사용할까?   
**A.** UserDao를 생성하는 방식이나 구성을 다르게 가져가는 메소드를 추가할 수 있기 때문이다.   


<br />      

 
## 2. 애플리케이션 컨텍스트의 동작 방식     

오브젝트 팩토리에 대응되는 것이 스프링 애플리케이션 컨텍스트다.    
스프링에서는 이 애플리케이션 컨텍스트를 IoC 컨테이너라 하기도하고 스프링 컨테이너, 빈 팩토리라고 부르기도 한다.     

**왜 그렇게 부르는걸까?**         
IoC Container는 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 대신 해준다하여 붙여진 이름이다.   
이때, IoC Container에 의해 관리되는 오브젝트들은 Bean이라고 부른다.   
IoC Container는 Bean을 저장한다고 하여, BeanFactory라고도 불린다.   

BeanFactory는 하나의 인터페이스이며, Application Context는 BeanFactory의 구현체를 상속받고 있는 인터페이스이다.  
실제로 스프링에서 IoC Container라고 불리는 것은 Application Context의 구현체이다.   



오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플리케이션 컨텍스트를 사용했을 떄 얻을 수 있는 장점은 다음과 같다.   

(1) 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.   


(2) 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.    
오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고,     
이 외에도 다양한 기능을 제공한다.     

(3) 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.           
`getBean()` 메소드는 빈의 이름을 이용해 빈을 찾아주는데         
타입만으로 검색하거나 특별한 어노테이션 설정이 되어 있는 빈을 찾을 수도 있다.        


<br />        
 

# 싱글톤 레지스트리와 오브젝트 스코프         

스프링의 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와는 차이점이 있다.   
DaoFactory의 userDao() 메소드를 두 번 호출해서 리턴되는 UserDao 오브젝트를 비교해보자.   
두 오브젝트가 같은 오브젝트일까?     
메소드 코드를 보면 new 연산자에 의해 새로운 오브젝트가 만들어지게 되어있다.     
즉 메소드 호출마다 새로운 오브젝트가 만들어지는 것이고 두 오브젝트는 다른 오브젝트이다.   

스프링의 애플리케이션 컨텍스트에 DaoFactory를 설정정보로 등록하고 getBean() 메소드를 이용해 userDao를 가져와보자.   
getBean()을 두 번 호출해서 가져온 오브젝트가 동일하다.   
스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.   



## 1. 싱글톤 레지스트리로서의 애플리케이션 컨텍스트   

애플리케이션 컨텍스트는 앞서 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC 컨테이너이다.   
그러면서 동시에 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.   

스프링은 기본적으로 별도의 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다.     


### 서버 애플리케이션과 싱글톤   
매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 아무리 오브젝트 생성과 GC 성능이 좋아졌어도 이렇게 부하가 걸리면 서버가 감당하기 힘들다.   
그래서 엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.   

서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수 있다.   
서블릿은 대부분 멀티 스레드 환경에서 싱글톤으로 동작한다.    
서블릿 클래스당 하나의 오브젝트만 만들어주고, 사용자의 요청을 담당하는 여러 스레드에서   
하나의 오브젝트를 공유해 동시에 사용한다.     

이렇게 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리다.     
서버환경에서는 서비스 싱글톤의 사용이 권장된다.   
하지만 디자인 패턴에서 소개되는 싱글톤 패턴은 사용하기 까다롭고 여러 가지 문제점이 있다.   


### 싱글톤 패턴의 한계     
자바에서 싱글톤 패턴을 구현하는 방법은 다음과 같다.   

- 클래스 밖에서는 오브젝트를 사용하지 못하게 **생성자를 private로** 만든다.   
- 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 **스태틱 필드를 정의**한다.   
- 스태틱 팩토리 메소드인 `getInstance()`를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트가 만들어지게 한다.   
생성된 오브젝트는 스태틱 필드에 저장된다.   
- 한 번 오브젝트가(싱글톤) 만들어지고 난 후에는 `getInstance()` 메소드를 통해 이미 만들어 스태틱 필드에 저장해둔 오브젝트를 넘겨준다.     

이런식으로 UserDao를 싱글톤 패턴을 적용해서 만들면 private로 바뀐 생성자는 외부에서 호출할 수 없기 때문에 DaoFacroty에서 UserDao를 생성하여 ConnectionMaker 오브젝트를 넣어주는 게 불가능해진다.     

일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.   

- private 생성자를 갖고 있기 때문에 상속할 수 없다.   
private 생성자를 가진 클래스는 다른 생성자가 없으면 상속이 불가능하다.   
즉 상속과 다형성을 사용할 수 없다는 것이다.   

- 싱글톤은 테스트하기 힘들다.   
만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트 등으로 대체하기가 힘들다.   

- 서버환경에서 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.   
서버에서 클래스 로더를 어떻게 사용하고 있느냐에 따라서 싱글톤이 꼭 보장된다고 할 수 없다.    
여러개의 JVM에 분산되서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어진다.   

- 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.   



### 싱글톤 레지스트리     
자바의 기본적인 싱글톤 패턴의 구현방식은 여러가지 단점이 있기 때문에   
스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. -> 싱글톤 레지스트리    
스프링 컨테이너는 싱글톤을 생성하고 관리, 공급하는 싱글톤 관리 컨테이너이기도 하다.   
싱글톤 레지스트리의 장점은 static 메소드와 private 생성자를 사용해야 하는 방식이 아니라는 것이다.   
즉 객체지향적인 설계 방식과 원칙, 디자인 패턴 등을 적용하는 데 아무런 제약이 없다.   

스프링은 IoC 컨테이너 뿐만 아니라 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고 관리해주는 싱글톤 레지스트리이다.   
스프링이 빈을 만드는 것은 결국 오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다.   

<br />          
 
## 2. 싱글톤과 오브젝트의 상태   
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.   

상태가 없는 방식으로 클래스를 만들어야 하는데 각 요청에 대한 정보나 DB, 서버의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까?    
이때는 파라미터와 로컬 변수, 리턴 값 등을 이용하면 된다.   
메소드 파라미터나 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 저장할 독립적인 공간이 만들어지기 때문에 싱글톤이라고 해도 여러 스레드가 변수의 값을 덮어쓸 일은 없다.   

<br />        


## 3. 스프링 빈의 스코프     
스프링이 관리하는 오브젝트, 즉 빈이 생성되고 존재하고 적용되는 범위를 빈의 스코프(scope)라고 한다.     
스프링 빈의 기본 스코프는 싱글톤이다. 경우에 따라 싱글톤 외의 스코프를 가질 수 있다.    
대표적으로 프로토타입 스토프가 있다.   
프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어준다.   


<br />        


# 의존관계 주입(DI)       

## 1. 의존관계 주입     

객체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의 IoC 컨테이너이다.   
여기서 사용하는 IoC라는 용어는 매우 느슨하게 정의되서 폭넓게 사용되는 언어이다.   
때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.   
그래서 스프링이 제공하는 IoC 방식의 핵심을 짚어주는 의존관계 주입이라는 좀 더 의미가 명확히 드러나는 의미를 사용하기 시작했다.   

스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다.   
스프링의 차별된 기능을 의존관계 주입이라는 용어로 분명하게 나타낼 수 있다.   


<br />        


## 2. 런타임 의존관계 설정    

### 의존관계   
두 개의 클래스 또는 모듈이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘야 한다.   
즉 누가 누구에게 의존하는 관계에 있다는 식이어야 한다.    

A가 B에 의존하고 있다는 것은 B의 기능이 추가되거나 변경되거나 형식이 바뀌면 그 영향이 A로 전달된다는 것이다.   
반대로 B는 A의 변화에 영향을 받지 않는다는 뜻이다.   


### UserDao의 의존관계  
지금까지 구현한 UserDao는 ConnectionMaker 인터페이스를 사용한다.     
따라서 ConnectioMaker 인터페이스가 변한다면 UserDao가 직접적으로 영향을 받는다.     
하지만 ConnectionMaker를 구현한 클래스(DConnectionMaker)에 변화가 생기는 경우에는   
UserDao에 영향을 주지 않는다.   
이렇게 인터페이스에 대해서만 의존관계를 만들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변화에 영향을 덜 받는 상태가 된다. 이는 결합도가 낮다고 설명할 수 있다.      
의존관계는 한쪽의 변화가 다른 쪽에 영향을 주는 것이라고 했으니, 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서 자유로워진다.    


런타임 의존관계는 모델링 시점의 의존관계와는 분명히 다르다.    
인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 UserDao의 오브젝트가 런타임시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수가 없다.   
런타임 시에 의존관계를 맺는 대상 즉, 실제 사용대상인 오브젝트를 의존 오브젝트라고 한다.   



의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업이다.   

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어햐 한다.   
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.   
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.   

의존관계 주입의 핵심은 설계 시점에서 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제 3의 존재가 있다는 것이다.   
DI에서 말하는 제 3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트라고 볼 수 있다.    
전략패턴에 등장하는 클라이언트나 앞에서 만들었던 DaoFactory 혹은 DaoFactory와 같은 작업을 일반화해서 만들어졌다는 스프링의 애플리케이션 컨텍스트, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼 수 있다.     


### UserDao의 의존관계 주입   

```  
public UserDao() {  
	connectionMaker = new DConnectionMaker();  
}    
```   

UserDao는 이미 설계 시점에서 DConnectionMaker라는 구체적인 클래스의 존재를 알고있다.     
문제는 이미 런타임 시 의존관계가 코드 속에 다 미리 결정되어 있다는 점이다.   
그래서 IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코드를 제거하고,   
제3의 존재에 런타임 의존관계 결정 권한을 위임한다.   

DaoFactory는 런타임 시점에 UserDao가 사용할 ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao의 생성자 파라미터로 주입해서 UserDao가 DConnectionMaker의 오브젝트와 런타임 의존관계를 맺게 해준다.      


DI는 자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다는 점에서 IoC의 개념에 잘 들어맞는다.   


<br />        

## 3. 의존관계 검색과 주입   

스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것은 아니다.   
외부로부터의 주입이 아니라 스스로 검색하는 의존관계 검색이라고 불리는 것도 있다.   

의존관계 검색은 자신이 어떤 클래스의 오브젝트를 사용할지 결정하지는 않지만 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.        
런타임 시 의존관계를 맺을 오브젝트를 결정하는 것과 오브젝트의 생성 작업은 외부 컨테이너에게 IoC로 맡기지만     
이를 가져올 때는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.     


```  
public UserDao() {    
	DaoFactory daoFactory = new DaoFactory();  
	this.connectionMaker = daoFactory.connectionMaker();      
}        
```    

위 코드를 보면 UserDao는 여전히 자신이 어떤 ConnectionMaker 오브젝트를 사용할지 미리 알지 못한다.      
그리고 여전히 코드의 의존대상은 ConnectionMaker 인터페이스뿐이다.     
런타임 시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이나믹하게 런타임 의존관계를 맺는다.   
따라서 IoC 개념을 잘 따르며 그 혜택을 받고 있는 코드라고 할 수 있다.   
하지만 적용 방법은 외부로부터 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청하는 것이다.   

이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리 정해놓은 이름을 전달해서 그 이름에 해당하는 오브젝트를 찾게 된다.     
그래서 의존관계 검색이라고 부른다.   


의존관계 검색과 의존관계 주입의 중요한 차이점은 의존관계 검색 방식에서는   
검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다.   
UserDao가 굳이 스프링이 만들고 관리하는 빈일 필요가 없다.   
직접 `new UserDao()`로 만들어 사용하고 ConnectionMaker만 스프링의 빈이기만 하면 된다.   

반면에 의존관계 주입에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다.   



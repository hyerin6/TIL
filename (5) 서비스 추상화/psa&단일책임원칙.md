# 서비스 추상화와 단일 책임 원칙        

### 수직, 수평 계층구조와 의존관계   

기술과 서비스에 대한 추상화 기법을 사용하여 특정 기술환경에 종속되지 않는 코드를 만들었다.     

`UserDao`와 `UserService`는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고 독자적으로 확장이 가능하도록 만들었다.       
같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리한 것이다. 같은 계층에서 **수평적인 분리**라고 볼 수 있다.       

트랜잭션의 추상화는 이와는 좀 다르다.   
애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우 레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.   


![스크린샷 2020-12-20 오후 11 08 50](https://user-images.githubusercontent.com/33855307/102715370-5c322b80-4318-11eb-905e-f1a3cab11274.png)     


위 계층과 책임의 분리는 지금까지 만들어진 사용자 관리 모듈과 의존관계를 나타낸다.   


`UserDao`와 `UserService`는 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다.     
`UserDao`와 `DataSource`도 인터페이스와 DI를 통해 연결되서 결합도가 낮아졌다.   
마찬가지로 `UserService`와 트랜잭션 기술도 스프링이 제공하는 인터페이스를 통한 추상화 계층을 사이에 두고 사용하게 했기 때문에   
구체적인 트랜잭션 기술에 독립적인 코드가 됐다.     
`UserDao`와 DB 연결 기술, `UserService`와 트랜잭션 기술의 결합도가 낮은 분리는     
애플리케이션 코드를 로우레벨의 기술 서비스와 환경에서 독립시켜준다.     



### 단일 책임 원칙        

이런 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 단일 책임 원칙으로 설명할 수 있다.      
하나의 모듈은 한가지 책임을 가져야 한다는 의미로 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 이해할 수도 있다.      


### 단일 책임 원칙의 장점   

단일 책임 원칙을 잘 지킨다면 어떤 변경이 필요할 때 수정 대상이 명확해진다.   
기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다.   

적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고   
애플리케이션 로직과 기술/환경을 분리하는 등의 작업이 필요하다.   
이를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다.   

객체지향 설계와 프로그래밍의 원칙은 서로 긴밀하게 관련이 있다.     
단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고,     
모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오기 때문이다.     


<br />              


# 메일 서비스 추상화        

레벨이 업그레이드되는 사용자에게 안내 메일을 발송해야 하는 상황이라면?    
`UserService`의 `upgradeLevel()` 메소드에 메일 발송 기능이 필요하다.   


### JavaMail을 이용한 메일 발송 기능   

`upgradeLevel()` 메소드 안에 JavaMail 코드를 직접 넣지 않는 게 나을테니   
`sendUpgradeMail()` 메소드를 구현해보자.   


### JavaMail이 포함된 코드의 테스트   

메일 발송이란 부하가 큰 작업이다. 게다가 테스트를 진행하다 메일이 실제로 발송될 수도 있다.    
`JavaMail`은 자바 표준 기술이고 이미 수많은 시스템에서 사용중이니   
`JavaMail` API를 통해 요청이 들어간다는 보장만 있다면 굳이 테스트할 때마다 `JavaMail`을 직접 구동시킬 필요는 없다.   


### 테스트를 위한 서비스 추상화     

실제 메일 전송을 수행하는 `JavaMail` 대신에 테스트에서 사용할, `JavaMail`과 같은 인터페이스를 갖는 오브젝트를 만들어서 사용하면 문제는 해결된다.     

그런데 한 가지 심각한 문제가 있다. `JavaMAil`의 API는 이 방법을 적용할 수 없다.   
`JavaMail`의 핵심 API에는 `DataSource`처럼 인터페이스로 만들어져서 구현을 바꿀 수 있는 게 없다.    
`JavaMail`에서는 `Session` 오브젝트를 만들어야만 메일 메시지를 생성할 수 있고 전송할 수 있는데   
`Session`은 인터페이스가 아니라 클래스이기 때문이다.   
구현을 바꿔치기할 만한 인터페이스의 존재가 보이지 않는다.   

`JavaMail`처럼 테스트하기 힘든 구조인 API를 테스트라기 좋게 만드는 방법은         
트랜잭션을 사용하면서 살펴봤던 서비스 추상화를 적용하면 된다.        
스프링은 `MailSender`라는 `JavaMail`에 대한 추상화 기능을 제공하고 있다.         


<br />        


# 정리      

- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다.   
비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로 정리돼야 한다.  

- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와   
DI를 잘 활용해서 결합도를 낮춰야 한다.   

- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.   

- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다.   
트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.    

- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에     
스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.    

- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다.   
환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.   

- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며,   
DAO가 사용하는 기술에 대한 강한 결합을 만들어낸다.   

- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면   
스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.     

- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관적인 API를 가진 추상화 계층을 도입한다.   
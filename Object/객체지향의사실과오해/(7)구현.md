<br />

마틴 파울러는 객체지향 설계 안에 존재하는 세 가지 관점에 대해 다음과 같이 설명했다.             

* 개념 관점(Conceptual Perspective)              
  도메인 안에 존재하는 개념과 개념들 사이의 관계를 표현한다.                


* 명세 관점(Specification Perspective)           
  사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨진다.        
  소프트웨어 안의 객체들의 책임에 초점을 맞추게 된다.          
  인터페이스와 구현을 분리하는 것은 훌륭한 객체지향 설계를 낳는 가장 기본적인 원칙이다.              
  "구현이 아니라 인터페이스에 대해 프로그래밍하라"를 따르는 것은          
  명세 관점과 구현 관점을 명확하게 분리하는 것에서부터 시작된다.             


* 구현 관점(Implementation Perspective)                   
  프로그래머는 객체의 책임을 어떻게 수행할 것인가에 초점을 맞추며         
  인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가한다.             


<br />

위 설명은 클래스를 어떻게 설계해야 하는지 중요한 힌트를 암시한다.   
클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야 한다.         


지금까지 역할, 책임, 협력을 이용해 객체의 인터페이스를 식별했다.   
협력에 참여하기 위해 객체가 수신해야 하는 메시지를 결정하고 메시지들이 모여 객체의 인터페이스를 구성한다는 점을 기억하자.   
협력 안에서 메시지를 선택하고 메시지를 수신할 객체를 선택하는 것은 객체의 인터페이스, 즉 명세 관점에서 객체를 바라보는 것이다.   

예제를 통해 다음 두 가지 목표를 달성해보자.     
* 도메인 모델에서 시작해서 최종 코드까지의 구현 과정을 간략하게나마 설명하는 것 
* 구현 클래스를 개념 관점, 명세 관점, 구현 관점에서 바라본다는 것이 무엇을 의미하는지를 설먕하는 것 

<br />
<br />

## 커피 전문점 도메인   
커피 전문점에서 커피를 주문하는 과정을 객체들의 협력 관계로 구현해보자.   

```text
커피 제조하기   

커피 전문점에서는 아메리카노, 카푸치노, 카라멜 마끼아또, 에스프레소 4가지 커피를 판매하고 있다.   
손님은 테이블에 앉아 메뉴판을 확인하고 커피를 주문한다. 주문받은 커피는 바리스타의 몫이다. 

최종 목표는 손님이 커피를 주문하는 사건을 객체를 이용해 컴퓨터 안에 재구성하는 것이다.
```


<br />

### 커피 전문점   
객체지향의 관점에서 메뉴판은 하나의 객체다.    
메뉴판은 네 개의 메뉴 항목으로 구성돼 있는데 메뉴 항목들 역시 객체로 볼 수 있다.   
손님 객체는 메뉴판 객체 안에 적힌 메뉴 항목 객체들 중에서 자신이 원하는 메뉴 항목 객체 하나를 선택해 바리스타 객체에게 전달한다.      
바리스타는 자율적으로 커피를 제조하는 객체로 볼 수 있다.      
객체지향의 관점에서 커피 전문점이라는 도메인은 손님, 메뉴 항목, 메뉴판, 바리스타, 커피 객체들로 구성된 작은 세상이다.   

손님이 메뉴판에서 주문할 커피를 선택할 수 있어야 한다.   
이것은 두 객체 사이에 관계가 존재한다는 것을 암시한다.   
손님은 바리스타에게 주문을 해야 하므로 손님과 바리스타 사이에도 관계가 존재한다.          

우리가 할 수 있는 일은 동적인 객체를 정적인 타입으로 추상화해서 복잡성을 낮추는 것이다.     
상태와 무관하게 동일하게 행동할 수 있는 객체들은 동일한 타입으로 분류할 수 있다.    

**메뉴판 객체는 네 개의 메뉴 항목 객체를 포함**할 수 있다.    
네 개의 메뉴 항목 객체 역시 모두 동일한 '메뉴 항목 타입'의 인스턴스로 모델링할 수 있다.   
메뉴판 타입과 메뉴 항목 타입 간의 관계는 **포함 또는 합성 관계**라고 한다.     

손님 타입은 메뉴판 타입을 알고 있어야 원하는 커피를 선택할 수 있다.     
메뉴판 타입이 손님의 일부는 아니기 때문에 이 관계는 **연관 관계**라고 한다. 

바리스타 타입은 커피를 제조해야 하므로 커피 타입을 알고 있어야 한다.    
커피나 메뉴판이 바리스타의 일부가 아니므로 이 관계 역시 포함관계는 아니다.   


![스크린샷 2021-11-28 오후 1 56 10](https://user-images.githubusercontent.com/33855307/143730162-cd78ceac-cc3a-4f7e-84c4-442d37c15575.png)


<br />  
<br />

## 설계하고 구현하기  
### 커피 주문을 위한 협력 찾기  
객체지향 설계의 첫 번째 목표는 훌륭한 객체 설계가 아니라 훌륭한 협력을 설계하는 것이다.   
훌륭한 객체는 훌륭한 설계할 때만 얻을 수 있다.   

협력을 설계할 때는 객체가 메시지를 선택하는 것이 아니라   
메시지가 객체를 선택하게 해야 한다.   
메시지를 먼저 선택하고 메시지를 수신하기에 적절한 객체를 선택해야 한다는 의미이다.   

객체가 수신하는 메시지는 객체가 외부에 제공하는 공용 인터페이스에 포함된다.     
현재 설계하는 커피 전문점 예제에서 첫 번째 메시지는 `커피를 주문하라`일 것이다.   


![스크린샷 2021-11-28 오후 2 03 22](https://user-images.githubusercontent.com/33855307/143730302-75b9c4e1-e61c-4d46-8fd9-0d476a42fb19.png)


메뉴 이름은 부가적인 정보인 인자를 의미한다.   
`커피를 주문하라(아메리카노)`와 같은 형태로 구현될 것이다.   

이제 메시지를 처리하기에 적합한 객체를 선택해야 한다.   
적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들어야 한다.   
여기서는 당연히 손님일 것이다.   
  
손님이 메뉴판으로 부터 메뉴 항목을 받아 선택하고 바리스타에게 선택한 메뉴를 전달하며 주문한다.      
커피 주문을 위한 협력은 바리스타가 새로운 커피를 만드는 것으로 끝난다.   


<br />

### 인터페이스 정리하기 
객체가 수신한 메시지가 객체의 인터페이스를 결정한다.   
메시지가 객체를 선택했고 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.   

![스크린샷 2021-11-28 오후 2 39 41](https://user-images.githubusercontent.com/33855307/143731090-120c9758-ff9f-4fb0-af23-109952126d3e.png)


객체의 타입을 구현하는 일반적인 방법은 클래스를 이용하는 것이다.   
자바 문법으로 다음과 같이 구현할 수 있다.  

```java 
class Customer {
    public void order(String menuName) {}
}

class MenuItem {
}
        
class Menu {
    public MenuItem choose(String name) {}
}

class Barista {
    public Coffee makeCoffee(MenuItem menuItem) {}
}

class Coffee {
    public Coffee(MenuItem menuItem) {}
}
```

<br />

### 구현하기   
클래스의 인터페이스를 식별했으니 이제 오퍼레이션을 수행하는 방법을 메소드로 구현하면 된다.   

문제: Customer가 어떻게 Menu 객체와 Barista 객체에 접근할까?  

객체가 다른 객체에게 메시지를 전송하기 위해서 먼저 객체에 대한 참조를 얻어야 한다.   
따라서 Customer 객체는 Menu 객체와 Barista 객체에 대한 참조를 알고 있어야 한다.   

문제 해결: Customer의 `order()` 메서드에 인자로 Menu와 Barista 객체를 전달 받는다.   

```java 
class Customer {
    public void order(String menuName, Menu menu, Barista barista) {}
}
```

이렇게 구현 도중 객체의 인터페이스가 변경될 수 있다.   
설계 작업은 스케치 작성 단계지 구현 그 자체일 수는 없다.   

<br />
<br />

## 코드와 세 가지 관점 
### 코드는 세 가지 관점을 모두 제공해야 한다.   
코드는 앞에서 말했던 개념 관점, 명세 관점, 구현 관점에서 각기 다른 사항들을 설명해준다. 


코드를 읽으면서 세 가지 관점을 쉽게 포착할 수 있어야 변경에 유연하게 대응할 수 있는 객체지향 코드를 작성하는 빠른 길이다.   

<br />  

### 도메인 개념을 참조하는 이유   
어떤 메시지가 있을 때 그 메시지를 수신할 객체는 어떻게 선택하는가?    
첫 번째 전략은 도메인 개념 중에서 가장 적절한 것을 선택하는 것이다.   
도메인 개념 안에서 적절한 객체를 선택하는 것은 도메인에 대한 지식을 기반으로 코드의 구조와 의미를 쉽게 유추할 수 있게 한다.   
이것이 시스템의 유지보수성에 큰 영향을 미친다.   

<br />

### 인터페이스와 구현을 분리하라  
명세 관점은 클래스의 안정적인 측면을 드러내야 한다.   
구현 관점은 클래스의 불안정한 측면을 드러내야 한다.   
인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동치는 취약한 설계가 된다.     

중요한 것은 클래스를 봤을 때 클래스를 명세 관점과 구현 관점으로 나눠볼 수 있어야 한다는 것이다.   
캡슐화를 위반해서 구현을 인터페이스 밖으로 노출하면 안되고,   
인터페이스와 구현을 분리하지 않고 섞어놓아도 안된다.   


<br />

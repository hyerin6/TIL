## InnoDB 스토리지 엔진 아키텍처        

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공한다.       
때문에 높은 동시성 처리가 가능하고 성능이 뛰어나다.       


![innodb-architecture](https://user-images.githubusercontent.com/33855307/104544101-5525e100-566a-11eb-927b-e6cdc1b0cf5a.png)     
<br />   


#### InnoDB 스토리지 엔진의 특성          

* 프라이머리 키에 의한 클러스터링                                  
프라이머리 키 순으로 디스크에 저장된다. 때문에 프라이머리 키에 의한 레인지 스캔은 상당히 빨리 처리될 수 있다.                                 


* 잠금이 필요없는 일관된 읽기(Non-locking consistent read)                                    
락을 걸지 않기 때문에 InnoDB에서 읽기 작업은 다른 트랜잭션이 가지고 있는 락을 기다리지도 않는다.                               
SERIALIZABLE 격리 수준을 제외하고 읽기 작업이 가능하다.                                   


* 외래 키 지원     
외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY 테이블에서는 사용할 수 없다.                              
    - InnoDB에서 외래키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요함                                  
    - 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하기 때문에     
    잠금이 여러 테이블로 전파되어 데드락이 발생할 때가 많다.      
      

* 자동 데드락 금지                                   
InnoDB는 그래프 기반의 데드락 체크 방식을 사용하기 때문에 데드락이 발생함과 동시에 바로 감지되고                            
감지된 데드락은 관련 트랜잭션 중에서 ROLLBACK이 가장 용이한 트랜잭션을 자동적으로 강제 종료해버린다.                                                    
(ROLLBACK이 가장 용이한 트랜잭션 : 롤백을 했을 때 복구 작업이 가장 작은 트랜잭션, 레코드를 가장 적게 변경한 트랜잭션)                                 
따라서 데드락 때문에 쿼리가 제한시간에 도달한다거나 슬로우 쿼리로 기록되는 경우는 많지 않다.                              


* 자동화된 장애 복구                                                      
InnoDB에는 손실이나 장애로부터 데이터를 보호하기 위한 여러 가지 메커니즘이 탑재돼 있다.                                                     
MySQL 서버가 시작될 때, 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 일련의 복구 작업이 자동으로 진행된다.                             
                
                         
* 오라클의 아키텍처 적용                             
InnoDB 스토리지 엔진의 기능은 오라클 DBMS의 기능과 상당히 비슷한 부분이 많다.                             
대표적으로 MVCC 기능이 제공된다는 것, 언두(Undo) 데이터가 시스템 테이블 스페이스에 관리된다는 것,                            
테이블 스페이스의 개념 등 이 있으며 이 외에도 비슷한 부분이 많다.                            
<br />        


#### InnoDB 버퍼 풀          
InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, **디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간이다.**           
쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 **버퍼 역할**도 같이 한다.      
일반적인 애플리케이션에서는 데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하기 때문에 랜덤한 디스크 작업을 발생시킨다.     
하지만 버퍼 풀이 이러한 변경된 데이터를 모아서 처리하게 되면 **랜덤한 디스크 작업의 횟수를 줄일 수 있다.**       

MyISAM 키 캐시가 인덱스의 캐시만을 주로 처리하는 데 비해         
InnoDB의 버퍼 풀은 데이터와 인덱스 모두 캐시하고 쓰기 버퍼링의 역할까지 모두 처리하고 있는 것이다.       

InnoDB 버퍼 풀은 아직 디스크에 기록되지 않은 변경된 데이터를 가지고 있다.          
이러한 더티 페이지는 InnoDB에서 주기적으로 또는 어떤 조건이 되면 체크 포인트 이벤트가 발생하는데   
이때 Write 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록된다.    
체크 포인트가 발생한다고 해서 버퍼 풀의 모든 더티 페이지를 디스크로 기록하는 것은 아니다.   
<br />        


#### 언두(Undo) 로그     
언두 영역은 UPDATE 문장이나 DELETE와 같은 문장으로 데이터가 변경했을 때 변경되기 전의 데이터를 보관하는 곳이다.    

```
mysql> UPDATE member SET name='홍길동' WHERE member_id='1';
```

위 문장이 실행되면 트랜잭션을 커밋하지 않아도 실제 데이터 파일(데이터/인덱스 버퍼) 내용은 "홍길동"으로 변경된다.      
그리고 변경되기 전의 값이 "벽계수" 였다면, 언두 영역에는 "벽계수"라는 값이 백업되는 것이다.    
이 상태에서 만약 사용자가 커밋하게 되면 상태가 그대로 유지되고, 롤백하게 되면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.   

언두의 데이터는 크게 두 용도로 사용된다.       
* 트랜잭션의 롤백 대비용    
* 트랜잭션의 격리 수준을 유지하면서 높은 동시성을 제공     
<br />   
 
 
#### 인서트 버퍼(Insert Buffer)       
RDBMS에서 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업뿐 아니라 해당 테이블에 포함된 인덱스를 업데이트하는 작업도 필요하다.     
인덱스를 업데이터하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하고 테이블에 인덱스가 많다면 이 작업은 상당히 많은 자원을 소모하게 된다.      
그래서 InnoDB는 변경해야 할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수정하지만, 디스크로부터 읽어와서 업데이트해야 한다면    
임시 공간에 저장해두고 바로 사용자에게 결과를 반환하는 형태로 성능을 향상시키게 되는데, 이때 사용하는 임시 메모리 공간을 인서트 버퍼라고 한다.     

사용자에게 결과를 전달하기 전에 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 인서트 버퍼를 사용할 수 없다.      
인서트 버퍼에 임시 저장돼 있는 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 인서트 버퍼 머지 스레드라고 한다.   
<br />   


#### 리두(Redo) 로그 및 로그 버퍼    
쿼리 문장으로 데이터를 변경하고 커밋하면 DBMS는 데이터의 ACID를 보장하기 위해 즉시 변경된 데이터의 내용을 데이터 파일로 기록해야 한다.   
하지만 순차적으로 많은 데이터를 한꺼번에 변경 X, 랜덤하게 디스크에 기록해야 하기 때문에 디스크를 상당히 바쁘게 만드는 작업이다.   
그래서 버퍼링을 두기 위해 버퍼 풀과 같은 장치가 포함돼 있지만 이 장치만으로 ACID를 보장할 수 없어서             
이를 위해 **변경된 데이터를 순차적으로 디스크에 기록하는 리두 로그 파일**을 가지고 있다.   

리두 로그 덕분에 DBMS 데이터는 버퍼링을 통해 한번에 디스크에 변경된 내용을 처리할 수 있고 그로 인해 상당한 성능 향상을 기대할 수 있게 되었다.    
하지만 사용량이 매우 많은 DBMS 서버의 경우 이 리두 로그의 기록 백업이 큰 문제가 되서 이를 보완하기 위해 최대한 ACID 속성을 보장하는 수준에서 버퍼링하게 된다.   
이러한 리두 로그 버퍼링에 사용되는 공간이 로그 버퍼다.      
(여기서 ACID는 트랜잭션의 무결성을 보장하기 위한 4가지 요소를 의미한다. 원자성, 일관성, 격리성, 지속성)      
<br />       


#### MVCC(Multi Version Concurrency Control)       
일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능이다.          
MVCC의 가장 큰 목적 => 잠금을 사용하지 않는 일관된 읽기를 제공             
InnoDB는 언두 로그를 이용해 이 기능을 구현한다.            

다음은 격리 수준이 READ_COMMITED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블의 데이터 변경 처리 예제이다.   

```
mysql> CREATE TABLE member (
    m_id INT NOT NULL, 
    m_name ... , 
    m_area ... , 

    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);

mysql> INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');

mysql> COMMIT;
```

INSERT 문이 실행되면, 데이터베이스의 상태는 다음과 같이 변경된다.   

<br />   
<img width="676" alt="스크린샷 2021-01-14 오후 3 01 26" src="https://user-images.githubusercontent.com/33855307/104551026-64605b00-5679-11eb-888b-83c98ffe2ff4.png">    
<br /><br />            
 
다음은 MEMBER 테이블에 UPDATE 문장이 실행될 때의 처리 절차다.         

```
mysql> UPDATE memebr SET m_name='박혜린' WHERE m_id=12;
```

<br />     
<img width="457" alt="스크린샷 2021-01-14 오후 3 12 57" src="https://user-images.githubusercontent.com/33855307/104551866-00d72d00-567b-11eb-9b04-9b9409bbf78f.png">       
<br /><br />                 

UPDATE 문장이 실행되면 커밋 여부와 관계 없이, InnoDB의 버퍼 풀은 새로운 값인 "박혜린"으로 업데이트 된다.   
디스크의 데이터 파일에는 체크 포인트나 InnoDB의 Write 스레드에 의해 새로운 값으로 업데이트돼 있을 수도 있고 아닐 수도 있다.   
<br />   

아직 COMMIT이나 ROLLBACK이 되지 않은 상태에서 다른 사용자가 다음 같은 쿼리로 작업 중인 레코드를 조회하면 어디에 있는 데이터를 조회할까?   

```
mysql> SELECT * FROM member WHERE m_id=12;
```

답은 MySQL 초기화 파라미터에 설정된 격리 수준에 따라 다르다.      

* READ_UNCOMMITTED         
InnoDB 버퍼 풀이나 데이터 파일로부터 변경되지 않은 데이블을 읽어서 반환        
      
* READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE          
아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경 이전의 내용을 보관하고 있는 언두 영역의 데이터를 반환   


이러한 과정을 DBMS에서는 MVCC라고 표현한다.      
즉 하나의 레코드에 대해 2개의 버전이 유지되고 필요에 따라 어느 데이터가 보여지는지 여러 가지 상황에 따라 달리지는 구조다.       
 
지금까지 UPDATE 쿼리가 실행되면 InnoDB 버퍼 풀은 즉시 새로운 데이터로 변경되며 기존의 데이터는 언두로 복사되는 과정까지 알아봤는데        
이 상태에서 COMMIT 명령을 실행하면 InnoDB는 더 이상 변경 작업 없이 지금의 이 상태를 영구적인 데이터로 만들어 버린다.        
하지만 롤백을 실행하게 되면 언두 영역에 있는 백업된 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제해 버린다.          
커밋이 된다고 언두 영역의 백업 데이터가 항상 바로 삭제되는 것은 아니고 언두 영역을 필요로 하는 트랜잭션이 더는 없을 때 비로소 삭제된다.          
<br />    


#### 잠금 없는 일관된 읽기(Non-locking consistent read)        
InnoDB에서 격리 수준이 SERIALIZABLE이 아닌 READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ 수준인 경우     
INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 관계없이 항상 잠금을 대기하지 않고 바로 실행된다.        
특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았다 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않는다.   
이를 잠금 없는 일관된 읽기라고 표현하며, InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두(Undo) 로그를 사용한다.    

오랜시간 활성 상태인 트랜잭션으로 인해 MySQL 서버가 느려지거나 문제가 발생할 때가 가끔 있는데     
이러한 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지해야 하기 때문에 발생하는 문제다.     
따라서 트랜잭션이 시작됐다면 가능한 빨리 롤백이나 커밋을 통해 완료하는 것이 좋다.       
<br />    


#### InnoDB와 MyISAM 스토리지 엔진 비교    
MySQL 5.5부터는 InnoDB 스토리지 엔진이 기본 스토리지 엔진으로 채택됐다.      
InnoDB 스토리지 엔진은 MyISAM보다 많은 기능과 특징을 갖고 있으며 안전성 또한 우수하다.    

MyISAM 스토리지 엔진이 인덱스를 위한 키 캐시를 가지고 있지만 데이터 자체는 운영체제의 캐시에 의존하는 반면   
InnoDB 스토리지 엔진은 자체적인 버퍼 풀을 가지고 좀 더 업무 특성에 맞는 캐싱이나 버퍼링을 수행한다.    
InnoDB은 MyISAM 보다 MySQL 서버의 설정 튜닝이 조금 더 까다롭다.      

이하 129p 참고    
<br />      

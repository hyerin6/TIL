# 예외   

예제로 만들어봤던 JdbcContext와 스프링의 JdbcTemplate를 알아보면서 얼렁뚱땅 넘어간 부분이 있다.   


```   
public void deleteAll() throws SQLException() { . . . } // jdbcContext
public void deleteAll() { . . . } // jdbcTemplate        
```


JdbcTemplate을 적용한 코드에서는 SQLException이 사라졌다.      
어디로 갔을까?       


<br />        


## 초난감 예외처리   

#### 예외 블랙홀      

```
try {
	. . .
} catch(SQLException e) { // 예외를 잡고 아무것도 하지 않는 코드   
}
```

위 코드는 예외를 잡고 아무것도 하지 않고 무시해버리는 코드다.        
이렇게 구현하면 컴파일러 에러 메시지도 없어지고 간단한 예제에서라면 별문제 없이 잘 동작한다.     


하지만 아무것도 하지 않고 넘어가 버리는 건 정말 위험하다.   
발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나 메모리나 리소스가 소진되거나,   
예상치 못한 다른 문제가 일어날 수 있다.    

다음과 같은 처리도 문제가 있다.   


```
} catch(SQLException e) {
	System.out.println(e);
}


} catch(SQLException e) {
	e.printStackTrace();  
}  
```

  
위 코드는 예외가 발생했을 때 화면에 출력해주는 것이다.          
콘솔 로그를 누가 계속 모니터링하지 않는 한 이 예외 코드는 그냥 남아있을 것이다.          

예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다.   
모든 예외는 적절하게 복구되든지 아니면 작업을 중단하고 운영자 또는 개발자에게 분명하게 통보돼야 한다.         



#### 무의미하고 무책임한 throws           

예외 블랙홀보다는 조금 낫긴 하지만 무책임한 throws 선언도 심각한 문제점이 있다.        
자신이 사용하려고 하는 메소드에 throws Exception이 선언되어 있다고 생각해보자.     
그런 메소드 선언에서는 의미 있는 정보를 얻을 수 없다. 정말 무엇인가 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 아니면 그냥 습관적으로 붙여넣은 것인지 알 수가 없다.   
결국 이런 메소드를 사용하는 메소드에서도 역시 throws Exception을 따라서 붙이는 수밖에 없다.     
결과적으로 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.         




<br />    


## 예외의 종류와 특징       

그렇다면 예외를 어떻게 다뤄야 할까?    
가장 큰 이슈는 체크 예외(checked exception)라고 불리는 명시적인 처리가 필요한 예외를 사용하고 다루는 방법이다.      
자바에서 throw를 발생시킬 수 있는 예외는 크게 세 가지가 있다.         


#### Error       

첫번째로는 java.lang.Error 클래스의 서브 클래스이다.     
에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다. 그래서 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안된다.      
OutOfMemoryError나 ThreadDeath같은 에러는 catch 블록으로 잡아봤자 아무런 대응 방법이 없기 때문이다.  
따라서 시스템 레벨에서 특별한 작업을 하는 게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경쓰지 않아도 된다.    


#### Exception과 체크 예외    

java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외 상황이 발생했을 경우에 사용된다.   

Exception 클래스는 다시 체크 예외와 언체크 예외로 구분된다.     
체크 예외는 Exception 클래스의 서브 클래스이며 RuntimeException 클래스를 상속하지 않은 것이고,   
언체크 예외는 RuntimeException을 상속한 클래스들을 말한다.         

RuntimeException은 Exception의 서브 클래스이므로 Exception의 일종이긴 하지만 자바는 이 RuntimeException과 그 서브클래스는 특별하게 다룬다.      


![스크린샷 2020-10-22 오후 4 32 37](https://user-images.githubusercontent.com/33855307/96839484-386f7800-1484-11eb-80ce-f0b906265ddd.png)   


일반적으로 예외라고 하면 Exception 클래스의 서브 클래스 중에서 RuntimeException을 상속하지 않은 것만들 말하는 체크 예외라고 생각해도 된다. 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다. 그렇지 않으면 컴파일 에러가 발생한다.   



#### RuntimeException과 언체크/런타임 예외     

java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 또는 대표 클래스 이름을 따서 런타임 예외라고도 한다.      
에러와 마찬가지로 이 런타임 예외는 catch로 잡거나 throws로 선언하지 않아도 된다.    

런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나, 허용되지 않는 값을 사용해서 메소드를 호출할 때 발생하는 IllegalArgumentException 등이 있다.   
이런 예외는 코드에서 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있다.    
피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외다.   


<br />    


## 예외처리 방법    

#### 예외 복구   

첫번째 예외처리 방법은 예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려 놓는 것이다.     

예시) 사용자가 요청한 파일을 읽으려고 시도할 때 해당 파일이 없거나 다른 문제가 있어서 읽히지 않아서 IOException이 발생했다고 생각해보자.   

예외처리) 사용자에게 상황을 알리고 다른 파일을 사용하도록 안내해서 예외상황을 해결할 수 있다.   
단, IOException 에러 메시지가 사용자에게 그냥 던져지기만 하는 것은 예외복구라고 볼 수 없다.   















































































































































































































































































































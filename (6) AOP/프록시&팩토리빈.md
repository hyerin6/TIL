# 다이내믹 프록시와 팩토리 빈             
   
## 1. 프록시와 프록시 패턴, 데코레이터 패턴     

트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리했을 때 적용했던 기법을 생각해보자.      
단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전형적인 전략 패턴을 사용하면 된다.      
추상화 작업을 통해 이미 전략 패턴은 적용되어 있다.      
그러나 기능 구현 내용을 분리했을 뿐 트랜잭션을 적용한다는 코드는 그대로 남아있다.      

```   
      (1)                                   (2)
   핵심 기능                핵심 기능 코드             부가기능 인터페이스 
      +           =>            +            ->            +
부가기능 구현 코드           부가기능 위임 코드           부가기능 구현 코드 
```   

(1)과 같이 `핵심기능+부가기능` 코드가 (2)처럼 분리되었어도 위임을 통해 기능을 사용한다는 코드가 남아있다.       

트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 적용 사실 자체를 밖으로 분리할 수 있다.   
부가기능 전부를 핵심기능 코드에서 빼내는 것이다.    

```
부가기능 -> 핵심기능
```  

이렇게 분리된 부가기능을 담은 클래스는 중요한 특징이 있다.    
부가기능 외의 나머지 모든 기능을 원래 핵심기능을 가진 클래스로 위임해줘야 한다.    
핵심기능은 부가기능을 가진 클래스를 모른다. 그래서 부가기능이 핵심기능을 사용하는 구조가 된다.    

문제는 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.   
그래서 부가기능은 자신이 핵심기능 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다.       


![스크린샷 2020-12-22 오후 2 13 45](https://user-images.githubusercontent.com/33855307/102851728-ef29ad80-445f-11eb-8ee4-b2265e089a09.png)    


부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.     
비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 대표적인 경우다.   


- 프록시(대리자, 대리인) : 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것      
- 타깃, 실체 : 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트          

```      
클라이언트 -> 프록시 -> 타깃 
``` 

프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.   

프록시는 사용 목적에 따라 두 가지로 구분된다.   
- 클라이언트가 타깃에 접근하는 방법을 제어하기 위함    
- 타깃에 부가적인 기능을 부여해주기 위함   

전부 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만   
목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.    

<br />       

#### 데코레이터 패턴    
데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시에 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴이다.   
어떤 방법과 순서로 프록시와 타깃이 연결되는지 컴파일 시점에서 정해진게 아니다.   
데코레이터 패턴에서는 프록시가 꼭 한개로 제한되지 않고 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다.   
프록시가 여러개일 수 있기 때문에 순서를 정해서 단계적으로 위임하는 구조로 만들면 된다.   

```  
클라이언트 -> 1번 프록시 -> 2번 프록시 -> 3번 프록시 -> 타깃   
```  

부가적인 기능을 각각 프록시로 만들어두고 런타임 시에 적절한 순서로 조합해서 사용하면 된다.          

<br />            

프록시로 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃인지,   
다음 단계인 프록시로 위임하는지 알 수 없다.   
그래서 다음 위임 대상은 인터페이스로 선언하고 생성자나 Setter를 통해 위임 대상을 외부에서 런타임 시에 주입 받을 수 있도록 만들어야 한다.    

`UserService` 인터페이스를 구현한 타깃인 `UserServiceImpl`에 트랜잭션 부가기능을 제공해주는 `UserServiceTx`를 추가한 것도   
데코레이터 패턴을 적용한 것이라고 볼 수 있다. 이 예제에서는 Setter를 이용해 타깃을 주입해줬다.          

데코레이터 패턴은 인터페이스를 통해 위임하는 방식이기 때문에 어느 타깃으로 연결되는지 코드 레벨에서 알 수 없다.   
`UserServiceTx`도 `UserServiceImpl`이라는 구체적인 클래스를 위임하는 게 아니다.   
`UserService` 인터페이스를 통해 다음 오브젝트로 위임하도록 되어있다.   

데코레이터 패턴은 이렇게 타깃, 클라이언트의 변경없이 새로운 기능을 추가할 때 유용한 방법이다.       

<br />       

#### 프록시 패턴         
일반적으로 사용하는 프록시 뜻과 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다.     
프록시 패턴은 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 말한다.     
타깃의 기능을 확장하거나 추가하지 않는 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.      

타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 타깃 오브젝트는 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋은데     
타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다. 이럴 때 프록시 패턴을 적용하면 된다.          
그러나 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는 경우가 있는데 실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다.      
프록시의 메소드를 통해 타깃을 사용하려고 시도하면 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.        

만약 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후에 사용되는 경우라면       
이렇게 프록시를 통해 타깃 오브젝트의 생성을 최대한 늦춤으로써 얻는 장점이 많다.           


예제를 통해 알아보자.   

1. 원격 오브젝트를 이용하는 경우      
이 경우 프록시를 사용하면 편리하다. 다른 서버에 존재하는 오브젝트를 사용해야 한다면,           
원격 오브젝트에 대한 프록시를 만들어두고 클라이언트는 마치 로컬에 존재하는 오브젝트를 쓰는 것처럼 프록시를 사용하게 할 수 있다.      
프록시는 클라이언트의 요청을 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게 돌려준다.            

2. 특별한 상황에서 타깃에 대한 접근권한을 제어하는 경우    
만약 수정 가능한 오브젝트가 있는데 특정 레이어로 넘어가서는 읽기전용으로만 동작하게 강제해야 한다고 하자.            
이럴 때는 오브젝트의 프록시를 만들어서 사용할 수 있다.       
프록시의 특정 메소드를 사용하려고 할 때 접근이 불가능하다고 예외를 발생시키면 된다.              


구조적으로 보면 데코레이터 패턴과 프록시 패턴은 비슷하지만          
프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다.                    
생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문에 타깃 클래스에 대한 직접적인 정보를 알아야 한다.              
인터페이스를 통해 위임하도록 만들 수도 있지만 그 사이에 다른 프록시나 데코레이터가 추가될 수 있다.     

타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면 프록시라 부르지만      
부가 기능을 위함인지, 접근 제어를 담당하는 것인지 구분해보면 각각 어떤 목적으로 프록시를 사용한건지, 어떤 패턴인지 알 수 있다.     

<br />         

## 2. 다이내믹 프록시          

프록시는 매번 새로운 클래스를 정의해야 하고, 인터페이스의 구현 메소드가 많으면 모든 메소드를 일일이 구현해서 위임하는 코드를 넣어야 한다.   
단위 테스트에서 목을 일일이 클래스로 정의해서 모의 메소드를 구현하는 일이 불편했던 것과 마찬가지다.   
그렇다면 목 오브젝트를 만드는 불편함을 목 프레임워크가 편리하게 바꿨던 것처럼   
프록시도 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하지 않고 사용할 방법이 있을까?    

자바에는 `java.lang.reflect` 패키지 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다.            
일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이내믹하게 생성하는 것이다.        

<br />       

#### 프록시의 구성과 프록시 작성의 문제점         
프록시는 다음 두 가지 기능으로 구성된다.        
- 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.            
- 지정된 요청에 대해서는 부가기능을 수행한다.           

트랜잭션 부가기능을 위해 만든 `UserServiceTx`는 기능 부가를 위한 프록시다.      
프록시의 역할은 위임과 부가작업이라는 두 가지로 구분할 수 있다.        
`UserServiceTx`에서 두 기능을 분리해보자.       

```
public class UserServiceTx implements UserService {
    UserService userService; // 타깃 오브젝트

    public void add(User user) { // 메소드 구현과 위임 
        this.userService.add(user);
    }

    public void upgradeLevels() { // 메소드 구현 
        TransactionStatus status = ...; // 부가기능 수행 
        
        userService.upgradeLevels(); // 위임

        // 부가기능 수행 
        . . . 

    }

}
```

프록시를 만들기 번거로운 이유는 뭘까?           

- 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.       
부가기능이 필요없는 메소드까지 구현해야 한다. 또, 타깃 인터페이스에 메소드가 추가되거나 변경되면 함께 수정해줘야 한다.      
- 부가기능 코드가 중복될 가능성이 많다.      
트랜잭션은 DB를 사용하는 대부분의 로직에 적용될 필요가 있기 때문에 유사한 코드가 여러 메소드에 중복돼서 나타날 것이다.    

코드가 중복되는 문제는 분리해서 어떻게든 해결해보면 되겠지만   
첫번째 문제인 인터페이스 메소드의 구현과 위임 기능 문제는 간단하지 않다.   
이런 문제를 해결하는 데 유용한 것이 바로 JDK의 다이내믹 프록시다.   

<br />       

#### 리플렉션      
다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.   
리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 것이다.         

```
String name = "Spring";
```
이 문자열의 길이를 알고 싶으면 String 클래스의 `length()` 메소드를 호출하면 된다. 일반적으로 이렇게 사용한다. `name.length()`     

자바의 모든 클래스는 그 클래스 자체의 구성정보를 담은 Class 타입의 오브젝트를 하나씩 갖고있다.   
`클래스이름.class` 라고 하거나 오브젝트의 `getClass()` 메소드를 호출하면 클래스 정보를 담은 Class 타입 오브젝트를 가져올 수 있다.         

```
Method lengthMethod = String.class.getMethod("length");
```
String이 가진 메소드 중에서 "length" 라는 이름을 갖고 있고, 파라미터는 없는 메소드의 정보를 가져오는 것이다.   

`java.lang.reflect.Method` 인터페이스는 메소드에 대한 자세한 정보를 갖고 있으며, 이를 이용해 특정 오브젝트의 메소드를 실행시킬 수도 있다.       
Method 인터페이스에 정의된 `invoke()` 메소드를 사용하면 된다.          

```  
public Object invoke(Object obj, Object... args)
```  

이를 이용해 length() 메소드를 호출한다면 다음과 같다.       

```  
int length = lengthMethod.invoke(name); // int length = name.length();
```  

<br />          

#### 프록시 클래스         

다이내믹 프록시를 이용해 프록시를 만들어보자.   

![스크린샷 2020-12-22 오후 6 28 31](https://user-images.githubusercontent.com/33855307/102872765-82c0a580-4483-11eb-8ecf-677859fbd8b5.png)     


위 구조를 가진 프록시는 프록시 적용의 일반적인 문제점 두 가지를 모두 가지고 있다.    
인터페이스의 모든 메소드를 구현해 위임하도록 코드를 구현해야 하고, 부가기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복돼서 나타난다.        


<br />   


#### 다이내믹 프록시 적용         

![스크린샷 2020-12-22 오후 10 20 09](https://user-images.githubusercontent.com/33855307/102892858-de9b2680-44a3-11eb-9cc5-df97d6741e0a.png)     

다이내믹 프록시는 프록시 팩토리에 의해 런타임 시에 다이내믹하게 만들어지는 오브젝트이다.      
 
다이내믹 프록시 오브젝트는 타깃 인터페이스와 같은 타입으로 만들어지고          
클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다.    
이 덕분에 프록시를 만들 때 인터페이스를 모두 구현하지 않아도 된다.     
프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.       
        
다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 지공 코드는 직접 작성해야 한다.          
부가기능은 프록시 오브젝트와 독립적으로 `InvocationHandler`를 구현한 오브젝트에 담는다.        
`InvocationHandler` 인터페이스는 메소드 한 개만 가진 간단한 인터페이스다.   

```  
public Object invoke(Object proxy, Method method, Object[] args) 
```  

`invoke()` 메소드는 리플렉션의 Method 인터페이스를 파라미터로 받는다.   
메소드를 호출할 때 전달되는 파라미터도 args로 받는다.   

다이내믹 프록시 오브젝트는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 
`InvocationHandler` 구현 오브젝트의 `invoke()` 메소드로 넘기는 것이다.   
타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.       

각 메소드 요청은 어떻게 처리해야 할까?       
`InvocationHandler` 구현 오브젝트는 타깃 오브젝트 레퍼런스를 갖고 있으면           
리플렉션을 이용해 간단히 위임 코드를 만들어 낼 수 있다.         


먼저 `InvocationHandler`를 만들어보자.   

```   
public class Uppercasehandler implements InvocationHandler {
    // 다이내믹 프록시로부터 전달받은 요청을 다시 타깃 오브젝트에 위임하기 위해   
    // 타깃 오브젝트를 주입받아야 한다.  
    Hello target; 
    
    public UppercaseHandler(Hello target) {
        this.target = target;
    }

    public Object invoke(Object proxy, Method method, Object[] args) {
        String ref = (String)method.invoke(taraget, args); // 타깃으로 위임  
        return ref.toUpperCase(); // 부가기능 제공
    }
}
```  

다이내믹 프록시로부터 요청을 전달받으려면 `InvocationHandler`를 구현해야 한다.     
다이내믹 프록시가 클라이언트로부터 받는 모든 요청은 `invoke()` 메소드로 전달된다.     
다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다.     

타깃 오브젝트의 메소드 호출이 끝났으면 프록시가 제공하려는 부가기능을 수행하고 결과를 리턴한다.      
리턴된 값은 다이내믹 프록시가 받아서 최종적으로 클라이언트에게 전달된다.      


다음으로 `InvocationHandler`를 사용하고 Hello 인터페이스를 구현하는 프록시를 만들어보자.             
다이내믹 프록시의 생성은 Proxy 클래스의 `newProxyInstance()` 스태틱 팩토리 메소드를 이용하면 된다.            

```  
// 생성된 다이내믹 프록시 오브젝트는 Hello 인터페이스를 구현하고 있으므로 Hello 타입으로 캐스팅해도 안전한다.   
Hello proxiedHello = (Hello)Proxy.newProxyInstance( 
        getClass().getClassLoader(), // 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에 사용할 클래스 로더 
        new Class[] { Hello.class }, // 구현할 인터페이스
        new UppercaseHandler(new HelloTarget())); // 부가기능과 위임 코드를 담은 invocationHandler
```  

다음은 간단한 사용방법이다. 

- 첫 번째 파라미터로 클래스 로더를 제공해야 한다.   
다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것이다.     

- 두 번째 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스이다.      

- 마지막 파라미터는 부가기능과 위임 관련 코드를 담고 있는 `InvocationHandler` 구현 오브젝트를 제공해야 한다.    
타깃 오브젝트를 생성자로 받고, 원하는 부가기능의 Handler 오브젝트를 전달하면 된다.   

<br />    

## 3. 다이내믹 프록시를 이용한 트랜잭션 부가기능        

`UserServiceTx`를 다이내믹 프록시 방식으로 변경해보자.     
`UserServiceTx`는 서비스 인터페이스의 메소드를 모두 구현해야 하고     
트랜잭션이 필요한 메소드마다 트랜잭션 처리코드가 중복돼서 나타나는 비효율적인 방법으로 만들었었다.      

다이내믹 프록시와 연동해서 트랜잭션 기능을 부가해주는 `InvocationHandler`를 구현해보자.    


#### 트랜잭션 `InvocationHandler`        

```
public class TransactionHandler implements InvocationHandler {
    private Object target; // 타깃 오브젝트
    private PlatformTransactionManager tm;
    private String pattern;

    public void setTarget(Object target) { this.target = target; }

    . . .

    public Object invoke(Object proxy, Method method, Object[] args) {
        // 트랜잭션 적용 대상 메소드를 선별해 트랜잭션 경계설정 기능을 부여한다.   
        if(method.getName().startWith(pattern)) {
            return invokeInTransaction(method, args);
        } else {
            return method.invoke(target, args);
        }
    }

    private Object invokeTransaction(Method method, Object[] args) { . . . }

}
```

트랜잭션을 적용하면서 타깃 오브젝트의 메소드를 호출하는 것은 `UserServiceTx`에서와 동일하다.        
한 가지 달라진 점은 롤백을 적용하기 위한 예외는 `RuntimeException` 대신에 `InvocationTargetException`을 잡도록 해야 한다는 것이다.       
리플렉션 메소드인 `Method.invoke()`를 이요해 타깃 오브젝트의 메소드를 호출할 때는     
타깃 오브젝트에서 발생하는 예외가 `InvocationTargetException`으로 한 번 포장돼서 전달되기 때문이다.     
`getTargetException()` 메소드로 중첩되어 있는 예외를 가져와야 한다.             

<br />          

## 4. 다이내믹 프록시를 위한 팩토리 빈       

























































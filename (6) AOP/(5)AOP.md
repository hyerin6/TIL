# AOP         

비즈니스 로직을 담은 `UserService`에 트랜잭션을 적용해온 과정을 정리해보자.   


#### 트랜잭션 서비스 추상화       
트랜잭션 경계설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 만난 첫번째 문제는 특정 트랜잭션 기술에 종속되는 코드가 돼버린다는 것이었다.    
JDBC의 로컬 트랜잭션 방식을 적용한 코드를 JTA를 이용한 글로벌/분산 트랜잭션 방식으로 바꾸려면 모든 트랜잭션 적용 코드를 수정해야 한다는 문제점이 있었다.     
그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 서비스 추상화 기법을 적용했다.   
구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이내믹하게 연결해준다는 DI를 활용한 전형적인 접근 방법이었다.   

트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고 그것을 어떻게 하는지를 분리한 것이다.      
어떻게 할지는 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.     


#### 프록시와 데코레이터 패턴         
트랜잭션을 어떻게 다룰까는 추상화를 통해 코드에서 제거했지만, 여전히 비즈니스 로직 코드에는 트랜잭션을 적용하고 있다는 사실이 드러나 있다.    
문제는 트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다는 점이고      
트랜잭션 경계설정을 담당하는 코드의 특성 때문에 단순한 추상화와 메소드 추출 방법으로는 더 이상 제거할 방법이 없었다.      

그래서 도입한 것이 DI를 이용해 데코레이터 패턴을 적용하는 방법이다.   
투명한 부가기능 부여를 가능하게 하는 데코레이터 패턴의 적용으로 비즈니스 로직을 담당하는 클래스도 자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됐다.        
클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서       
트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만들었다.      
트랜잭션 처리 코드는 일종의 데코레이터에 담겨서 클라이언트와 비즈니스로직을 담은 타깃 클래스 사이에 존재하도록 만들었다.         
클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐 타깃에 접근할 수 있게 됐다.            


#### 다이내믹 프록시와 프록시 팩토리 빈          
프록시를 이용해서 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거했지만        
비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업이 오히려 큰 짐이 됐다.        
트랜잭션 기능을 부여하지 않아도 되는 메소드조차 프록시로서 위임 기능이 필요하기 때문에 일일리 다 구현을 해줘야했다.   

그래서 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용했다.   
그 덕분에 프록시 클래스 코드 작성의 부담도 덜고, 부가기능 부여 코드가 여기저기 중복돼서 나타나는 문제도 일부 해결했다.    
하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제는 해결하지 못했다.   

JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다.      
내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와    
부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유할 수 있게 됐다.       


#### 자동 프록시 생성 방법과 포인트컷                       
트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 아직 남아있다.        
이를 해결하기 위해서 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.       
결국 트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다.       


#### AOP: 애스펙트 지향 프로그래밍               
전통적인 객체지향 기술의 설계 방법으로는 독립적인 모듈화가 불가능한 트랜잭션 경계설정과 같은 부가기능을 어떻게 모듈화할까       
고민하다가 사람들은 이런 부가기능 모듈을 객체지향 기술에서 주로 사용하는 오브젝트와는 다르게 특별한 이름으로 부르기 시작했다.        
그것이 바로 애스펙트다. (aspect)        

애스펙트란 그 자체로 애플케이션의 핵심기능을 담고 있지는 않지만 애플리케이션을 구성하는 중요한 한 가지 요소이고,       
핵심기능에 부가되어 기능을 갖는 특별한 모듈을 가리킨다.       
애스펙트는 부가될 기능을 정의한 코드인 어드바이스와 어드바이스를 어디에 적용할지를 결정하는 포인트컷을 함께 갖고 있다.           
지금까지 본 예제의 어드바이저는 단순한 형태의 애스펙트라고 볼 수 있다.                 

![스크린샷 2020-12-27 오후 10 52 06](https://user-images.githubusercontent.com/33855307/103172348-2bad3d00-4896-11eb-8ef2-87bc26688c73.png)    

이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서                
애스펙트라는 독특한 모듈로 만들어 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍 혹은 AOP(Aspect Oriented Programming의 약자)라고 한다.                        


AOP는 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계, 개발할 수 있도록 만들어주는 것이다.          
그래서 애플리케이션을 다양한 관점에서 바라보며 개발할 수 있게 도와준다.           
이렇게 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 관점 지향 프로그래밍이라고도 한다.           


#### 바이트코드 생성과 조작을 통한 AOP    
가장 강력한 AOP 프레임워크로 꼽히는 AspectJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.                    
프록시를 사용하지 않고 어떻게 독립적으로 만든 부가기능을 타깃 오브젝트에 적용할까?                      

AspectJ는 프록시처럼 간접적인 방법이 아니라 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다.                   
부가기능을 넣는다고 소스코드를 수정할 수 없으니 컴파일된 타깃의 클래스 파일 자체를 수정하거나                   
클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.                   
왜 컴파일된 클래스 파일 수정이나 바이트코드 조작과 같은 복잡한 방법을 사용할까?      

1. 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서     
자동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있다.          
스프링과 같은 컨테이너가 사용되지 않는 환경에서도 AOP 적용이 가능해진다.    

2. 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문이다.           


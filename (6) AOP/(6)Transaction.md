# Transaction    

`PlatformTransactionManager`로 대표되는 스프링의 트랜잭션 추상화를 설명하면서 얼렁뚱땅 넘어간게 한 가지 있다.    
트랜잭션 매니저에서 트랜잭션을 가져올 때 사용한 `DefaultTransactionDefinition` 오브젝트다.    
트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전달하는 `DefaultTransactionDefinition` 용도는 무엇일까?      

다음 블로그글에 트랜잭션이 정리되어 있다.   
<https://hyerin6.github.io/2020-06-13/transaction/>          


<br />       

트랜잭션 정의를 수정하려면 어떻게 해야 할까?             
`TransactionDefinition` 오브젝트를 생성하고 사용하는 코드는 트랜잭션 경계설정 기능을 가진 `TransactionAdvice`다.          
트랜잭션 정의를 바꾸고 싶다면 디폴트 속성을 갖고 있는 `DefaultTransactionDefinition`을 사용하는 대신 외부에서 정의된            
`TransactionDefinition` 오브젝트를 DI 받아서 사용하도록 만들면 된다.            
하지만 이 방법으로는 트랜잭션 속성을 변경하면 `TransactionAdvice`를 사용하는 모든 트랜잭션의 속성이 한꺼번에 바뀐다는 문제가 있다.           
원하는 메소드만 선택해서 독자적인 트랜잭션 정의를 적용할 수 있는 방법은 없을까?         

<br />       

## 트랜잭션 인터셉터와 트랜잭션 속성     
메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다.        
메소드 이름 패턴에 따라 다른 트랜잭션 정의가 적용되도록 만드는 것이다.    

#### TransactionInterceptor       
스프링에는 편리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있도록 만들어진 `TransactionInterceptor`가 존재한다.          
`TransactionInterceptor`는 `PlatformTransactionManager`와 `Properties` 타입의 두 가지 프로퍼티를 갖고 있다.      

`Properties` 타입인 두 번째 프러퍼티 이름은 transactionAttributes로, 트랜잭션 속성을 정의한 프로퍼티다.   
트랜잭션 속성은 `TransactionDefinition`의 네 가지 기본 항목에 `rollbackOn()`이라는 메소드를 하나 더 갖고 있는 
`TransactionAttribute` 인터페이스로 정의된다.   
`rollbackOn()` 메소드는 어떤 예외가 발생하면 롤백을 할 것인가를 결정하는 메소드다.   


<br />    

## 포인트컷과 트랜잭션 속성의 적용 전략       
트랜잭션 부가기능을 적용할 후보 메소드를 선정하는 작업은 포인트컷에 의해 진행된다.   
그리고 어드바이스의 트랜잭션 전파 속성에 따라서 메소드별로 트랜잭션의 적용 방식이 결정된다.        
포인트컷 표현식과 트랜잭션 속성을 정의할 때 따르면 좋을 몇 가지 전략을 알아보자.     

#### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 사용한다.   
일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직하다.          
쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는 게 좋다.   
조회의 경우에는 읽기전용으로 트랜잭션 속성을 설정해두면 그만큼 성능의 향상을 가져올 수 있다.    

#### 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.                  
기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어 두면       
하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지정할 수 있다.             

#### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.         
이것은 전략은 아니고 주의사항이다.   
프록시 방식의 AOP에서는 프록시를 통한 부가기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다.   
타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일어나지 않는다.   

타깃 안에서의 호출에는 프록시가 적용되지 않는 문제를 해결하는 방법은 두 가지가 있다.      

1. 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제하는 방법이다.           
이는 비즈니스 로직만 남긴 코드에 스프링 API와 프록시 호출 코드를 추가하는 것으로 바람직하지 않아 추천하지 않는 방법이다.           

2. AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술을 적용한다.               


  

# 애플리케이션 아키텍처       

아키텍처의 가장 단순한 정의는 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고,       
어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다.         

<br />     

## 계층형 아키텍처      
스프링을 공부하면서 관심, 책임, 성격, 변하는 이유와 방식이 서로 다른것들을 분리함으로써   
결합도는 낮추고 응집도는 높이는 코드를 만들어 왔다.   

웹 애플리케이션에서도 이처럼 성격이 다른 것은 아키텍처 레벨에서 분리해주는 것이 좋다.        
만약, 분리하지 않고 JSP 처럼 HTML, JDBC 코드가 함께 존재한다면? 유지보수는 거의 불가능에 가까워 진다.     

이를 계층형 아키텍처라고 부르기도 하고 3-tier 애플리케이션 아키텍처라고 부르기도 한다.      

<br />          
 
#### 3계층 아키텍처와 수직 계층         
3계층 아키텍처는 다음으로 구성되어 있다.           

```  
클라이언트 ↔ 프레젠테이션 계층 ↔ 서비스 계층 ↔ 데이터 액세스 계층 ↔ DB/레거시 
```  
 
**- 데이터 액세스 계층: 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할**           
    
<details>
<summary>더보기</summary>
<div markdown="1">

<br />       
데이터 액세스 계층은 DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 부른다.    
DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS 계층이라고도 한다.    
대부분 데이터 저장을 목적으로 DB 이용이 주된 책임이고 외부 시스템을 호출해서 서비스를 이용하는 것은 기반 계층으로 따로 분류하기도 한다.    

데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다.     
다시 세분화하는 경우 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부른다.     
기본 3계층은 기술 계층보다는 역할에 따른 분류라 가로로 배열하는데      
데이터 액세스 계층은 같은 책임을 가졌지만 추상화 레벨에 따라 구분하기 때문에 세로로 배열한다.         
 

다음은 데이터 액세스 계층의 수직 계층구조이다.     
![스크린샷 2021-01-09 오후 4 29 44](https://user-images.githubusercontent.com/33855307/104086070-e4607c80-5297-11eb-87a6-9e410cc3c962.png)      
<br />     

</div>
</details>     
 
 

**- 서비스 계층: 비즈니스 로직을 담고 있는 계층**        

<details>
<summary>더보기</summary>
<div markdown="1">      

<br />      
잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다.              
POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트, 유연하게 확장할 수 있다.           
서비스 계층은 DAO 계층을 호출, 이용하거나 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.         
(예를들어, 원격 호출, 메일 또는 메시징 서비스가 대표적인 기반 서비스이다.)      
기반 서비스는 3계층 어디서나 접근하게 만들거나 서비스 계층을 통해 사용되도록 제한할 수도 있다.      
코드의 특징과 장단점, 활용 예를 잘 살펴서 결정하면 된다.           

서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다.      
단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에   
기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요없기 때문이다.    
기반 서비스 계층을 사용하는 경우에도 데이터 액세스 계층을 사용하는 경우와 마찬가지로 독립된 계층의 서비스를 이용하는 것으로 봐야 한다.    
비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층을 구분해야 한다.        

원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다.  
서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어 특정 구현과 기술에 대한 종속성을 제거해야 한다.   
또는 AOP를 통해 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.      

![스크린샷 2021-01-09 오후 4 55 57](https://user-images.githubusercontent.com/33855307/104086450-8d5ca680-529b-11eb-9e45-061c788d46d6.png)     
   

이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고,         
클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.       
엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어 있는 서비스 계층이어야 한다.     
<br />      

</div>
</details> 
   

**- 프레젠테이션 계층: 주로 웹 기반이 UI를 만들고 흐름을 관리**         
 
<details>     
<summary>더보기</summary>   
<div markdown="1">         

<br />     
프레젠테이션 계층은 가장 복잡한 계층이다. 다양한 기술과 프레임워크의 조합을 가질 수 있다.     
엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.                
<br />       

</div>  
</details>   

<br />         

 
#### 계층형 아키텍처 설계의 원칙          
오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다.      
각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.      

각 계층은 자신의 계층의 책임에만 충실해야 한다.     
데이터 액세스 계층에 비즈니스 로직을 담거나 웹 파라미터를 파싱하는 코드나 결과를 화면에 어떻게 뿌릴지 결정하는 코드가 드어간다면 응집도가 낮아진다.       
결과적으로 변화에 대한 유연성이 떨어지고, 이해하기 힘든 코드를 가진 계층이 되고 말 것이다.     
자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다.     

종종 실수하는 계층 간 설계의 예를 살펴보자.      
다음은 서비스 계층이 DAO를 호출할 때 사용하도록 정의한 인터페이스의 메소드다.     

```
public ResultSet findUserByName(String name) throws SQLException;
```

findUserByName의 문제는 **데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출**한다는 점이다.          
- 서비스 계층의 코드는 ResultSet이라는 데이터 액세스 계층에서 만들어진 오브젝트를 직접 다뤄야만 한다.             
- 경우에 따라 리소스를 반환하거나 DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다.           
- ResultSet을 다룰 때 발생하는 예외처리도 필요       

계층 간에 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다.   
오브젝트 간의 강한 결합이 있을 때 방생하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다.    
앞의 DAO 인터페이스의 메소드는 다음과 같이 수정돼야 한다.   

```
public List<User> findUserByName(String name) throws DataAccessException;
``` 

<br />     

또, 흔히 일어나는 실수 중 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다.   
서블릿의 HttpServletRequest나 HttpServletResponse 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안된다.     
계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다.     
재사용이 불가능하고 예외가 발생할 수도 있으며 문제의 원인을 찾기가 어려워지기 쉽다. 또한 테스트 작성도 힘들어진다.     

어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.   
당연히 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다.   
인터페이스를 사용하게 한다는건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다.    
여기서 말하는 인터페이스는 interface 키워드를 사용하라는 의미가 아니다.    
인터페이스에 아무 생각 없이 public 메소드를 추가한다면 인터페이스를 사용하는 가치는 떨어진다.    
한번 정의돼서 다른 계층에서 사용하기 시작한 인터페이스 메소드는 변경이 까다롭고 비용이 많이 든다.    

스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경계나 그 관계에 직접적으로 관여하지 않는다.     
하지만 모든 경계에는 오브젝트가 존재하고 그 사이의 관계도 오브젝트 대 오브젝트로 정의되기 마련이다.    
그러면에서 스프링의 DI가 계층 사이의 관계에도 적용된다고 볼 수 있다.        
하지만 DI는 계층을 구분하지 않기 때문에 빈 사이으이 의존관계를 만들 때 주의해야 한다.       
한 계층의 내부에서만 사용되도록 만든 빈이 있는데 이를 DI를 통해 다른 계층에서 함부로 쓰이는 일은 피해야 한다.   
또 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI 하지 않도록 주의해야 한다.    

<br />        

## 애플리케이션 정보 아키텍처       
애플리케이션에서 정보를 어떤식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.     
존재하는 정보를 데이터로 다루는 경우와 오브젝트로 다루는 경우로 나눌 수 있다.     

**데이터로 다루는 경우는 다음으로 구분한다.**        
- DB에 무게를 두는 경우         
- 서비스 계층의 코드에 무게를 두는 경우     

**오브젝트로 다루는 경우**           
- 도메인 모델을 반영하는 오브젝트 구조를 만들어주고 이걸 사용        


<br />          

#### DB/SQL 중심의 로직 구현 방식 (DB에 무게를 두는 경우)      
데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다.    

예) 사용자가 이름으로 사용자 정보를 검색해서 일치하는 사용자의 비밀번호, 이름, 가입일자만 보여주는 작업     
위 예제가 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다.             

검색조건은 SQL로 만들어진다. 사용자 정보를 웹 페이지에 나타낼 때 가입일자 중에서 연도만 보여줘야 한다면,    
가입일자 필드에서 연도를 추출하는 것은 SQL의 날자처리 함수를 이용해야 한다.   
SQL은 이미 화면에 어떤 식으로 출력이 될지 알고 있는 셈이다.    
서비스 계층에서는 별로 할 일이 없고 프레젠테이션 계층의 뷰는 DAO의 SQL에서 정확히 어떤 필드 값을 리턴할지,   
어떤 포맷으로 전달할지 알고 있다. 결과를 저장하는 오브젝트에서 값을 가져와 화면에 출력한다.    

모든 계층의 코드는 '이름을 이용한 고객 조회'라는 업무에 종속된다.      
또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다.         
종속적일 뿐만 아니라 배타적이어서 다른 단위 업무에 재사용되기 힘들다.    

개발하기 쉽지만 다음과 같은 단점이 있다.          
- 변화에 매우 취약하다.   
- 중복 제거가 쉽지 않다.       
- 각 계층의 코드가 긴밀하게 연결되어 객체지향의 장점이 별로 활용되지 못한다.      
- DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨어진다.      


<br />               


#### 거대한 서비스 계층 방식 (서비스 계층의 코드에 무게를 두는 경우)               
DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 
DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다.   
DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다.    

비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다.       
반면 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다.       
DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다.    
상대적으로 단순한 DAO 로직을 사용하고 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층을 만들게 된다.      

다음과 같은 장점이 있다.       
- 단위 업무별로 독립적인 개발이 가능해 초기 개발 속도가 빠르고 개발자 사이에서 독립적인 개발이 가능     
- (애플리케이션의 코드에 비즈니스 로직이 담겨) 핵심 로직이 자바 코드 안에 담겨 있어 테스트하기 수월하다.      
- SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드를 여러 비즈니스 로직에서 공유 가능      


그러나 다음과 같은 단점이 있다.           
- 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 즉 여전히 계층 간의 결합도가 크다.           
- 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 중복돼서 나타나기 쉽다.        


데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다.         
화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고       
장기적으로 코드 관리와 발전이 힘들다는 단점이 있다.              

<br />        

## 오브젝트 중심 아키텍처         
오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은    
도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것이다.          
이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처다.      
객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.  
  
카테고리 하나에 여러 개의 상품이 포함되는 (1:N) 도메인 모델을 만들어보자.    
먼저 테이블을 만든다면, 상품에 카테고리와 관계를 만들어주는 FK를 둬야 한다.      
  
데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각을 하게 된다. 즉, `SELECT ... JOIN ...` 실행을 통해 결과를 담는다.         
다음과 같은 형태로 만들어 서비스 계층에 넘겨주게 된다. 이렇게 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 존재하게 된다.      

```  
while(rs.next()) {
    Map<String, Object> resMap = new HashMap<>();
    resMap.put("categoryid", rs.getString(1));
    resMap.put("description", rs.getString(2));
    
    ...
    
    list.add(resMap);
}
```
 
<br />     

오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다.    

```
public class Category {
    int categoryid;
    Stirng description;
    Set<Product> products; // 0~N개의 product를 참조하는 컬렉션을 가질 수 있다.     
    
    // getter, setter
}

public class Product {
    int productid;
    String name;
    int price;
    Category category; // 1개의 category를 가리키는 레퍼런스를 직접 갖고 있다. 

    // getter, setter
}
```

자바 언어의 특성을 최대한 활용할 수 있다. -> 자바의 레퍼런스 개념은 상호 참조가 가능하게 만든다.      

   

이 방식에도 다음과 같은 단점은 있다.       
* 최적화된 SQL에 비해 성능면에서 조금의 손해    
* 모든 필드 값을 다 채워서 전달함     


이런 문제를 해결하는 접근 방법   
* Lazy loading : 오브젝트가 필요한 경우에 다이나믹하게 DB에서 읽어준다.        
* 가장 이상적인 방법은 JPA, JDO, 하이버네이트와 같은 ORM 기술을 사용하는 것이다.           
    + 지연 로딩 직접 만들지 않아도 된다.    
    + 복잡한 DAO 코드 만들지 않아도 된다.        
    + 자주 변경되지 않으면서 많은 로직에서 참조되는 레퍼런스 테이블을 캐시해줌으로써 성능 향상       
    + 결론 : 사용하기 쉽고 직관적이며 코드의 양이 대폭 줄어든다.             


그런데 도메인 오브젝트도 결국은 자바 오브젝트이다. 자바 오브젝트는 속성뿐만 아니라 행위에 대한 것도 가지고 있다.     
행위에 관한 코드를 작성하는 것도 적극 활용해야 된다고 생각한다.     
이를 활용한 것이 '풍성한 도메인 오브젝트 방식'이다.    


<br />   

#### 풍성한 도메인 오브젝트 방식           
풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다.     
어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다.        
이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.      

예를 들어, Category가 가지고 있는 전체 Product의 값을 필요로 하는 경우를 살펴보자.    
비즈니스 계층에 이 코드를 작성할 수도 있지만, Category 클래스 내부에 함수를 작성할 수도 있다.   
이런 경우 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.      

장점은 다음과 같다.             
- 재활용하기 좋다.                                
- 코드 중복이 발생하지 않는다. + 객체지향적이다.            

 
풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 보면 훨씬 간결하고 객체지향적이다.              
그러나 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있는 서비스 계층이 없어도 된다는 것은 아니다.        
도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다.          
비즈니스 로직을 처리하는 중에 DB나 외부 시스템에 전송하거나 데이터를 받는 작업이 필요하기 때문에 DAO 오브젝트를 DI 받아야 하는데   
도메인 오브젝트는 스프링 컨테이너가 관리하는 빈이 아니기 때문에 DAO 오브젝트를 DI 받을 수 없다.     

다음은 풍성한 도메인 오브젝트 방식의 아키텍처를 나타낸다.    
스프링의 빈으로 관리되는 3계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용할 수 있지만 그 반대는 안 된다는 사실을 주의해야 한다.         


![스크린샷 2021-01-11 오후 2 30 35](https://user-images.githubusercontent.com/33855307/104149470-9d01f980-5419-11eb-9abb-e91adc482796.png)      


<br />       

#### 도메인 계층 방식             
도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.       
그래서 등장한 것이 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.       
도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것이다.       

도메인 오브젝트가 독립된 계층을 가지면서 갖게된 특징      
- 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다.       
- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다.        
간단한 설정으로 데이터 액세스 계층이나 기반 계층을 DI받을 수 있다.          


스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다.     
스프링 AOP 대신 AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고   
스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.     

이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받게 할 수 있다.      
이 덕분에 도메인 오브젝트 기능의 제약이 사라진다.        

도메인 게층 방식은 이전의 어떤 방식보다도 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다.   
그럼에도 서비스 계층의 역할이 완전히 사라지는 것은 아니다. 그러나 비중과 규모는 훨씬 작아졌다.   

도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 사항이 있다.             
도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다.       
선택 방법은 다음과 같다.     

**- 여전히 모든 계층에서 도메인 오브젝트를 사용한다.**    
도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대로 누릴 수 있다.      
그러나 주의하지 않으면 오브젝트를 념겨받은 이상 그것을 사용하는 데 제약이 없기 때문에 함부로 조작하거나 기능을 실행해버릴 위험이 있다.           

이를 해결하는 방법은 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것이다.     
개발자가 이를 어길 수 있는데 이는 코딩 정책의 적용을 분석할 수 있는 툴을 이용해 검증하거나     
ApectJ의 정책/표준 강제화 기능을 사용하면 된다.     


**- 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다.**          
도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다.       
이런 오브젝트는 데이터 전달을 위해 사용된다고 DTO라고 불린다.    

DTO는 기능을 갖지 않으므로 사용하기 안전하다. 도메인 오브젝트를 외부 계층의 코드로부터 보호해준다.   
하지만 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 한다.   
따라서 AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다.     


다음은 도메인 계층 방식의 구조이다.     

![스크린샷 2021-01-11 오후 3 31 11](https://user-images.githubusercontent.com/33855307/104152126-0d147d80-5422-11eb-829a-e6e0778cb687.png)     


도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만 그 특성은 확연히 다르다.      
여러 가지 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 때다.   
복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고 도메인 모델과 설계에 변경이 발생했을 때   
도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다.     
반면 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식이 부담이 될 수도 있다.   

도메인 계층을 이용하는 방식을 선택할 때는 오브젝트 중심 아키텍처의 기본 두 가지 방법을 충분히 경험해보고   
오브젝트 중심의 개발 방식에 익숙해졌다면 조심스럽게 접근해야 한다.   


# 테스트

`main()` 메소드로 테스트를 구현했다면? 한계가 있다.

- 일정한 패턴으로 테스트
- 많은 테스트를 간단하게
- 테스트 결과를 종합해서 확인이 가능하게
- 실패한 곳을 빠르게 찾을 수 있게
- 위 목록에 만족하는 테스트 작성 방법, 테스트 지원 도구

위 목록에 만족하는 것이 바로 JUnit 이다. JUnit은 테스트 지원 도구로 다음 두 가지 조건을 만족해야 한다.

- 메소드가 public 이어야 한다.
- 메소드에 `@Test` 어노테이션을 붙여야 한다.


프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨 받아 주도적으로 애플리케이션의 흐름을 제어한다.

따라서 `main()` 메소드를 만들 필요가 없고 오브젝트를 만들어 실행시키는 코드를 만들지 않아도 된다.


<br />


### `@Before`
중복되는 코드를 `setUp()` 메소드를 만들어 구현하고

`@Before` 어노테이션을 붙여주면 `@Test` 메소드가 실행되기 전에 먼저 실행된다.


<br />


```
public class UserDaoTest {
    private UserDao userDao;

    @Before
    public void setUp() {
        ApplicationContext context =
            new GenericXmlApplicationContext("applicationContext.xml");
        this.userDao = context.getBean("userDao", UserDao.class);
    }

    . . .


}
```



중복되는 테스트 코드를 정리하면서 어느 정도 깔끔해졌다.

하지만 찜찜한 부분이 남아있는데, 애플리케이션 컨텍스트 생성 방식이다.


`@Before` 메소드가 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다.
애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.





<br />
<br />


### DI와 테스트

UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 뒀다.
UserDao는 DI를 통해 사용할 오브젝트를 외부에서 주이받기 때문에
자신이 사용하는 오브젝트 클래스가 무엇인지 알 필요가 없고 코드 수정없이 의존 오브젝트를 바꿔가며 사용할 수 없다.

"절대로 DataSource의 구현 클래스를 바꾸지 않는다."고 가정해보자.
그럼에도 불구하고 인터페이스를 두고 DI를 적용해야 할까?

DI를 적용해야 하는 이유는 다음과 같다.

1. 소프트웨어 개발에서 절대 바뀌지 않는 것은 없다.

2. 클래스의 구현 방식이 바뀌지 않는다고 해도 인터페이스를 두고
DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
(이런 기법을 일반화한 것이 AOP이다.)

3. 테스트를 위해서이다.
작은 단위의 대상에 대해 독립적으로 만들어지고
실행되게 하는데 중요한 역할을 한다.

<br />

### 정리

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- `main()` 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다.
코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안된다.
- 테스트는 포괄적이어야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.

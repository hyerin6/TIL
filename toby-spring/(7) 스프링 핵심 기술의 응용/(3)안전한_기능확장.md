# 인터페이스 상속을 통한 안전한 기능확장         

지금까지 만들었던 SqlService 구현 클래스들은 초기에 리소스로부터 SQL 정보를 읽어오면 이를 메모리에 두고 그대로 사용한다.       
SQL 매핑 정보 파일을 변경했다고해서 메모리상의 SQL 정보가 갱신되진 않는다.        
 
애플리케이션을 새로 시작하지 않고 특정 SQL의 내용만 변경하고 싶다면?      
SQL 정보의 실시간 변경이라는 기능을 추가하려면   
즉 기존에 설계하고 개발했던 기능이 발전돼야 할 경우에 스프링 답게 접근하는 방법은 무엇일까?    


<br />         

## DI와 기능의 확장      

스프링과 같은 DI 프레임워크를 적용했다고 빈 설정파일을 이용해 애플리케이션을 구성했다고 해서 DI를 바르게 활용하고 있다고 볼 수는 없다.     

<br />     

#### DI를 의식하는 설계      
초기부터 SqlService릐 내부 기능을 적절한 책임과 역할에 따라 분리하고, 인터페이스를 정의해 느근하게 연결해주고     
DI를 통해 유연하게 의존관계를 지정하도록 설계했기 때문에 그 뒤의 작업은 매우 쉬워졌다.      
유연하고 확장 가능한 좋은 오브젝트 설계와 DI 프로그래밍 모델은 서로 상승작용을 한다.       

DI는 런타임 시에 의존 오브젝트를 다이내믹하게 연결해줘서 유연한 확장을 꾀하는게 목적이기 때문에   
항상 확장을 염두에 두고 오브젝트 사이의 관계를 생각해야 한다.     

<br />     

#### DI와 인터페이스 프로그래밍        
DI를 적용할 때 가능한 한 인터페이스를 사용하게 해야 한다.         
인터페이스를 사용해야 하는 이유는 다음과 같다.     
 
1. 다형성을 얻기 위해서다.      
하나의 인터페이스를 통해 여러 개의 구현을 바꿔가면서 사용할 수 있게 하는 것이 DI가 추구하는 첫번째 목적이다.      

2. 인터페이스 분리 원칙을 통해 클라이언트와 의존 오브젝트 사이의 관게를 명확하게 해줄 수 있다.           
 
```   
A ---(사용)---> B1 (Object)

B1 ---(implements)---> B (interface)
B1 ---(implements)---> C (interface)  
```  

A가 B1을 사용(의존)하고 있는데 B1을 사용하더라도 B 인터페이스를 통해서만 사용한다.         
그런데 B1 오브젝트가 C 인터페이스를 구현할 수 있다.       
B1이 B와 C를 구현하고 있는 이유는 C라는 인터페이스가 그려주는 창으로 B1을 바라보는 다른 종류의 클라이언트가 존재하기 때문이다.        

즉 인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로 하나의 오브젝트를 바라보는 창이 여러 가지일 수 있다는 뜻이다.    
각기 다른 관심과 목적을 가지고 어떤 오브젝트에 외존하고 있을 수 있다는 의미이다.     

굳이 C라는 인터페이스에 정의된 내용에는 아무런 관심이 없는 A 오브젝트가      
C 인터페이스의 메소드까지 모두 노출되어 있는 B1이라는 클래스에 직접 의존할 이유가 없다.      
게다가 C 인터페이스의 메소드에 변화가 발생하면 A 오브젝트의 코드에 영향을 줄 수 있다.     
인터페이스를 이렇게 클라이언트의 종류에 따라 적절하게 분리해서 오브젝트가 구현하게 하면 매우 유용하다.     


오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도, 목적과 관심이 각기 다른 클라이언트가 있다면 인터페이스를 통해       
이를 적절히 분리해줄 필요가 있고 이를 객체지향 설계 원칙에서는 인터페이스 분리 원칙이라고 부른다.        
인터페이스를 사용하지 않고 클래스를 직접 참조하는 방식으로 DI를 했다면,         
인터페이스 분리 원칙과 같은 클라이언트에 특화된 의존관계를 만들어낼 방법 자체가 없다.        


<br />        


## 인터페이스 상속       
하나의 오브젝트가 구현하는 인터페이스를 여러 개 만들어서 구분하는 이유 중의 하나는   
오브젝트의 가능이 발전하는 과정에서 다른 종류의 클라이언트가 등장하기 때문이다.   

인터페이스 분리 원칙이 주는 장점은 모든 클라이언트가 자신의 관심에 따른 접근 방식을 불필요한 간섭 없이 유지할 수 있다는 점이다.      
-> 기존 클라이언트에 영향을 주지 않은 채로 오브젝트의 기능을 확장, 수정할 수 있다.   

```
                    <<interface>>
                      SqlReader
                ↗
BaseSqlService 
                ↘
                    <<interface>>
                     SqlRegistry
                          ↑
                    MySqlRegistry 
```

MySqlRegistry는 BaseSqlService에 영향을 주지 않으면서 독자적으로 확장될 수 있다.     

인터페이스를 사용해 DI 관계를 만들었기 때문에 얻을 수 있는 또 다른 장점은 SqlRegistry의 구현 클래스인      
MySqlRegistry의 오브젝트가 또 다른 제 3읰 클라이언트를 위한 인터페이스를 가질 수 있다는 점이다.         

새로운 클라이언트를 위해 새로운 인터페이스가 필요하지만 꼭 SqlRegistry와 별개의 인터페이스를 만들어야 하는 것은 아니다.        
기존 SqlRegistry를 확장한 인터페이스를 이용할 수도 있다.        

그러나 이 예제에서 클라이언트인 BaseSqlService 클래스와 그 서브클래스가 존재하기 때문에 
SqlRegistry 인터페이스 자체를 수정하는 건 바람직한 방법은 아니다.    
새롭게 추가할 기능을 사용하는 클라이언트를 위해 새로운 인터페이스를 정의하거나 기존 인터페이스를 확장하는 게 바람직하다.     

기존의 SqlRegistry 인터페이스를 상속하고 메소드를 추가해서 새로운 인터페이스로 정의돼야 한다.     

```  
public interface updatableSqlRegistry extends SqlRegistry {
    ...
}
```  


이렇게 SQL 업데이트 기능을 가진 새로운 인터페이스를 만들었으니 BaseSqlService도 새로 만든 updatableSqlRegistry 인터페이스를 이용하게 해야 할까?   
그렇지 않다. BaseSqlService는 초기화를 통한 SQL 등록과 조회만을 목적으로 SQL 레지스트리 오브젝트를 사용할 것이므로,   
기존의 SqlRegistry 인터페이스를 통해 접근하면 충분하다.     

반면 SQL 업데이트 작업이 필요한 새로운 클라이언트 오브젝트는 updatableSqlRegistry 인터페이스를 통해 SQL 레지스트리 오브젝트에 접근하도록 만들어야 한다.       

![스크린샷 2021-01-04 오후 2 15 30](https://user-images.githubusercontent.com/33855307/103503373-62d3ad80-4e97-11eb-84ca-2485d33e4631.png)      

실제 오브젝트 사이에 일어나는 DI의 결과만 보면 BaseSqlService와 SqlAdminService 오브젝트는        
동일한 MyUpdatableSqlRegistry 오브젝트를 DI 받아서 사용한다.               

중요한 것은 클라이언트가 정말 필요한 기능을 가진 인터페이스를 통해 오브젝트에 접근하도록 만들었는가이다.   
잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려 있다.   



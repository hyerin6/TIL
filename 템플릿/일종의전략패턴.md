# 템플릿      

확장에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙인 개방 폐쇄 원칙(OCP)을 다시 한번 생각해보자. 변화의 특성이 다른 부분을 구분해주고, 각각 다른 목적과 다른 이유로 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 바로 이 개방 폐쇄 원칙이다.   

템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법이다.   

스프링에 적용된 템플릿 기법을 살펴보고 이를 적용해 완성도 있는 DAO 코드를 만들어보자.   

<br />          

# 다시 보는 DAO      

### 예외처리 기능을 갖춘 DAO         

DB 연결과 관련된 여러 가지 개선 작업은 완료했지만 다른 면에서 심각한 문제가 있다. 바로 예외상황에 대한 처리다.    
정상적인 JDBC 코드의 흐름을 따르지 않고 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 하기 때문이다.   



**JDBC 수정 기능의 예외처리 코드**    


```  
try {
	
	// JDBC Connection Code   
	
} catch(SQLException e) {
	throw e;
} finally {
	if(rs != null) {
		try {
			rs.close();
		} catch(. . .) {
		}
	}
}
  
```  



### JDBC try/catch/finally 코드 문제점   
복잡한 try/catch/finally 블록이 2중으로 중첩되고 모든 메소드에서 반복된다.      




### 분리와 재사용을 위한 디자인 패턴 응용       

**메소드 추출**    
먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다.     
자주 바뀌는 부분을(JDBC Connection Code) 메소드로 독립시켰는데 재사용할 수 없고,     
분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 하는 부분이기 때문에 뭔가 반대로 됐다.     


**템플릿 메소드 패턴의 적용**  
템플릿 메소드 패턴은 상속을 통해 기능을 확장해서 사용하는 것이다.   
변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것이다.   
하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다.     

예를들어 JDBC 메소드가 4개인 경우 4개의 서브클래스를 만들어서 사용해야 한다.         
또한 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 서브클래스들이 이미 클래스 레벨에서 컴파일 시점에서 이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다.       
상속을 통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.      

 
**전략 패턴의 적용**      
개방 폐쇄 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것이, 오브젝트를 아예 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴이다.   
전략 패턴은 OCP 관점에 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다. 

하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서(OCP의 폐쇄 원칙) 전략을 바꿔쓸 수 있다는 것인데,   

```  
deleteAll() {
	try {
		StatementStrategy s = new DeleteAllStatement();
		. . .     
	} catch() {
	}
}
```  

이렇게 컨텍스트 안에서 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있는게 이상하다.   
컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고있다는건, 전략패턴에서도 OCP에도 잘 들어맞는다고 볼 수 없다.           


**DI 적용을 위한 클라이언트/컨텍스트 분리**     
전략패터의 실제적인 사용방법을 좀 더 알아보자.   
전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인지를 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다.   
Client가 구체적인 전략 하나를 선택 -> 오브젝트 생성 -> Context에 전달   

결국 이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 바로 ObjectFactory이며, 이를 일반화한 것이 앞에서 살펴봤던 의존관계 주입(DI)이었다.     
DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조라고 볼 수 있다.    

예제에 DI를 적용해보자.   

- 적용 전   

```  
StatementStrategy s = new DeleteAllStatement();   
```

- 적용 후    
 
```
jdbcContextStatementStrategy(StatementStrategy stmt) {
	Connection c = null;
	PreparedStatement ps = null;
	
	try {	
		c = dataSource.getConnection();
		ps = stmt.makePreparedStatement(c);  
	}

	. . . 

}
```  

전략 인터페이스인 StatementStrategy를 컨텍스트 메소드 파라미터로 지정하면 된다.     

<br />          


# JDBC 전략 패턴의 최적화    

### 전략과 클라이언트의 동거    
좀 더 개선할 점을 찾아보자.    

(1) DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점     
(2) DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다.       

위 두 문제를 해결해보자.   


- 로컬 클래스   

클래스 파일이 많아지는 문제는 StatementStrategy 전략 클래스를 매번 독립적인 파일로 만들지 않고 UserDao 클래스 안에 내부 클래스로 정의하는 것으로 해결할 수 있다.     
UserDao에서만 사용되고 UserDao의 메소드 로직에서 강하게 결합되어 있기 때문이다.      

```  
public void add(final User user) { // User 오브젝트를 AddStatement의 메소드에서 사용 가능   
	class AddStatement implements StatementStrategy {
		. . .
	}  
}  
```  

특정 메소드에서만 사용되는 것이라면 위 코드처럼 로컬 클래스로 만들 수 있다.    

로컬 클래스를 사용함으로써 클래스 파일이 하나 죽었고, 생성 로직을 함께 볼 수 있으니 코드를 이해하기도 좋다.    
또 로컬 클래스는 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 장점이 있다.     
필요한 오브젝트가 있으면 생성자를 통해 전달했었는데 내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문에 번거로움이 없어졌다.      
다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해야 한다.          
 


- 익명 내부 클래스    

```  
new 인터페이스이름() { 클래스 본문 };
```   

익명 내부 클래스는 선언과 동시에 오브젝트를 생성한다. 이름이 없기 때문에 클래스 자신의 타입을 가질 수 없고, 구현한 인터페이스 타입의 변수에만 저장할 수 있다.    
만들어진 익명 내부 클래스의 오브젝트는 딱 한 번만 사용할 테니 굳이 변수에 담아 두지 말고 필요한 곳에서 바로 생성하는 편이 낫다.   

<br />          


# 컨텍스트와 DI    

### jdbcContext의 분리    
전략 패턴의 구조로 보자면 UserDao의 메소드가 클라이언트고, 익명 내부 클래스로 만들어지는 것이 개별적인 전략이고, jdbcContextWithStatementStrategy() 메소드는 컨텍스트이다.     
컨텍스트 메소드는 UserDao 내의 PreparedStatement를 실행하는 기능을 가진 메소드에서 공유할 수 있다.   

그런데 JDBC의 일반적인 작업 흐름을 담고 있는 jdbcContextWithStatementStrategy()는 다른 DAO에서도 사용 가능하다.     
그러니 UserDao 클래스 밖으로 독립시켜서 모든 DAO가 사용할 수 있게 해보자.     


**클래스 분리**    
JdbcContext라는 클래스를 만들고 UserDao에 있는 컨텍스트 메소드를 옮겨 놓는다.        
이렇게 하면 DataSource가 필요한 것은 UserDao가 아니라 JdbcContext이다. DB 커넥션을 필요로 하는 코드는 JdbcContext 안에 있기 때문이다.            
따라서 JdbcContext가 DataSource에 의존하고 있으므로 DataSource 타입 빈을 DI 받을 수 있게 해줘야 한다.     


**빈 의존관계 변경**  
UserDao는 이제 JdbcContext에 의존하고 있다. 그런데 JdbcContext는 인터페이스인 DataSource와 달리 구체 클래스다.   
스프링 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는게 목적이다.   
하지만 이 경우는 그 자체로 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있고 구현 방법이 바뀔 가능성은 없다.   
그래서 UserDao와 JdbcContext는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가 된다.   

스프링 빈 설정은 클래스 레벨이 아니라 런타임 시에 만들어지는 오브젝트 레벨의 의존 관계에 따라 정의된다.   
기존에는 UserDao가 DataSource 빈을 직접 의존했지만, 이제는 JdbcContext 빈이 그 사이에 끼게 된다.    



### JdbcContext의 특별한 DI    

UserDao와 JdbcContext 사이에는 인터페이스를 사용하지 않고 DI를 적용했다.   
그래서 UserDao와 JdbcContext는 클래스 레벨에서 의존관계가 결정된다.     
DI를 적용했지만 의존 오브젝트의 구현 클래스를 변경할 수는 없다.   


**스프링 빈으로 DI**   
인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있을까?      
꼭 인터페이스를 만들지 않아도 된다.   
의존관계 주입(DI)이라는 개념을 충실히 따르자면 인터페이스를 사이에 둬서 클래스 레벨에서는 의존관계가 고정되지 않게 하고 런타임 시에 의존할 오브젝트와의 관계를 다이내믹하게 주입해주는 것이 맞다.     
따라서 인터페이스를 사용하지 않았다면 엄밀히 말하면 온전한 DI라고 볼 수는 없다.      
그러나 스프링의 DI는 넓게 보자면 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념을 포괄한다. 그런 의미에서 JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하게 주입했다는건 DI의 기본을 따르고 있다고 볼 수 있다.    
인ㅌ퍼ㅔ이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않지만, JdbcContext를 UserDao와 DI구조로 만들어야 하는 이유를 알아보자.   

(1) JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문이다.   
JdbcContext가 그 자체로 변경되는 상태정보를 갖고 있지 않고 JDBC 컨텍스트 메소드를 제공해주는 일종의 서비스 오브젝트로서 의미가 있기 때문에 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적이다.    

(2) 가장 중요한 이유는 JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문이다.          
JdbcContext는 dataSource 프로퍼티를 통해 DataSource 오브젝트를 주입받게 되어있다.    
DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼야 한다.      
스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문이다.     



중요한 것은 인터페이스의 사용 여부다.    
인터페이스가 없다는건 UserDao와 JdbcContext가 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미이다. UserDao는 항상 JdbcContext 클래스와 함께 사용돼야 한다.   
클래스는 구분되어 있지만 이 둘은 강한 응집도를 갖고있다.   
UserDao가 JDBC 방식 대신 JPA나 하이버네이트같은 ORM을 사용해야 한다면 JdbcContext도 통째로 바꿔야 한다.   
이런 경우는 굳이 인터페이스를 두지 말고 강력한 결함을 가진 관계를 허용하면서 위에 말하는 두 가지 이유인 싱글톤으로 만드는 것과 JdbcContext에 대한 DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao에 DI 되도록 만들어도 좋다.   
단, 이런 클래스를 바로 사용하는 코드 구성을 DI에 적용하는 것은 가장 마지막 단계에서 고려해볼 사항임을 잊지 말자.   



**코드를 이용하는 수동 DI**     
스프링 빈으로 등록해서 UserDao에 DI하는 대신 사용할 수 있는 방법이 있다. UserDao 내부에서 직접 DI를 적용하는 방법이다.      
이 방법을 쓰려면 JdbcContext를 스프링의 빈으로 등록해서 사용했던 첫번째 이유인 싱글톤으로 만드려는 것은 포기해야 한다.   
그렇다고 해서 DAO 메소드가 호출될 때마다 JdbcContext 오브젝트를 새로 만들어야 한다는건 아니다.   
DAO마다 하나의 JdbcContext 오브젝트를 갖고 있게 하는 것은 가능하다.     

JdbcContext를 스프링 빈으로 등록하지 않았으므로 다른 누군가가 jdbcContext의 생성과 초기화를 책임져야 한다.   
제어권은 UserDao가 갖는 것이 적당하다.       

남은 문제는 JdbcContext를 스프링 빈으로 등록해서 사용했던 두 번째 이유이다.    
JdbcContext는 다른 빈을 인터페이스를 통해 간접적으로 의존하고 있다. JdbcContext는 DataSource 타입 빈을 다이내믹하게 주입 받아서 사용해야 한다. 그렇지 않으면 DataSource 구현 클래스를 자유롭게 바꿔가면서 적용할 수 없다.   

이런 경우 사용할 수 있는 방법이 한 가지 있다.   
JdbcContext에 대한 제어권을 갖고 생성과 관리를 담당하는 UserDao에게 DI까지 맡기는 것이다.   
UserDao가 임시로 DI 컨테이너처럼 동작하게 만들면 된다.   
JdbcContext에 주입해줄 의존 오브젝트인 DataSource는 UserDao가 대신 DI 받도록 하는 것이다.   
UserDao는 주입받은 DataSource 빈을 JdbcContext를 만들고 초기화하는 과정에만 사용하고 버리면 되고    
스프링 설정 파일에서는 userDao와 dataSource 두 개만 빈으로 등록한다.   


이 방법의 장점은 굳이 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 갖고 있는 DAO 클래스와 JdbcContext를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서 다른 오브젝트에 대한 DI도 적용할 수 있다는 점이다.     


인터페이스를 사용하지 않는 클래스와의 의존관계이지만 스프링의 DI를 이용하기 위해 빈으로 등록해서 사용하는 방법은 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다는 장점이 있는 반면에 DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 노출된다는 단점이 있다.   

DAO의 코드를 이용해 수동으로 DI를 하는 방법은 JdbcContext가 UserDao의 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있지만 JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI 작업을 위한 부가적인 코드가 필요하다는 단점도 있다.   

어떤 방법이 낫다고 할 수 없고 상황에 따라 적절한 방법을 선택해서 사용하면 된다.   






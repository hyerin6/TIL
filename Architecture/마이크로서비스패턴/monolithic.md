# Monolithic  

## FTGO 애플리케이션 아키텍처  

**FTGO**      
FTGO는 미국 온라인 배달 서비스이다.    
전형적인 엔터프라이즈 자바 애플리케이션인 FTGO의 전체 구조는 코어가 비즈니스 로직으로 구성된 육각형 아키텍처(hexagonal architecture)이다.    

<img width="1000" src="https://user-images.githubusercontent.com/33855307/153741113-bf2e1317-036f-4b50-b456-474696d2d6f8.jpeg">


비즈니스 로직은 각자가 도메인 객체 컬렉션인 모듈로 구성되며, 외부 시스템과 연계하는 어댑터가 여럿 달려 있다.   
REST API, 웹 UI 어댑터 등 비즈니스 요청을 호출하여 처리하는 인바운드 어댑터가 있고,     
그 밖에 비즈니스 로직에서 MySQL DB에 접속하거나 클라우드 서비스를 호출하게 해주는 아웃바운드 어댑터가 있다.   

논리적으로는 모듈화한 아키텍처임에도 애플리케이션은 WAR 파일 하나로 패키징한다.   

<br />

### 모놀리식 아키텍처의 장점   
비교적 규모가 작았던 초기에는 모놀리식 아키텍처가 장점이 많았다.   

* 개발이 간단하다.                         
  IDE 등 개발 툴은 단일 애플리케이션 구축에 초점이 맞춰져있음.     

* 애플리케이션을 쉽게 변경할 수 있다.
  코드, DB 스키마를 변경해서 빌드/배포하기 용이하다.  

* 테스트하기 쉽다.

* 배포하기 쉽다.    
  개발자는 서버에 접속하여 톰캣 설치 경로에 WAR 파일을 복사하면 된다.    

* 확장하기 쉽다.          
  부하분산기(로드밸런싱) 뒷면에 애플리케이션 인스턴스를 여러 개 실행       

<br />

## 모놀리식 아키텍처의 한계     
규모가 커지면서 팀별로 기능 분야가 특화된 스크럼 팀이 여럿이고 구현할 스토리가 늘어나 애자일식 개발/배포가 불가능해진다.    

* 너무 복잡해진다.  

* 개발이 더디다.   
  애플리케이션이 너무 커져서 개발자 IDE의 실행 속도도 느려지고 빌드/실행 후 테스트하기까지 너무 많은 시간이 낭비되어 생산성이 떨어진다.    

* 확장하기 어렵다.  
 
* 모놀리스는 확실하게 전달하기 어렵다.    

* 기술 스택에 발목이 잡힌다.   


<img width="1000" src="https://user-images.githubusercontent.com/33855307/153742596-135707b1-6bd5-4791-985e-2906a524a5da.jpeg">


복잡도는 하위로 내려갈수록 더 심화된다.   
코드베이스가 너무 복잡해 변경 영향도가 제대로 파악이 안되므로 개발자는 CI 서버에서 전체 테스트 스위트를 한 번씩 돌려 봐야 한다.    
테스트 실패 시 원인을 찾고 조치하는 데 시간이 많이 걸린다.   

신뢰성이 부족한 것도 문제다. 테스트가하기 어렵고 테스트성이 부족하면 결국 프로덕션에 버그가 발생할 가능성도 높다.   
전체 모듈이 같은 프로세스로 실행되어 결함 격리가 되지 않고, 어떤 모듈에 버그 하나만 있어도 메모리 누수가 발생해 전체 애플리케이션 인스턴스가 내려가는 일도 발생한다.   

새로운 언어나 기술을 사용하고자 애플리케이션 전체를 재작성하는 것은 비용과 리스크가 높기 때문에 점점 한물간 기술 스택을 쓸 수밖에 없다.   

<br />

## 마이크로서비스 아키텍처   
소프트웨어 아키텍처는 기능 요건과는 무관하다. 즉 유스케이스는 어느 아키텍처든 구현할 수 있다.     
그러나 아키텍처는 서비스 품질 요건에 영향을 미친다.

* 관리성
* 확장성 
* 테스트성 

위 속성들이 가장 큰 영향을 받는다.  
<br />  

#### 확장 큐브와 마이크로서비스 
<img src="https://thebook.io/img/007035/038_1.jpg">

이 모델에 따르면 애플리케이션을 X, Y, Z 세 방향으로 확장시킬 수 있다.    

<br />

#### X축 확장: 다중 인스턴스에 고루 요청 분산 
X축 확장은 일반적인 모놀리식 애플리케이션의 확장 수단이다. 
부하분산기 뒷면에 애플리케이션 인스턴스를 N개 띄워 놓고 요청을 인스턴스에 고루 분배한다.    

<br />

#### Z축 확장성: 요청 속성별 라우팅 
다중 인스턴스를 실행하는 것은 X축 확장과 같지만 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법이다.         
인스턴스 앞면에 위치한 라우터는 요청의 속성에 알맞은 인스턴스로 요청을 라우팅한다.          
예) userId에 따라 요청을 분산          

<img src="https://thebook.io/img/007035/039.jpg">

각 애플리케이션이 자신에게 배정된 사용자 하위 집합만 처리   
Z축 확장은 애플리케이션을 확장해서 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단이다.   

<br />

#### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해   
X축/Z축 확장을 하면 애프리케이션 능력과 가용성은 개선되지만, 애플리케이션이 점점 복잡해지는 문제는 해결되지 않는다.   
따라서 기능 분해가 필요하다.   

<img src="https://thebook.io/img/007035/040.jpg">

마이크로서비스 아키텍처는 고수준에서 바라보면 하나의 애플리케이션을 여러 서비스로 기능 분해하는 아키텍처 스타일이다.   
중요한 것은 크기가 아니라 각 서비스가 집중된/응집된 책임을 맡고 있다는 것이다.   

<br />

## 마이크로서비스는 모듈성을 갖고 있다.  
모놀리식 애플리케이션 프로그래밍 언어 구성체(ex. java package)와 빌드 아티팩트(ex. jar)를 조합한 단위로 모듈을 정의하지만   
실제로 이런 접근 방식은 문제가 많아 진흙탕이 되기 쉽다.   

마이크로서비스 아키텍처는 서비스를 모듈성의 단위로 사용한다.   
각 서비스는 다른 서비스가 함부로 규칙을 어기고 침투하지 못하게 API라는 경계선을 갖고 있어서 다른 서비스 API를 우회하여 그 내부 클래스에 마음대로 들어올 수 없다.   
따라서 애플리케이션 모듈성을 유지하기 쉽고 서비스를 독립적으로 배포/확장할 수 있다.  

<br />

## 서비스마다 DB가 따로 있다. 
예를들어 주문 서비스는 ORDERS 테이블이 있는 DB, 고객 서비스는 CUSTOMERS 테이블이 있는 DB를 각자 소유한다.   
헌타임에 서비스는 서로 완전히 분리되어 있기 때문에 다른 서비스가 DB 락을 획득해 내 서비스를 블로킹하는 일이 일어나지 않는다.   

<br />

## FTGO 마이크로서비스 아키텍처
FTGO 애플리케이션을 마이크로서비스 아키텍처로 전환해보자.   

먼저 Y축 확장을 적용해보자.   
아래 그림에서 X/Z축 확장을 하면 서비스마다 인스턴스가 여러개 존재할 것이다.   

<img src="https://thebook.io/img/007035/042.jpg">

서비스와 API가 분명하게 정의되어 각 서비스가 독립적으로 개발, 테스트, 배포, 확장이 가능하다.   
개발자가 타 서비스의 API를 우회하거나 그 내부 요소에 직접 접근할 수 없기 때문에 모듈성 유지 차원에서도 적합하다.   

<br />

## 마이크로서비스 아키텍처와 SOA  
`마이크로서비스 아키텍처는 SOA(Service Oriented Architecture)와 별반 다를 것이 없다.` 라고들 한다.   
고수준에서 바라보면 두 아키텍처 모두 시스템을 여러 서비스로 구성하는 아키텍처 스타일이다.   
그러나 근본적인 차이점이 있다.   

<img src="https://user-images.githubusercontent.com/33855307/153744359-5c6488d1-4ae8-4cc6-9f2b-38f69f5948d9.png">

<br />

## 마이크로서비스 아키텍처의 장점
#### 크고 복잡한 애플리케이션을 지속적으로 전달/배포할 수 있다.  
다음 세 가지 방법으로 지속적 전달/배포를 실현한다.     

* 테스트성     
  상대적으로 크기가 작아서 자동화 테스트를 작성하기 쉽고 더 빨리 실행되며, 애플리케이션 버그도 적은 편이다.       


* 배포성        
  독립적으로 배포할 수 있어서 자신이 담당한 서비스 변경분을 배포할 때 다른 개발자와 협의할 필요가 없다.         


* 자율성, 느슨한 결합      
  작은 팀이 여럿 결합된 기술 조직을 꾸려 갈 수 있다.     
  다른 팀과 독립적으로 개발, 배포, 확장이 가능하므로 개발 속도는 더 빨라진다.     


지속적인 전달/배포는 비즈니스 측면에서도 이점이 있다.    
* 런칭 시기를 앞당길 수 있고 고객의 피드백을 신속히 대응할 수 있다.   
* 현재 고객들이 기대하는 수준으로 확실하게 서비스를 제공할 수 있다.   
* 제품의 가치를 전달하는 데 더 많은 시간을 투자할 수 있어 만족도가 높다.  

<br />

#### 서비스가 작아 관리하기 용이하다. 
비교적 크기가 작아서 개발자가 코드를 이해하기 쉽다.    
코드베이스가 작으면 IDE도 느려지지 않아 개발 생산성도 올라간다.   

<br />

#### 서비스를 독립적으로 배포/확장할 수 있다. 
독립적으로 X축(복제)/Z축(파티셔닝) 확장을 할 수 있고 서비스마다 상이한 리소스 요건에 맞춰 하드웨어에 배포할 수 있다.   
리소스 요건이 전혀 다른 예: CPU 집약적 vs 메모리 집약적    

<br />

#### 결함 격리가 잘된다.   
<br />   

#### 신기술을 시험/도입하기 쉽다. 

<br />

## 마이크로서비스 아키텍처의 단점 
마이크로서비스 아키텍처도 많은 단점과 이슈가 있다.   

<br />

#### 딱 맞는 서비스를 찾기 쉽지 않다.   
마이크로서비스 아키텍처에 맞게 시스템을 여러 서비스로 분해하는 구체적으로 정립된 알고리즘은 따로 없다.  
만약 시스템을 잘못 분해하는 경우, 단점만 가득한 분산 모놀리스가 된다.   

<br />

#### 분산시스템은 복잡하다.   
분산 시스템이라는 또 다른 복잡성은 개발자가 감당해야 한다.     

특히 서비스마다 DB가 따로 있기 때문에 다중 DB에 접속하고 트랜잭션을 구현하는 일이 어렵다.     
* 사가 기술로 서비스 간 데이터 일관성 유지       
* 단순 쿼릴로 여러 서비스 데이터를 조회할 수 없어 API를 조합하거나 CQRS 뷰로 쿼리    


종류가 다른 서비스가 여러 인스턴스가 떠 있기 때문에 운영 복잡도 역시 가중된다.      


<br />

#### 여러 서비스에 걸친 공통 기능은 배포할 때 잘 살펴야 한다.

<br />

#### 도입 시기를 결정하기 어렵다. 
애플리케이션 수명 주기 중 어느 시점에 마이크로서비스 아키텍처를 도입할지 결정하는 것도 어렵다.   
초기 개발부터 정교한 분산 아키텍처를 사용하면 개발 속도가 더디고 신속하게 interation(반복)하기도 어렵다.   

<br />

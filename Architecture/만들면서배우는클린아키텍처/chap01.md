# 계층형 아키텍처의 문제

<img width="300" src="https://user-images.githubusercontent.com/33855307/152487080-a3f90a7a-774d-4d0f-b580-d7f1c625f667.jpeg"/>

계층형 아키텍처는 견고한 아키텍처 패턴이고, 잘 이해하고 구성하면 독립적인 도메인 로직을 작성할 수 있다.
웹 계층, 영속성 계층도 마찬가지로 기존 기능에 영향을 주지 않고 기술을 변경할 수 있다.

그렇다면 문제점은?
계층형 아키텍처는 코드에 나쁜 습관들이 스며들기 쉽고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 허점들을 노출한다.

<br />

### 1) 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.

정의에 따르면 계층형 아키텍처의 토대는 데이터베이스다.

```text
웹 → 도메인 → 영속성 → 데이터베이스
```

자연스레 **데이터베이스에 의존**하게 된다.
모든 것이 영속성 계층을 토대로 만들어지기 때문에 이런 방식은 다양한 이유로 문제를 초래한다.

애플리케이션의 목적은 비즈니스 규칙이나 정책을 반영한 모델을 만들어 사용자가 더욱 편리하게 활용하기 위함이다.

우리는 상태가 아니라 **행동을 중심으로 모델링**하는데
행동이 상태를 바꾸는 주체이기 때문에 행동이 비즈니스를 이끌어간다.

그렇다면 왜 도메인 로직이 아닌 데이터베이스를 토대로 아키텍처를 만들었을까?
유스케이스를 만들 때 디비 구조를 먼저 생각하고 이를 토대로 도메인 로직을 구현했다면,
전통적인 계층형 아키텍처에서는 합리적인 방법이었다. (의존성 방향에 따라 구현)
하지만 비즈니스 관점에서는 전혀 맞지 않는 방법이다.
도메인 로직을 먼저 만들어야 한다.

**데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문이다.**
`<br />`

<img width="500" src="https://user-images.githubusercontent.com/33855307/152488553-6f0b2e7e-0d30-4007-b6b0-75d2bd17be4d.jpeg">

**도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다.**

ORM에 의해 관리되는 엔티티들은 일반적으로 영속성 계층에 둔다.
계층은 아래 방향으로만 접근 가능하기 때문에 도메인 계층에서 엔티티에 접근할 수 있다.

서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 되고 도메인 로직뿐만 아니라
즉시로딩/지연로딩, 데이터베이스 트랜잭션, 캐시 플러시 등 영속성 계층과 관련된 작업들을 해야만 한다.

영속성 코드가 도메인 코드에 녹아들어가 둘 중 하나만 바꾸는 것이 어려워진다.
이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 반대되는 상황이다.

<br />

### 2) 지름길을 택하기 쉬워진다.

전통적인 계층형 아키텍처에서전체적으로 적용되는 유일한 규칙
→ 특정한 계층에서 같은 계층에 있는 컴포넌트나 아래에 있는 계층에만 접근이 가능하다.

만약 상위 계층에 접근해야 한다면? 해당 컴포넌트를 아래로 내리면 된다.
한 두번은 괜찮아 보이지만 이러한 방식으로 수년에 걸친 개발과 유지보수로 영속성 계층은 다음과 같아질 확률이 높다.

<img width="500" src="https://user-images.githubusercontent.com/33855307/152538664-3d4ba7aa-69a8-48b7-adcd-fdbe97e36b1b.jpeg">

영속성 계층(최하단 계층)에서 모든 것에 접근이 가능하기 때문에 시간이 지나면서 점점 비대해진다.

<br />

### 3) 테스트하기 어려워진다.

계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너뛰는 것이다.
엔티티의 필드 하나만 조작하면 되는 경우 웹 계층에서 바로 영속성 계층에 접근하면 도메인 계층을 건드릴 필요가 없지 않을까?

<img width="500" src="https://user-images.githubusercontent.com/33855307/152539064-343ae7d0-2925-491a-807e-316a6fb245f9.jpeg">

도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다.

처음 몇 번은 괜찮아 보이지만 이런 일이 자주 일어나면 두 가지 문제점이 발생한다.

<br />

### 문제점 1. 단 하나의 필드를 조작하는 것에 불과하더라도 도메인 로직을 웹 계층에 구현하게 된다.

유스케이스가 확정된다면 애플리케이셔 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼져나갈 확률이 높다.

<br />

### 문제점 2. 웹 계층 테스트에서 도메인 계층뿐만 아니라 영속성 계층도 Mocking 해야 한다.

단위 테스트의 복잡도가 올라간다.
웹 컴포넌트의 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이면서 테스트의 복잡도가 높아진다.

<br />

### 3) 유스케이스를 숨긴다.

기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는 데 도움이 돼야 한다.

유스케이스가 '간단'해서 도메인 계층을 생략한다면? 웹, 도메인, 영속성 계층 모두에 접근할 수 있도록 아래로 내렸다면?
영속성 계층에 존재할 수도 있다. 이 경우 기능을 추가할 적당한 위치를 찾는 일은 어렵다.
심지어 계층형 아키텍처는 도메인 서비스의 '너비'에 관한 규칙을 강제하지 않기 때문에
시간이 지나면 여러 개의 유스케이스를 담당하는 넓은 서비스가 만들어 지기도 한다.

넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다.
→ 테스트가 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.

<br />

### 4) 동시작업이 어려워진다.

애플리케이션에 새로운 유스케이스를 추가한다고 상상해보자.  
개발자는 3명이 있다. 한 명은 웹 계층, 한 명은 도메인, 한 명은 영속성 계층, 이렇게 할 수 있을까?  
계층형 아키텍처에서는 이렇게 작업할 수가 없다.  
모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 하고, 도메인, 웹 순서로 만들어야 한다.  

개발자들이 인터페이스를 먼저 같이 정의하고 각 개발자들이 실제 구현을 기다릴 필요없이 이 인터페이스들로 작업하면  
가능하겠지만 이는 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다.   


코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다.  
서로 다른 유스케이스에 대한 작업을 하게 되면 같은 서비스를 동시에 편집하는 상황이 발생하고,   
이는 병합 충돌과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기한다.  

<br />

# 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수하기 쉽고 코드를 쉽게 변경하거나 추가할 수 있게 된다.   


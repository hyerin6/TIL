# 1. 네트워크

자바 네트워크 프로그램을 작성하기 위해 필요한 네트워크 배경 지식을 학습하자.

<br />

## 1) Network

네트워크는 서로 데이터를 주고 받을 수 있는 컴퓨터 및 장치들의 집합이다.

<br />

**노드(node)**
네트워크 안의 각각의 장비를 노드(node)라고 부른다.

> 노드의 예
>
> 컴퓨터
>
> 네트워크에 직접 연결된 프린터
>
> 라우터 (router)
>
> 브리지 (bridge)
>
> 게이트웨이 (gateway)
>
> 참고: 라우터, 브리지, 게이트웨이는 네트워크에서 데이터 전달을 담당하는 장비이다.
>
> 네트워크 이론 수업에서 이 장비들에 대해 배울 수 있다.

<br />

**호스트(host)**

노드 중에서 일반적인 컴퓨터를 호스트라고 한다.

<br />

<br />

## 2) 네트워크 주소 (Network address)

모든 네트워크 노드는 네트워크 주소를 가지고 있다.

네트워크 주소는 바이트 목록(byte[]) 이다.

네트워크 주소는 네트워크 노드를 고유하게 식별한다.

➡️어떤 장비를 가리키는지 정확하게 알고 있다는 뜻이다.

<br />

네트워크 주소를 저장하기에 적당한 Java의 기본 숫자 타입은 없다.

예를 들어 4바이트 인터넷 주소를 Java int 타입 변수에 저장할 수 없고,

byte[] 배열에 저장해야 한다.

<br />

> 참고
>
> Java의 int의 바이트 수는 4 바이트, 바이트 순서는 big-endian 이다.

<br />

![n1](https://user-images.githubusercontent.com/33855307/134761806-8f463282-1aba-4eda-8ba9-5b7320b93671.jpeg)
![n2](https://user-images.githubusercontent.com/33855307/134761810-ff279e6c-39bd-4d07-9d41-0c8248fcb428.jpeg)

<br />
<br />

**Ethernet 주소**

Ethernet은 네트워크 종류 중 하나이다.

Ethernet에서 주소는 MAX 주소이다.

Ethernet 주소 즉 MAC 주소는 Ethernet 하드웨어에 부여된다.

<br />

Ethernet 하드웨어 제조사가 Ethernet 하드웨어를 만들 때 MAC 주소를 부여한다.

각 제조사는 동일한 MAC 주소를 갖는 Ethernet 하드웨어가 생산되지 않게 할 책임이 있다.

따라서 각각의 MAC 주소는 지구상에서 유일하다.

<br />

**인터넷 주소**

인터넷에서 주소는 IP 주소이다.

일반적으로 IP 주소는 컴퓨터를 책임지는 조직에서 컴퓨터에 할당한다.

(ex. 성공회대가 책임지는 컴퓨터의 인터넷 주소는 성공회대가 할당한다. )

<br />

조직은 그들의 컴퓨터에 사용하도록 허가된 주소들을 인터넷 서비스 제공자(ISP, Internet Service Provier)로부터 할당받는다.

(ex. 성공회대의 ISP는 KT 이다. )

<br />

> 참고: 성공회대학교 IP 주소 할당 과정
>
> (1) 전세계 IP 주소 총괄 관리는 IANA
>
> (2) 대륙별 IP 주소 총괄 관리는 RIR
>
> (3) 우리나라 IP 총괄 관리는 KISA
>
> (4) 성공회대가 이용하는 ISP는 KT
>
> 총 과정: `IANA > KISA > KT > 성공회대학교`

<br />

**주소에 대한 이름**
몇몇 네트워크에서 노드는 사람이 쉽게 식별할 수 있는 `www.skhu.ac.kr` 또는 `hyerin의 Macbook pro` 같은 텍스트 이름을 가지기도 한다.

> www.skhu.ac.kr : 인터넷에서의 이름
>
> hyerin의 Macbook pro : mac 네트워크에서의 이름

<br />

일반적으로 어떤 특정한 시점에 어떤 노드 이름 하나는 어떤 노드 주소 하나를 가르킨다.

ex. `www.skhu.ac.kr`은 `203.246.75.30`을 가르킨다.

하지만 이름이 주소에 고정되는 것은 아니다.

<br />
<br />

## 3) 패킷(packet)

컴퓨터 네트워크는 패킷 교환(packet-switched) 방식을 사용한다.

네트워크를 여행하는 데이터는 패킷이라 불리는 덩어리로 나뉘고, 각각의 패킷은 따로 따로 처리(전달) 된다.

각각의 패킷에는 송신자와 수신자의 정보가 포함되어 있다.

<br />

데이터를 패킷으로 나누어 전달하는 방식의 장점

* 여러 대화가(통신이) 회선 하나를 공유할 수 있다.
  ➡️ 통신이 회선 하나를 독점하지 않는다.
* 전송 과정에서 패킷의 손상 여부를 체크섬(checksum) 값으로 확인할 수 있다.

<br /> 
<br />

## 4) 프로토콜(protocol)

프로토콜은 컴퓨터들이 서로 대화(통신)하는 방법에 대한 자세한 규칙이고 약속이다.

<br />

**프로토콜의 예**

* HTTP (Hypertext Transfer Protocol)
  웹 서버와 웹브라우저 간의 통신 방법을 정의
  매우 고수준의 프로토콜 <br />
* IEEE 802.3 표준
  특정 유형의 회선에서 비트를 전기 신호로 인코딩하는 방법을 정의
  매우 저수준의 프로토콜

<br />
<br />

# 2. 네트워크 계층

## 1) 계층형 아키텍처

네트워크 통신 시스템은 몇 개의 계층으로 분리되어 설계 구현되었다.

각 계층들은 다양한 추상화 단계를 나타낸다.

> 참고: 계층형 아키텍처 (layered architecture)
>
> 매우 복잡하고 거대한 시스템을 설계, 구현하는 것은 당연히 어렵다.
>
> 이 어려움을 극복하는 효과적인 방법은 거대한 시스템을 작게 나누어서 하나씩 해결하는 것이다.
>
> 거대하고 복잡한 SW는 대부분 계층형 아키텍처이다. (ex. 운영체제)

<br />

**계층형 아키텍처의 장점**

계층형 아키텍처에서 각 계층은 인접한 바로 위아래 계층하고만 대화한다.

그렇기 때문에 다음과 같은 장점을 가진다.

<br />

(1) 각 계층의 개발자는 전체 시스템을 전부 다 파악할 필요가 없고 인접한 계층만 파악하면 된다.

예: Java 네트워크 애플리케이션 개발자는 네트워크 통신 시스템의 복잡한 내부 과정을 몰라도

바로 아래 계층인 Java 네트워크 라이브러리만 파악하면 된다.

<br />

(2) 인접한 계층 사이의 인터페이스가 변경되지 않는 한 하나의 계층 안에 있는 소프트웨어를 다른 계층에 미치는 영향 없이 수정하거나 대체할 수 있다.

예: Java 네트워크 라이브러리의 API가 변경되지 않는 한 Java 네트워크 애플리케이션에 아무 영향 없이

Java 네트워크 라이브러리가 버전 업 될 수 있다.

<br />

> 참고: API (Application Programming Interface)
>
> Java의 경우 API는 바로 외부에 노출된 public 클래스, public 메소드 목록이다.

<br />
<br />

## 2) 프로토콜 스택

![p1](https://user-images.githubusercontent.com/33855307/134764010-048b3205-2b32-4000-9727-2a56733b6c46.jpeg)

<br />

위 그림은 우리 주변의 네트워크에 흔히 존재하는 프로토콜 스택(stack)이다.

<br />

> 참고
>
> sw 계층이 쌓인 구조를 스택이라고 부른다.
>
> 예: full stack 개발자 = 아래 계층부터 위 계층까지 전부 개발할 수 있는 개발자

<br />

📝 프로토콜 = 표준 통신 규칙, 표준 통신 규약

<br />

<br />

## 3) 네트워크 계층 모델

<br />

![p2](https://user-images.githubusercontent.com/33855307/134764012-df8c6cc1-ad70-4996-98e7-754176e67649.jpeg)

<br />
<br />

### 웹브라우저와 웹서버의 통신 과정

<br />

![p3](https://user-images.githubusercontent.com/33855307/134764015-0107a6c5-35a4-462c-8308-a00aa8db77d2.jpeg)

<br />

(1) 웹브라우저가 웹서버로부터 어떤 웹페이지를 받아 볼 수 있으려면,

그 페이지에 대한 요청 (HTTP request)을 웹서버에 전송해야 한다.

그래서 웹브라우저 애플리케이션은 그 컴퓨터의 전송 계층에 그 요청 데이터를 전달한다.

<br />

(2) 전송 계층은 전달받은 데이터를 TCP 세그먼트(segment) 단위로 쪼개서 그 컴퓨터의 인터넷 계층에 전달한다.

<br />

(3) 인터넷 계층은 전달받은 데이터를 IP 데이터그램(datagram)으로 쪼개서 `Host-to-Network` 계층으로 전달한다.

<br />

(4) `Host-to-Network` 계층은 전달받은 이진수 디지털 데이터를 전송 물리 매체에 적절한 아날로그 신호로 변환해 전송한다.

> 아날로그 신호의 예
>
> 구리선 → 전압 신호
>
> 무선 → 전파 신호
>
> 광케이블 → 빛 신호

<br />

(5) 원격 컴퓨터의 `Host-to-Network` 계층은 전달받은 아날로그 신호를 디지털 데이터로 디코딩하고,
그 결과인 IP 데이터그램을 그 컴퓨터의 인터넷 계층으로 전달한다.

<br />

(6) 인터넷 계층은 IP 데이터그램의 손상 여부를 확인하고 이상이 없으면 그 결과 데이터를 그 컴퓨터의 전송 계층으로 전달한다.

<br />

(7) 전송 계층은 모든 데이터가 도착했는지 확인하기 위한 검사를 수행하고,

손실되거나 손상된 데이터에 대해 재전송을 요청한다.

그리고 전달받은 데이터의 순서를 원래대의 순서로 정렬하여 그 컴퓨터의 애플리케이션 계층으로 전달한다.

<br />

(8) 원격 컴퓨터의 애플리케이션 계층의 웹 서버가 데이터를 수신한다.

<br /> 
<br />

## 4) Host-to-Network 계층

Host-to-Network 계층은 이더넷 카드나 와이파이 안테나 같은 네트워크 인터페이스 장치가 물리적인 연결을 통해 네트워크로 IP 데이터그램을 보내는 방법을 정의한다.

```
네트워크 인터페이스 장치 → Ethernet 하드웨어 
물리적인 연결 → 유선 케이블, wifi 무선, 광 케이블 
IP 데이터그램 → 패킷(packet)
```

<br />

Host-to-Network 계층의 세부 내용은 다른 계층에 비해 복잡하다.

다행이 Java 네트워크 애플리케이션을 개발할 때, Host-to-Network 계층의 세부 내용을 잘 몰라도 된다.

그렇지만 우리가 구현하는 Java 애플리케이션이 사용하게될 네트워크 회선의 속도를 고려해야 할 것이다.

예: 모바일 앱의 3G 무선 통신을 사용하는 앱이라면, 데이터 전송을 최소화 하도록 개발해야 한다.

<br />
<br />

## 5) internet 계층

인터넷 계층을 OSI 7계층 모델에서는 네트워크 계층이라고 부른다.

이 계층은 데이터를 패킷으로 구성하는 방법과 대상 컴퓨터를 식별하기 위한 주소 체계를 정의한다.

<br />

### Internet Protocol

이 계층에 포함된 가장 대표적인 프로토콜은 인터넷 프로토콜(IP)이다.

인터넷 프로토콜은 세상에서 가장 널리 사용되는 네트워크 계층 프로토콜이며, 

자바가 이해할 수 있는 유일한 네트워크 계층 프로토콜이기도 하다. 


<br /> 

IP에는 두 종류가 존재한다. 32비트 주소를 사용하는 IPv4 및 128 비트 주소를 사용하는 IPv6가 있다. 

이 두 프로토콜은 서로 꽤 다르지만, 자바에서 구현할 때는 그 차이가 노출되지 않는다.   


<br />
<br />

### packet 

internet 계층에서는 데이터를 IP 데이터그램이라는 패킷으로 쪼개서 전달한다. 

IPv4 프로토콜에서 패킷 구조는 다음과 같다. 


<br />
<br />


### routing

패킷을 목적지까지 최적의 경로로 전달하는 방법도 internet 계층에서 정의한다. 

인터넷을 통해 전송되는 데이터는 최종 목적지에 도달하기 전에 여러 라우터를 통과하게 된다. 

> 참고: 라우터 
> 
> 라우터는 네트워크에서 패킷을 전달하는 장비이다. 
> 
> 라우터는 자신에게 보내진 패킷의 목적지 주소를 확인하여 최적의 경로로 패킷을 전달한다. 


<br />
<br />

## 6) tansport 계층 

### internet 계층의 부족한 점 

(1) internet 계층은 모든 패킷이 목적지까지 전송되는 것을 보장하지 않는다. 

몇몇 패킷은 목적지까지 도달하지 못할 수 있다. 

<br />

(2) internet 계층은 패킷에 포함된 데이터가 전송 도중 손상되지 않는다는 것을 보장하지 않는다. 

전송 도중 데이터가 손상될 수도 있다. 

<br />

(3) internet 계층은 패킷들이 전송된 순서대로 도착한다는 것을 보장하지 않는다. 

<br />
<br />

### transport 계층에서 하는 일 

(1) 모든 데이터가 전송되는 것을 보장한다. 

도착하지 않고 중간에 빠진 데이터가 있으면 목적지의 transport 계층이 이를 자동으로 식별하고 재전송을 요청한다. 

출발지의 transport 계층이 해당 데이터를 자동으로 재전송한다. 


<br />


(2) 데이터가 손상되지 않음을 보장한다. 

전송 도중 손상된 데이터가 있으면 목적지의 transport 계층이 이를 자동으로 식별하고 재전송을 요청한다. 

<br />

(3) 데이터의 순서가 유지됨을 보장한다. 

도착한 데이터를 원래의 순서로 재정렬하여 애플리케이션 계층에 전달한다. 

<br />
<br />

### transport 계층의 프로토콜 

(1) TCP 프로토콜 (Transmission Control Protocol) 

손실되거나 손상된 데이터의 재전송과 데이터의 순서를 보장하는 프로토콜이다. 

그래서 신뢰할 수 있지만 오버헤드가 높은 프로토콜이다. 

<br />

(2) UDP 프로토콜 (User Datagram Protocol)

손실되거나 손상된 데이터의 재전송과 데이터의 순서를 보장하지 않는 프로토콜이다. 

그래서 신뢰할 수 없지만 빠른 프로토콜이다. 

<br />
<br />


## 7) application 계층 

사용자의 애플리케이션에 해당하는 계층이다. 

<br />

애플리케이션 계층 아래의 세 계층의 프로토콜은 한 컴퓨터에서 다른 컴퓨터로 데이터를 전송하는 방법을 정의한다. (define how to send)

애플리케이션 계층의 프로토콜은 전공되는 데이터의 내용을 정의한다. 

<br />

대표적인 application 계층 프로토콜은 HTTP, FTP, SMTP 이다. 

* HTTP 프로토콜: HTML 문서를 주고 받는 것을 정의 

* FTP 프로토콜: 파일을 주고 받는 것을 정의 

* SMTP 프로토콜: 이메일을 전송하는 것을 정의 

<br />
<br />


# 3. IP, TCP, UDP 
## 1) IP (Internet Protocol)
IP는 미국과 소련 냉전 시대 군사적인 목적으로 미국이 개발했다. 

<br />

### routing 
IP는 네트워크에서 라우터가 몇 개 손상되더라도 네트워크는 계속 작동되도록 설계했다. 

출발지에서 목적지까지 복수개의 경로가 존재하고 중간의 손상된 라우터를 우회해서 패킷이 라우팅될 수 있도록 설계되었다. 

<br />

### platform independent 
군사시설에는 여러 종류의 컴퓨터가 있고 이들 모두가 서로 통신이 가능해야 했다. 

IP는 공개적이고 플랫폼 독립적으로 만들어졌다. 

메인프레임부터 PC까지 모든 컴퓨터가 IP 네트워크에 연결될 수 있다. 

<br /> 
<br /> 

## 2) TCP, UDP 
TCP는 꽤 많은 오버헤드를 유발한다. 

그래서 데이터 순서가 특별히 중요하지 않고 일부 패킷의 손실이 전체 데이터 스트림을 손상시키지 않는 경우 

패킷은 종종 UDP 프로토콜을 이용하여 보낼 수 있다. 

예를들어 비디오나 오디오 신호의 일부 손실은 화질이나 음질에 눈에 띄는 저하를 발생시키지 않는다. 

<br />
<br />


## 3) IP 주소와 domain name
### IP 주소 
IPv4 네트워크 안에 있는 모든 컴퓨터는 4바이트 숫자로 식별되며 199.1.32.90 처럼 점으로 구분된 네 개의 숫자 형식으로 표기된다. 

네 개의 숫자는 0에서 255까지의 부호 없는 바이트 범위의 값을 가질 수 있다. 

데이터가 네트워크를 통해 전송될 때 패킷의 헤더에는 패킷이 가고자 하는 장비의 주소(목적지 주소)와 패킷을 보낸 주소(출발지 주소)를 포함하고 있다. 

<br /> 

IPv4에는 40억개 이상의 사용 가능한 IP가 있으며, 지구상의 모든 사람들이 하나씩 쓰기에는 충분하지만 모든 컴퓨터들이 쓰기에는 부족하다. 

그래서 16바이트 주소를 사용하는 IPv6로 전환히 진행되고 있다. 

IPv6 주소는 관례상 FEDC:BA98:7654:3210:FEDC:BA98:7654:3210와 같이 콜론으로 구분된 네 개의 16진수를 여덟 개 블록으로 표기한다.

<br /> 
<br /> 

### domain name 
208.201.239.101과 같이 숫자로 된 인터넷 주소를 `www.oreilly.com`처럼 사람이 쉽게 기억할 수 있는 

호스트네임으로 변환해주는 DNS(Domain Name System)이 개발되었다. 

<br /> 
<br />

### DHCP 
서버들은 고정된 IP 주소를 사용하지만 LAN(Local Area Network)이나 무선에 연결된 대부분의 컴퓨터들은 

부팅할 때마다 DHCP(Dynamic Host Configuration protocol) 서버로부터 IP 주소를 할당 받아서 사용한다. 


<br /> 


**내부 네트워크 주소**

다음과 같은 패턴의 IP 주소는 내부 네트워크 주소이다. 인터넷 주소로 사용될 수 없다. 

- `10.*.*.*`

- `172.16.*.*` ~ `172.31.*.*`

- `192.168.*.*`


<br /> 

**로컬 루프백 주소(local loopback address)**

`127.0.0.1`

컴퓨터 자기 자신을 가르키는 주소, 이 주소에 대한 host name은 localhost

<br /> 

**브로드캐스트(broadcast)주소**

4바이트 각각에 모두 같은 숫자를 사용하는 IPv4 주소들 예를들어 `255.255.255.255`는 브로드캐스트 주소이다. 

이 주소로 보내진 패킷들은 로컬 네트워크 안에 있는 모든 노드에 의해 수신되며, 로컬 네트워크 영역을 넘어 라우팅되지 않는다. 

이러한 브로드캐스트 주소는 일반적으로 로컬 네트워크 안의 노드를 탐색하는 용도로 사용된다. 

예르들어 PC는 부팅될 때, DHCP 서버를 찾기 위해 브로드캐스트 주소로 특정 메시지를 전달한다. 

<br /> 
<br /> 

## 4) port 번호 
컴퓨터에서 통신 앱이 한 개만 실행된다면 IP주소만 있어도 된다.

하나의 컴퓨터에서 실행되는 여러 통신 앱을 구별하기 위해서 IP주소뿐만 아니라 포트(port) 번호도 필요하다.

포트 번호는 USB 포트와 같은 어떤 물리적인 부품과 전혀 상관 없고, 그냥 가상의 번호일 뿐이다.

네트워크 애플리케이션은 통신을 할 때, 아직 사용되고 있지 않은 포트 번호를 하나 선택해야 한다.

네트워크를 통해서 패킷이 도착하면, 인터넷 계층은 패킷에서 도착지 포트 번호를 확인한다.

그래서 포트 번호를 사용하고 있는 애플리케이션에 데이터가 전달된다.

포트 번호의 1에서 1023까지는 finger, FTP, HTTP 그리고 IMAP 같은 잘 알려진 서비스를 위해 미리 예약되어 있다.

대부분의 웹서버가 사용하는 포트 번호는 80이다.

<br />
<br />

# 4. the Internet 
인터넷은 세상에서 가장 큰 IP 기반 네트워크다. 

IP(Internet Protocol)을 구현한 네트워크를 IP 네트워크라고 한다. 

IP 네트워크를 줄여서 internet이라고 부를 수 있다. (a internet)

지구 전체가 연결된 IP 네트워크의 이름은 Internet 이다. (the Internet)


<br />

## 1) internet 주소 블럭 
외부와 연결되지 않은 IP 네트워크의 예 → the Internet에 연결되지 않은 회시ㅏ 내부 internet 

외부와 연결되지 않은 IP 네트워크에서는 IP 주소를 맘대로 골라서 사용해도 된다. 

그렇지만 the Internet에서는 할당된 IP 주소만 사용해야 한다. 

<br /> 

성공회대학교는 KT ISP로부터 아래와 같은 internet 주소 블럭을 할당 받았다. 

`203.246.75.0`~`203.246.75.255`(/24) 

이 주소 블럭은 처음 24 비트가 고정되어 있기 때문에 /24 라고 불린다. 

32비트 중 24비트가 고정되었고 나머지 8비트에 해당하는 2^8개의 IP 주소를 사용할 수 있다. 

<br />

그런데 해당 블록에서 가장 낮은 주소는 네트워크 자체를 식별하는 데 사용된다. → `203.246.75.0`

가장 큰 주소는 해당 네트워크에 대한 브로드캐스트 주소로 사용된다. → `203.246.75.255`

따라서 사용할 수 있는 IP 주소는 2^8 - 2 = 254개 이다. 

<br />
<br />



## 2) 네트워크 주소 변환

성공회대에서 사용할 수 있는 IP주소가 254개 이면, 너무 부족하다.

IP 부족 문제를 해결하기 위해서, 네트워크 주소 변환(NAT, Network Address Translation) 기술을 사용한다.

<br /> 

NAT 기술을 사용하는 네트워크에서는,

ISP로부터 할당 받은 public IP 주소와

내부 네트워크에서만 사용하는 내부 네트워크 IP 주소가 있다.

<br /> 

내부 네트워크에서는 다음과 같은 패턴 중 하나를 선택해서 IP주소를 사용한다.

`10.*.*.*`

`172.16.*.*` ~ `172.31.*.*`

`192.168.*.*`

가장 흔한 NAT 장비는 IP 공유기나 무선 공유기이다.


<br /> 

성공회대도 NAT 기술을 사용한다.

성공회대의 경우 KT ISP로부터 할당 받은 public IP 주소는 `203.246.75.0` ~ `203.246.75.255` (/24) 이다.

성공회대 내부 네트워크에서 사용하는 내부 네트워크 IP 주소는 `192.168.*.*` 이다.

성공회대의 PC들에는 내부 네트워크 IP 주소가 할당되어 있다.

성공회대 내부의 PC에서 성공회대 외부 컴퓨터로 패킷이 전달되는 과정은 다음과 같다.


<br /> 


성공회대 내부의 PC에서 성공회대 외부 컴퓨터로 패킷이 전달되는 과정은 다음과 같다.




(1) 내부 컴퓨터에서 외부로 패킷을 전송한다.

이 패킷의 출발지 주소는 내부 컴퓨터의 내부 네트워크 IP 주소이다.


<br /> 

(2) 성공회대 내부 네트워크의 패킷이 외부 네트워크로 나가려면, NAT 라우터를 거쳐야 한다.

NAT 라우터는 밖으로 나가는 패킷의 출발지 주소를 성공회대 public IP 주소로 바꾸어서 외부로 전송한다.

이때 NAT 라우터는, 어떤 내부 네트워크 IP 주소를 어떤 public IP 주소로 바꾸었는지 메모한다.

<br /> 

(3) 그렇게 성공회대 밖으로 나간 패킷은 인터넷을 거쳐 목적지 컴퓨터에 도착한다.

목적지 컴퓨터가 받은 패킷의 출발지 주소는 성공회대 public IP 주소이다.

이 주소로 목적지 컴퓨터는 답장 패킷을 보낸다.

즉 답장 패킷에 적힌 목적지 주소는 성공회대 public IP 주소이다.

<br /> 

(4) 답장 패킷을 성공회대 NAT 라우터가 받는다.

NAT 라우터는 아까 패킷을 외부로 전송할 때 메모해둔 주소 변환을 참고해서,

답장 패킷의 목적지 주소에 적힌 성공회대 public IP 주소를,

성공회대 내부 네트워크 주소로 다시 바꾸어 내부로 전송한다.

<br /> 

(5) 답장 패킷은, 처음에 패킷을 보낸 내부 컴퓨터에 도착한다.


<br /> 
<br /> 


## 3) 방화벽(firewall) 

인터넷상에는 크래커(cracker)들을 비롯한 악의를 가진 사용자들이 존재한다. 

그들의 접근을 차단하기 위해서는 외부 네트워크에서 로컬 네트워크로 들어오고 나가는 단일한 통로를 만들고, 

그 통로를 들어오고 나가는 모든 패킷을 검사하는 것이 도움이 된다.

이런 작업을 수행하는 하드웨어, 소프트웨어를 방화벽이라고 한다.

<br /> 

방화벽은 종종 내부 네트워크와 외부 네트워크를 연결하는 라우터에 포함된 기능으로 동작하기도 하고,

별도의 장비에서 작동하기도 한다.

<br /> 
<br /> 

## 4) proxy 서버

방화벽이 로컬 네트워크 안의 호스트가 외부 네트워크로 직접 연결하는 것을 금지한다면,

프록시 서버는 내부와 외부 사이의 중계자 역할을 한다.

<br /> 

방화벽에 의해 외부 네트워크로 연결이 금지된 장비는 외부에 있는 원격 웹 서버에 대해 직접 요청을 하는 대신 로컬 프록시 서버로부터 웹 페이지를 요청할 수 있다. 

프록시 서버는 해당 요청을 외부의 원격 웹 서버에 요청하고, 요청을 보낸 로컬 장비로 응답을 전달한다.

<br /> 

방화벽이 일반적으로 전송 계층이나 인터넷 계층에서 동작하는 반면에, 프록시 서버는 일반적으로 애플리케이션 계층에서 동작한다.

<br /> 

<img width="554" alt="스크린샷 2021-09-26 오후 12 39 01" src="https://user-images.githubusercontent.com/33855307/134792592-8f1a1965-0c19-4b6f-992a-6bc36ee82d4c.png">

<br />

만약 회사 내부에서는 프록시 서버를 통해서만 웹 서핑을 할 수 있다면,

회사는 어떤 직원이 얼마나 웹 서핑을 하는지 쉽게 감시할 수 있게 된다.



<br />


**방화벽이**

* 인터넷 계층에서 동작한다. 
    - 인터넷 계층이 전송하는 각각의 패킷의 내용을 따로 따로 검사한다.
    - 검사가 빠르다. 그렇지만 검사에 한계가 있다.

* 전송 계층에서 동작한다 
    - 패킷을 순서대로 모은 데이터의 내용을 검사한다 
    - 검사가 좀 더 느리다. 그렇지만 좀 더 많은 것을 검사할 수 있다.


<br />

**프록시 서버는 애플리케이션에서 동작한다.**

* 전송되는 데이터가 HTTP 웹 서핑인지, SMTP 이메일 전송인지, 카톡 채팅인지 구별할 수 있다.

* 누가 어떤 웹사이트를 보고 있는지, 누가 누구에게 어떤 이메일을 전송했는지 파악할 수 있다.


<br />

프록시 서버는 또한 캐시(cache)를 구현하기 위해 사용되기도 한다. 

어떤 PC로부터 프록시 서버를 통해 웹 서버에 파일이 요청되면, 프록시 서버는 먼저 자신의 캐시에 그 파일이 있는지 확인한다. 

캐시 안에 요청된 파일이 있으면, 프록시 서버는 웹 서버에 그 파일을 요청하지 않고, 

캐시된 파일을 PC에 제공할 수 있다. 만약 요청된 파일이 캐시에 없다면, 웹 서버에 그 파일을 요청하고, 

요청 결과 전달 받은 파일을 캐시에 등록한 후, PC에 파일을 제공한다.


<br />
<br />

> 참고 
> 
> 예컨대 네이버 뉴스의 첫 화면이 만들어지는 과정을 생각해보자. 
> 
> 뉴스 첫 화면에 기사가 여러 개 요약되어 표시되고, 사진도 여러 장 표시되어야 한다. 
> 
> 뉴스 기사와 사진은 당연히 DB에 저장되어 있을 것이다. 
> 
> 뉴스 첫 화면에 표시될 기사들과 사진들을 DB에서 전부 조회해서 첫 화면을 만들어야 한다. 
> 
> 네이버 뉴스를 보는 사람이 많아서, 예컨데 1만명이 1초 동안 네이버 뉴스 첫 화면을 요청했다면, 네이버 뉴스 서버는 첫 화면을 만드는 작업을 1초 동안 1만 번 수행해야 한다. 
> 
> 이 작업 과정에서 DB를 몇 십만 번 조회하게 될 것이다. 그런데 네이버 뉴스 서버 앞에, 캐시 역할을 하는 프록시 서버를 구축하고, 네이버 뉴스 서버에 대한 요청들이 모두 이 프록시 서버를 거쳐 가도록 하면 어떻게 될까? 
> 
> 누군가가 웹브라우저창을 열고 처음으로 네이버 뉴스 첫 화면에 접속하면, 이 웹브라우저의 요청을 프록시 서버가 먼저 받는다. 프록시 서버는 이 요청을 네이버 뉴스 서버에 전달한다. 
> 
> 네이버 뉴스 서버는 DB를 여러번 조회해서, 뉴스 첫 화면을 생성해서, 프록시 서버에게 전달한다. 프록시 서버는 뉴스 첫 화면을 자신의 HDD, SSD에 파일로 저장한 후 사용자 PC의 웹브라우저에 전달한다. 
> 
> 그 다음 다른 사용자가 네이버 뉴스 첫 화면을 또 요청하면, 이 요청을 먼저 받은 프록시 서버는, 네이버 뉴스 서버에게 이 요청을 전달하지 않고, 
> 
> 방금 HDD, SSD에 저장해둔 뉴스 첫 화면 파일을 읽어서 사용자 PC의 웹브라우저에 전달한다. 뉴스 첫 화면 뿐만 아니라, 뉴스 서버에 대한 요청들이 위와 같은 방식으로 처리된다. 
> 
> 프록시 서버가 HDD, SDD에 저장해 둔 파일을 읽는 작업은, 네이버 뉴스 서버가 DB를 여러번 조회하며, 뉴스 화면을 만드는 작업에 비해서 훨씬(몇백 배) 간단한 일이기 때문에, 
> 
> 네이버 뉴스 서비스의 성능도 훨씬(몇백 배) 높아진다. 그런데 DB의 뉴스 기사가 수정되어도, 프록시 서버의 HDD에 저장된 파일들은 그대로인 문제점이 있다.
> 
> 이 문제점을 해결하는 간단한 방법은, 일정한 시간이 지나면, 예를 들어 10초가 지나면, 프록시 서버에 저장된 파일들을 전부 자동으로 지워버리면 된다. 
> 
> 파일들이 전부 삭제되면, 프록시 서버는 웹브라우저의 요청을 뉴스 서버에 전달할 수 밖에 없다. 그 요청 결과 만들어진 뉴스 화면을, 프록시 서버는 자신의 HDD에 저장하고, 
> 
> 그 후 10초 동안에는 아까 요청된 URL이 다시 요청되면, 뉴스 서버에 그 요청을 전달하지 않고, 아까 저장해둔 파일을 읽어서 사용자 PC의 웹브라우저에 전달하면 된다. 
> 
> 즉 동시 접속자가 아무리 많아도, 네이버 뉴스 서버는, 정해진 시간 동안, 예를 들어 10초 동안, 요청된 뉴스 화면을 딱 한 번만 만들면 되고, 여러 번 반복해서 다시 만들 필요가 없다.



<br />
<br />

# 5. 클라이언트/서버 모델

## 1) 클라이언트/서버 모델 

대부분의 네트워크 프로그래밍은 클라이언트/서버 모델을 기반으로 한다.

클라이언트 서버 모델은, 클라이언트가 네트워크를 통해서 서버에게 어떤 작업을 요청하고,

서버가 그 요청을 받아서 클라이언트에게 어떤 서비스를 제공해 주는 방식으로 작동한다.

클라이언트 서버 방식의 가장 대표적인 시스템은 웹(WWW)이다.

웹브라우저가 클라이언트 역할을 하고, 웹서버가 서버 역할을 한다.

<br /> 

<img width="615" alt="스크린샷 2021-09-26 오후 12 44 56" src="https://user-images.githubusercontent.com/33855307/134792719-16fe9964-4daa-4d59-82e9-17de289dfdb1.png">


<br /> 
<br /> 

## 2) P2P 모델

일부 네트워크 프로그래밍은 P2P 모델을 기반으로 한다.

P2P 모델에서는 클라이언트나 서버 역할을 하는 컴퓨터가 따로 없고,

P2P 네트워크에 참여하는 컴퓨터가 모두 동등하게 클라이언트 역할도 하고 서버 역할도 한다.

<br /> 

P2P 방식의 가장 대표적인 시스템은 토렌트(torrent)이다.

<br /> 
<br /> 

# 6. 인터넷 표준

여러 회사에서 만든 많은 웹브라우저와 웹서버들이, 문제 없이 서로 통신할 수 있는 이유는,

HTTP 프로토콜 표준을 따라서 구현되었기 때문이다.

<br /> 

프로토콜은 컴퓨터들이 서로 대화(통신)하는 방법에 대한 자세한 규칙이고 약속이다.

<br /> 

프로토콜의 표준을 만드는 기구들 중에서 가장 대적인 곳은, IETF와 W3C 이다.

(Internet Engineering Task Force)

(World Wide Web Consortium)

<br /> 

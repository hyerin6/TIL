# Algorithm & Java        

#### 알고리즘의 이해         
알고리즘은 주어진 문제를 해결하기 위한 방법을 추상화하여 일련의 단계적 절차를 논리적으로 기술해 놓은 명세서이다.    

효율적이고 정확하게 문제를 해결하기 위해서는 데이터를 정확히 정의하고, 데이터를 처리하기에 적당한 알고리즘을 작성해야 한다.   
효과적인 알고리즘이 되기 위해서는 다음의 조건을 만족해야 한다.   
(1) 입력(input) : 알고리즘 수행에 필요한 자료가 외부에서 입력되어야 한다.   
(2) 출력(output) : 알고리즘 수행 후 하나 이상의 결과를 출력해야 한다.    
(3) 명확성(definiteness) : 수행할 작업의 내용과 순서를 나타내는 알고리즘의 명령어들은 명확하게 명세되어야 한다.   
(4) 유한성(finiteness) : 알고리즘은 수행 뒤에 반드시 종료되어야 한다.       
(5) 효과성(effectiveness) : 알고리즘의 모든 명령어들은 기본적이며 실행이 가능해야 한다.      


#### 성능 분석         
1. 알고리즘 분석 기준   
- 정확성   
- 명확성   
- 수행량   
- 최적성   

2. 알고리즘 성능분석 방법   
- 공간 복잡도        
- 시간 복잡도     

#### 빅-오 표기법       
(1) 실행 빈도수를 구하여 실행시간 함수를 찾는다.      
(2) 실행시간 함수의 값에 가장 큰 영향을 주는 n에 대한 항을 선택하여 계수는 생략하고 O의 오른쪽 괄호안에 표기한다.      

실행시간 함수 값의 크기는           
**log n < n < n  log n < n^2 < 2^n**       
의 순서로 커진다. 실행 빈도수가 상수 값을 가지는 경우에는 O(1)로 표기하며 가장 빠른 실행시간이 된다.    
 

#### 객체 지향 프로그래밍의 이해    
1. 객체의 특징     
- 캡슐화   
객체의 첫 번째 특징은 캡슐화(encapsulation)다. 캡슐화는 객체 내부의 메소드와 데이터를 외부에서   
사용할 수 없도록 감싸서 객체를 독립적인 프로그램 부품으로 만드는 것이다.   
캡슐화된 객체는 지정한 인터페이스를 통해서만 외부와 연결되어 밖에서 안의 내용을 볼 수 없기 때문에   
독립성을 갖게 된다. 이를 데이터 은닉(Data Hiding)이라 한다.   

- 코드의 재사용 : 상속   
코드의 재사용성은 이미 작성한 프로그램 코드를 다른 프로그램에서 사용할 수 있도록 하는 객체의 중요한 특징으로   
개발비용을 줄이고 신뢰성과 생산성을 높인다.   
캡슐화되어 있는 객체는 인터페이스만 맞춰주면 다른 프로그램에서도 사용할 수 있는데, 이렇게 객체를 재사용함으로써 코드의 재사용을 실현한다.     
또 다른 객체의 코드 재사용 방법으로 상속(inheritance)이 있다.    
이때 상속해주는 시존의 객체를 부모객체 또는 상위객체라고 하고, 상속을 받는 새로운 객체를 자식객체 또는 하위객체라고 한다.   

- 다형성   
다형성은 하나가 여러 형태를 가지고 있다는 의미이다. 객체의 다형성이란 같은 이름의 메소드가 상황에 따라 다른 연산을 수행하는 것을 의미한다.       
다형성은 메소드 사용을 간단하게 해주는 객체의 중요한 특징이다.   

#### 객체 지향언어 : 자바   
1. 자바의 캡슐화 구현   
자바 프로그램은 캡슐화된 클래스들을 조합하여 구성한다. 각각의 클래스는 class 키워드를 사용하여 만드는데,   
클래스는 객체를 생성하기 위한 기본 틀이다.       
자바의 클래스는 그 자체가 독립성을 가지기 때문에 정해진 인터페이스를 사용하지 않으면 외부에서는 클래스의 내용을 보거나 수정할 수 없다.   
자바는 독립적인 클래스 작성을 통하여 객체 지향의 캡슐화 기능을 실현한다.   

자바 클래스 내부의 멤버들은 캡슐화하기 위해서 접근 제어자를 사용한다.   
클래스의 각 멤버에 대한 외부의 접근 권한을 지정하는 접근 제어자로는 public, private 등이 있다.   
public으로 지정한 멤버는 외부에서도 접근이 가능하기 때문에 클래스에 대한 외부 인터페이스 역할을 한다.   
반면 private로 지정한 멤버는 같은 클래스의 멤버 메소드만이 접근할 수 있기 때문에 그 클래스 안에서만 사용할 수 있다.   
private 접근 제어자는 데이터 은닉을 제공한다.   


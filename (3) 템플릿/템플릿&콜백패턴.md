# 템플릿과 콜백    

지금까지 UserDao, StatementStrategy, JdbcContext를 이용해 만든 코드는 일종의 전략 패턴이 적용된 것이라고 볼 수 있다. 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 구조다.   
전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링에서는 템플릿/콜백 패턴이라고 부른다.   

전략패턴의 컨텍스트를 템플릿이라고 부르고 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.   



**템플릿**  
템플릿은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다.    
프로그래밍에서는 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿이라고 부른다.   

템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이뤄진다.   


**콜백**    
콜백은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다.    
파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행 시키기 위해 사용한다.   
자바에서 메소드 자체를 파라미터로 전달하는 방법은 없기 때문에 메소드가 담긴 오브젝트를 전달해야 한다.   


<br />       


## 1. 템플릿/콜백의 동작 원리        

템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이다. 콜백은 템플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.   


#### 템플릿/콜백의 특징     
여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다.     
여러 가지 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용할 수도 있지만 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다. 


콜백 인터페이스의 메소드에는 보통 파라미터가 있다. 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용한다.    


- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.     

- 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.   

- 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 한다.   


조금 복잡한거 같지만 DI 방식의 전략 패턴 구조라고 생각하고 보면 간단하다.   
클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI다.        
템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어난다.       
일반적인 DI는 템플릿에 인스턴스 변수가 있고 의존 오브젝트를 수정자 메소드로 받아 사용한다면, 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받는다는 것이 특징이다.      
콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징이다.    


**템플릿/콜백의 특징 요약**        
- 템플릿은 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받는다.      
- 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다.       
- 클라이언트와 콜백이 강하게 결합된다.      




<br />        


## 2. 편리한 콜백의 재활용          

템플릿/콜백 방식은 템플릿에 담긴 코드를 여기저기 반복적으로 사용하는 원시적인 방법에 대해 많은 장점이 있다.         
그런데 템플릿/콜백 방식에서 아쉬운 점이 있다.   
DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다는 것이다.       



#### 콜백의 분리와 재활용        

분리를 통해 재사용이 가능한 코드를 찾아낼 수 있다면 익명 내부 클래스를 사용한 코드를 간결하게 만들 수도 있다.           
예제를 통해 알아보자.     


- 익명 내부 클래스를 사용한 클라이언트 코드     

```      
public void deleteAll() {          
	this.jdbcContext.work(  
		// 변하지 않는 콜백 클래스 정의와 오브젝트 생성       
		new StatementStrategy() {          
			public PreparedStatement makePreparedStatement(Connection c) {
				return c.prepareStatement("delete from users"); // 변하는 SQL 문장  
			}
		}
	)
}
```       


- 변하지 않는 부분을 분리시킨 deleteAll() 메소드          

```
public void deleteAll() {
	executeSql("delete from users"); // 변하는 SQL 문장   
} 
```   


```
private void executeSql(final String query){
	// 변하지 않는 콜백 클래스 정의와 오브젝트 생성      
	new StatementStrategy() {
		public PreparedStatement makePreparedStatement(Connection c) {
			return c.prepareStatement(query); 
		}
	}
}
```


SQL을 담은 파라미터를 final로 선언해서 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 하는 것만 주의하면 된다.    
이렇게 재활용이 가능한 콜백을 담은 메소드가 만들어졌다.        



#### 콜백과 템플릿의 결합      

한 단계 더 나아가보자. executeSql() 메소드는 UserDao만 사용하기는 아깝다.   
DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 된다.   

executeSql 메소드를 옮기고 접근자를 public으로 바꿔서 외부에서 바로 접근이 가능하게 하면 된다.        


```
public class JdbcContext {
	
	. . .

	public void executeSql(final String query) {
		work(
			new StatementStrategy() {
				public PreparedStatement makePreparedStatement(Connection c) {
					return c.prepareStatement(query;)
				}
			}
		);
	}

	
}
```   


executeSql() 메소드가 JdbcContext로 이동했으니 UserDao의 메소드에서도 jdbcContext를 통해 executeSql() 메소드를 호출하면 된다.     
이렇게 되면 모든 DAO 메소드에서 executeSql() 메소드를 사용할 수 있게 되었다.     

일반적으로는 성격이 다른 코드들은 가능한 한 분리하는 편이 낫지만, 이 경우는 반대다. 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문에 한 군데 모여 있는 게 유리하다.     
구체적인 구현과 내부의 전략 패턴, 코드에 의한 DI, 익명 내부 클래스 등의 기술은 최대한 감추고 외부에는 꼭 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것이다.     



<br />        


## 3. 템플릿/콜백의 응용     

고정된 작업 흐름을 갖고 있으면서 여기저기서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보자.   

(1) 중복된 코드는 먼저 메소드로 분리할 방법을 생각해본다.           
(2) 그중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 한다.           
(3) 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴을 적용하는 것을 고려해본다.    


가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드다.     




#### 테스트와 try/catch/finally     

간단한 템플릿/콜백 예제를 하나 만들어보자.   
파일을 하나 열어서 모든 라인의 숫자를 더한 합을 돌려주는 코드를 만들어보자.   


```
public Integer calcSum(String filepath) {
	try {
		// 계산 로직 
	} cathch(IOException e) {
		// exception 처리   
	} finally {
		// 리소스 닫힘 확인 및 처리   
	}
}
```

DAO의 JDBC 코드에 적용했던 것과 기본 개념은 같다.   
만들어진 모든 리소스는 확실히 정리하고 빠져나오도록 만드는 것과 모든 예외상황에 대해서는 적절한 처리를 해두는 것 두 가지다.    




#### 중복의 제거와 템플릿/콜백 설계      
 
그런데 이번엔 파일에 있는 모든 숫자의 곱을 계산하는 기능을 추가해야 한다.   
파일을 읽어서 처리하는 기능은 비슷한데 앞에서 만든 코드를 복사해서 사용해야 할까? 템플릿/콜백 패턴을 적용해보자.                

먼저 템플릿에 담을 반복되는 작업 흐름은 어떤 것인지 파악하고 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇이고, 콜백이 템플릿에게 돌려줄 내용은 무엇인지 생각해봐야 한다.   
템플릿이 작업을 마친 후 클라이언트에게 전달해줘야 하는 것도 있을 것이다.   
템플릿/콜백 패턴을 적용할 때는 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 전달하는 내용이 무엇인지 파악하는 게 가장 중요하다.   
그에 따라 콜백의 인터페이스를 정의해야 하기 때문이다.    

가장 쉽게 생각해볼 수 있는 구조는 템플릿이 파일을 열고 각 라인을 읽어올 수 있는 BufferedReader를 만들어서 콜백에게 전달해주고, 콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 돌려주는 것이다.    

템플릿에서는 BufferedReaderCallback 인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행해주면 된다.        
콜백이 돌려준 결과는 최종적으로 모든 처리를 마친 후에 다시 클라이언트에 돌려주면 된다.   

템플릿/콜백을 적용한 calcSum() 메소드는 다음과 같다.   


```
public Integer calcSum(String filepath) {
	BufferedReaderCallback sumCallback = 
		new BufferedReaderCallback() {
			public Integer doSomethingWithReaders(BufferedReader br) {
				Integer sum = 0;
				// 계산 로직    
				return sum;  
			}
		};
	
	return fileReadTemplate(filepath, sumCallback);
}
```    


이제 파일에 있는 숫자의 곱을 구하는 메소드도 이 템플릿/콜백을 이용해서 만들면 된다.          




#### 템플릿/콜백의 재설계       

calcSum()과 calcMultiply()에 나오는 두 개의 콜백을 비교해보자. 두 개의 코드는 아주 유사하다.     
결과 값을 저장하는 sum 변수에 어떤 처리를 하는지만 다를 뿐 나머지 코드는 동일하다.     

템플릿과 콜백을 찾아낼 때는, 변하는 코드의 경계를 찾고 그 경계를 사이에 두고 주고받는 일정한 정보가 있는지 확인하면 된다고 했다.      


- 라인별 작업을 정의한 콜백 인터페이스   

```
public interface LineCallback {
	Integer LineCallback(String line, Integer value);
}	
```


- LineCallback을 사용하는 템플릿      

```
public Integer lineReadTemplate(String filepath, LineCallback callback, int initval) {
	try {
	
		. . .
		
		// 파일의 각 라인을 루프를 돌면서 가져오는 것도 템플릿이 담당한다.    
		while(line = br.readLine() != null) {
			// 각 라인의 내용을 가지고 계산하는 작업만 콜백에게 맡긴다. 	
			res = callback.doSomethingWithLine(line, res);
		}
		return res;
	}
}
```


템플릿 파일의 각 라인을 읽는 작업이 추가됐다. 계산 결과를 담을 변수를 초기화할 값도 파라미터도 전달받게 만들었다.     
새로 만든 템플릿이 기존에 만들었던 템플릿들과 다른 점은 while 루프 안에서 콜백을 호출한다는 점이다.     
콜백을 여러 번 반복적으로 호출하는 구조가 된 것이다.     



- lineReadTemplate()을 사용하도록 수정한 calSum(), calcMultiply() 메소드   

```
public Integer calcSum(String filepath) {
	LineCallback sumCallback = 
	  new LineCallback() {
	  	public Integer doSomethingWithLine(String line, Integer value) {
			return value + Integer.valueOf(line); // return value * Integer.valueOf(line);
		}};
	return lineReadTemplate(filepath, sumCallback, 0); // return lineReadTemplate(filepath, multiplyCallback, 1);
}
```

주석으로 처리한 부분이 calcMultiply() 메소드 구현 부분이다.        

로우레벨의 파일 처리 코드가 템플릿으로 분리되고 순수한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명확하게 보인다.   
Calculator 클래스와 메소드는 데이터를 가져와 계산한다는 핵심 기능에 충실한 코드만 갖고 있게 됐다.   


템플릿/콜백 패턴은 다양한 작업에 손쉽게 활용할 수 있다.   
코드의 특성이 바뀌는 경계를 잘 살피고 그것을 인터페이스를 사용해 분리한다는 가장 기본적인 객체지향 원칙에만 충실하면 어렵지 않게 템플릿/콜백 패턴을 만들어 활용할 수 있을 것이다.   



#### 제네릭스를 이용한 콜백 인터페이스   

지금까지 사용한 LineCallback과 lineReadTemplate()은 템플릿과 콜백이 만들어내는 결과가 Integer 타입으로 고정되어 있다.   
결과의 타입을 다양하게 가져가고 싶다면 자바 언어의 타입 파라미터라는 개념을 도입한 제네릭스를 이용하면 된다.   
제네릭스를 이용하면 다양한 오브젝트 타입을 지원하는 인터페이스나 메소드를 정의할 수 있다.    
콜백과 템플릿을 String 타입의 값도 처리할 수 있도록 확장하면 다음과 같은 코드가 된다.   


```
public interface LineCallback<T> {
	T doSomethingWithLine(String line, T value);
}
```





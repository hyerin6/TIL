# WHERE 조건 이해   
## 1. 묵시적 형변환 함정에 빠지지 말자.   
서비스 쿼리를 작성하다 보면 이상은 없는 성능이 좋지 않을 때가 있다.   

명시적으로 쿼리 내용을 볼 수 있다면 괜찮겠지만   
애플리케이션에서 변수를 바인딩하여 SQL을 실행한다면 성능이 안 좋은 이유를 찾기 어렵다.   

묵시적 형변환이 발생하여 테이블 풀스캔에 따른 현상을 방지하는 방법을 알아보자.   

<br />

### 1) 묵시적 형변환이란?   
조건절의 데이터 타입이 다를 때 우선순위가 높은 타입으로 형이 내부적으로 변환되는 것을 말한다.    
문자열-정수 비교 쿼리가 들어오면 두 개의 칼럼 중 우선순위가 낮은 문자열은 자연스럽게 정수 타입으로 형변환되어 처리된다.   

묵시적 형변환이 일어나는 대상이 인덱스 필드라면?      
조건절을 처리하기 위해 모든 데이터를 묵시적으로 형변환하기 때문에 테이블 풀스캔할 수밖에 없으며, 이 경우 성능이 심각하게 저하된다.   

<br />

### 2) 테스트 
```
## 테이블 생성 
CREATE TABLE test (
    i int unsigned NOT NULL auto_increment,
    j int unsigned NOT NULL,
    s varchar(64) NOT NULL,
    d datetime NOT NULL,
    primary key(i)
);

## 인덱스 추가 
ALTER TABLE test ADD key(j), ADD key(s), ADD key(d);

## 데이터 추가
INSERT INTO test (j, s, d)
values
(
    crc32(rand()),
    crc32(rand())*123245,
    date_add(now(), interval -crc32(rand())/5 second)
);
```

테스트할 준비를 하고 다음 쿼리를 17번 실행하면 테이블에는 131,072건의 데이터가 저장된다.   

```
INSERT INTO test (j, s, d)
SELECT 
    crc(rand()),
    crc(rand()) * 12345,
    date_add(now(), interval -crc32(rand())/5 second)
FROM test;
```

<br />

테스트할 데이터를 한 건 무작위로 가져와보자. 

```
Mysql> SELECT * FROM test ORDER BY rand() LIMIT 1;

+-------------+-------------+----------------+--------------------+
| i           | j           | s              | d                  | 
+-------------+-------------+----------------+--------------------+
| 187831      | 1080677858  | 6130532098283  | 1990-11-14 21:55:01|
+-------------+-------------+----------------+--------------------+
```

<br />

### 3) 정수형 칼럼을 문자열 조건으로 검색   
j는 정수 타입이다.  
칼럼이 정수형인 상태에서 문자열로 조건을 주었을 때의 실행 계획의 결과다.   

<img width="435" src="https://user-images.githubusercontent.com/33855307/144172690-682228d8-1626-4505-ad71-70a8ef390f3c.jpeg">  

정수형이 우선순위가 높기 때문에 문자열 조건값은 묵시적으로 정수형으로 형변환되어   
실행 시 큰 문제 없이 신속하게 결과를 얻을 수 있다.   

<br />

### 4) 문자열 칼럼을 정수 조건으로 검색   
s 칼럼은 문자열 칼럼이다.  

<img width="435" alt="스크린샷 2021-12-01 오후 1 40 17" src="https://user-images.githubusercontent.com/33855307/144172969-fa8e6b9a-fb44-47ce-805a-604194ca4d72.png">

s 칼럼에 인덱스가 있으므로 빠른 처리를 기대했겠지만 묵시적인 형변환이 발생하여 테이블 풀스캐을 하며 성능이 크게 저하된다.   
위 테이블 데이터가 많지 않아 속도가 느리지는 않지만 천만 건 이상의 많은 데이터가 있는 DB라면 성능에 치명적일 것이다.   

<br />

## 2. 함수, 잘못 쓰면 성능에 독이 된다.   
대부분의 DBMS에서 함수 기능을 제공한다.   
잘못 쓰면 불필요한 시스템 부하가 된다.   

예) 특정 날짜, 특정 시간에 사용자별 접속 통계를 추출하는 쿼리  

```
SELECT userid, count(*) AS cnt
FROM user_acess_log 
WHERE DATE_FORMAT(reg_date, '%Y%m%d') = '20120818'
    AND DATE_FORMAT(reg_date, '%H') >= '18'
    AND DATE_FORMAT(reg_date, '%H') < '21'
GROUP BY userid;
```

위와 같이 작성하면 어떤 목적의 쿼리인지 쉽게 알아볼 수는 있지만   
DB 내부적으로 테이블 풀스캔을 수행할 수밖에 없다.   
적절한 인덱스 또는 테이블 파티셔닝이 적용되어 있어도 마찬가지다.    

옵티마이저는 칼럼의 분포도를 기준으로 테이브를 추출하는 가장 빠른 방법을 도출한다.   
그런데 위와 같이 reg_date 칼럼 검색 시 DATE_FORMAT 함수를 사용하면   
옵티마이저는 reg_date와 연관된 데이터 분포도를 알 수 없게 된다.   
함수로 인해 옵티마이저가 변경될 결과값을 예상하지 못하기 때문이다.   


```
SELECT userid, count(*) AS cnt
FROM user_acess_log 
WHERE reg_date >= '2012-08-18 18:00:00'
    AND reg_date < '2012-08-18 21:00:00'
GROUP BY userid;
```

불필요한 함수를 없애고 시간을 가져오도록 쿼리를 변경했다.   
reg_date에 인덱스가 있거나 reg_date에 파티셔닝을 적용하면 빠르게 필요한 데이터에 접근하여 데이터를 가져온다.   

<br />

## 3. LIKE 검색을 아무 때나 써야 하나?
데이터를 조회할 때 특정 단어가 들어 있는 데이터를 검색하기 위해 LIKE 검색을 사용한다.   
편리하지만 대용량 테이블인 경우 위험하다.   

LIKE 검색은 `%` 문자 위치에 따라서 칼럼에 해당 인덱스가 있을지라도 의미가 없을 수도 있다.   
DB는 인덱스 키 순서로 정렬, 관리되므로 중간 또는 뒷부분부터 검색하면 인덱스 의미가 없어진다.  

<br />    

### 1) LIKE 테스트  

그렇다면 `%`를 맨 뒤에 붙이면 무조건 인덱스를 잘 활용할까?    

#### `'1311%'` vs `'1%'`   
`'1311%'`의 실행 결과 `Type` 항목은 range로 인덱스를 적절하게 활용했다.       
그러나 `'1%'`은 `Type` 항목이 All로 테이블 풀스캔으로 변경되었다.   

대부분의 DBMS에는 옵티마이저가 있다.   
옵티마이저는 데이터 분포도를 따져서 내부적으로 SQL을 최적으로 처리한다.   
1로 시작하는 데이터 비율이 전체적을 20% 이상을 차지하므로, 인덱스를 읽고 다시 데이터 파일로 가는 것보다   
처음부터 전체 데이터를 읽고 필요한 데이터를 선별하는 것이 더 빠르다고 옵티마이저가 판단했기 때문에 풀스캔을 한 것이다.     

<br />

### 2) `LIKE '%xxx%'` 테스트           
인덱스는 순차적으로 비교되므로 당연히 테이블 풀스캔이 발생한다.   

<br />

### 3) `LIKE '%xxx'` 테스트  
위 결과와 마찬가지로 테이블 풀스캔이 발생한다.   

상용 DBMS에서는 함수 결과를 인덱스로 구성하는 '함수 기반 인덱스'를 사용하여 위와 같은 요구 사항을 처리할 수 있다.     
함수로 문자열을 거꾸로 만들어서 그 결과를 인덱스로 구성하면 된다.   
MySQL에는 이런 기능이 없다.     
이러한 기능을 구현하려면 추가 인덱스 칼럼을 생성하고 트리거로 관리하면 된다.   

<br />

### 4) 결론   
* LIKE 조건이 '검색어%'와 같이 검색어가 앞 단에 있다면 데이터 분포도를 따져서 수행한다.   
* LIKE 조건이 '%검색어'와 같은 형태로 반드시 수행해야 한다면 LIKE 조건 이외의 조건절을 적극 활용하여  
LIKE 처리가 필요한 데이터 범위를 최대한 줄인다.   

<br />

인덱스는 필요한 데이터를 지칭한다는 점에서 데이터에 접근하기 위한 효율적 요소인 것은 분명하다.     
그러나 인덱스 또한 메모리를 차지하고, 디스크를 소모하며 CPU 연산이 필요한 데이터라는 것을 기억해야 한다.      
DB에서 처리하는 데이터 범위를 최대한 줄이는 것이 성능 최적화의 가낭 기본적인 요소다.        

<br />

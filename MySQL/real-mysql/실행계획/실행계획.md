DBMS에서도 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 통계 정보를 참조하며   
그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업이 필요하다. DBMS에서는 옵티마이저가 이러한 기능을 담당한다.    

MySQL에서는 EXPLAIN이라는 명령으로 쿼리의 실행 게획을 확인할 수 있는데 여기에는 많은 정보가 출력된다.   

<br />   

# 1. 개요   
옵티마이저가 만들어 내는 실행 계획을 이해햐는 것 또한 상당히 어렵고 가장 복잡하다.   

## 1.1 쿼리 실행 절차   
MySQL 서버에서 쿼리가 실행되는 과정은 크게 3가지로 나뉜다.   

#### (1) 첫 번째 단계 : SQL 파싱      
* 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.        
* MySQL 서버의 SQL 파서라는 모듈로 처리     
* SQL 파스트리가 만들어진다.     
* MySQL 서버에서 SQL 파스트리를 이용해 쿼리를 실행한다.     
* 거의 MySQL 엔진이 처리     
   
#### (2) 두 번째 단계 : 최적화 및 실행 계획 수립    
* SQL의 파싱 정보(파스 트리)를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.      
* MySQL 서버의 옵티마이저에서 실행     
* 거의 MySQL 엔진이 처리   

#### (3) 세 번째 단계 : 스토리지 엔진에 레코드 읽어오라고 요청, 레코드 조인, 정렬 작업       
* 두 번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 통해 스토리지 엔진으로부터 데이터를 가져온다.      
* MySQL 엔진과 스토리지 엔진이 동시에 참여해서 처리한다.     

<br />               

## 1.2 옵티마이저의 종류   
* 현재 대부분 DBMS가 사용하는 비용 기반 최적화(Cost-based optimizer, CBO)             
쿼리를 처리하기 위한 여러 가지 가능한 방법을 만들고 각 단위 작업의 비용(부하) 정보와    
대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출한다.     
<br />      
* 예전 오라클에서 사용했던 규칙 기반 최적화(Rule-based optimizer, RBO)             
기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립한다.


<br />       
 
## 1.3 통계 정보    
통계 정보가 정확하지 않다면?     
예) 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 10만건인 것처럼 돼티 있다면      
옵티마이저는 실제 쿼리 실행 시에 인덱스 레인지 스캔이 아니라 풀 테이블 스캔으로 실행할 수도 있다.      

MySQL에서 관리되는 통계 정보는 다음과 같다.   
* 대략적인 레코드 건수  
* 인덱스의 유니크한 값의 개수    

레코드 건수가 적으면 통계 정보가 부정확한 경우가 많아 ANALYZE 명령으로 강제적으로 갱신해야 할 때도 있다.     
> ANALYZE 명령은 인덱스 키 값의 분포도(선택도)만 업데이트한다.       
> 전체 테이블의 건수는 테이블의 전체 페이지 수를 이용해 예측한다.   
> ANALYZE 명령을 실행하는 동안 InnoDB 테이블은 읽기, 쓰기가 불가능하므로 서비스 도중에는 사용하지 않는 것이 좋다.    

<br />      

# 2. 실행 계획 분석    
쿼리의 실행 계획을 확인하려면 EXPLAIN 명령을 사용하면 된다.    

```
EXPLAIN 
SELECT e.emp_no, e.first_name, s.from_date, s.salary 
FROM employee e, salaries s 
WHERE e.emp_no = s.emp_no
LIMIT 10;
```
 
* 결과는 쿼리 문장에서 사용된 테이블(임시 테이블 포함)의 개수만큼 출력    

* 먼저 출력될수록 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블   

* 아래쪽일수록 안쪽(Inner) 부분이거나 나중에 접근한 테이블  

* UPDATE, INSERT, DELETE 문장에 대해서는 실행 계획을 확인할 방법이 없다.
  
* WHERE 조건절만 같은 SELECT 문장을 만들어서 대략적으로 계획을 확인해 볼 수 있다.      

<br />  

## 2.1 id 칼럼   
하나의 SELECT 문장은 다시 1개 이상의 하위(SUB) SELECT 문장을 포함할 수 있다.    

```
SELECT ...
FROM (SELECT ... FROM tb_test1) tb1,
    tb_test2 tb2
WHERE tb1.id=tb2.id;
```

위 쿼리 문장의 각 SELECT는 다음과 같이 분리해서 생각해볼 수 있다.   

```
SELECT ... FROM tb_test1;
SELECT ... FROM tb1, tb_test2 tb2 WHERE tb1.id=tb2.id;
```

실행 계획에서 가장 왼쪽에 표시되는 id 칼럼은 SELECT 쿼리별로 부여되는 식별자 값이다.      
SELECT 문장은 하나인데 여러 개의 테이블이 조인되는 경우에는 id 값이 증가하지 않고 같은 id가 부여된다.   

<br />       

## 2.2 select_type 칼럼   
각 단위 SELECT 쿼리가 어떤 타입의 쿼리인지 표시되는 칼럼이다.    

<br />     

## 2.3 table 칼럼   
MySQL의 실행 계획은 단위 SELECT 쿼리 기준이 아니라 테이블 기준으로 표시된다.       
테이블 별칭을 사용하면 별칭이 표시되고 별도의 테이블을 사용하지 않으면 NULL이 표시된다.      
예) `EXPLAIN SELECT NOW();`      

<br /> 

## 2.4 type 칼럼    
쿼리의 실행 계획에서 type 이후의 칼럼은 MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미한다.       

다음은 실행 계획의 type에 표시될 수 있는 값이다.   
* system           
* const            
* eq_ref      
* ref       
* fulltext        
* ref_or_null       
* unique_subquery        
* index_subquery        
* range       
* index_merge       
* index       
* ALL    
<br />       
  
### ref       
조인의 순서와 관계없이 사용되며, 프라이머리 키나 유니크 키 등의 제약 조건도 없다.    
인덱스의 종류와 관게없이 동등(Equal) 조건으로 검색할 때는 ref 접근 방법이 사용된다.     
동등 조건만으로 비교되므로 매우 빠른 레코드 조회 방법 중 하나다.    
<br />        

### range         
range는 인덱스 레인지 스캔 형태의 접근 방법이다. 인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미하는데   
주로 "<, >, IS NULL, BETWEEN, IN, LIKE" 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.    
접근 방법의 순서상으로 보면 MySQL이 가지고 있는 접근 방법 중에서 상당히 우선순위가 낮다는 것을 알 수 있다.    
그러나 이 접근 방법도 상당히 빠르고 모든 쿼리가 이 접근 방법만 사용해도 어느 정도 성능은 보장된다고 볼 수 있다.    
<br />      

### index       
접근 방식의 이름이 index라서 효율적으로 인덱스를 사용한다고 착각할 수 있다.    
하지만 index 접근 방식은 인덱스를 처음부터 끝까지 읽는 인덱스 풀 스캔을 의미한다.    

index 접근 방법은 다음의 조건 가운데 [1], [2] 조건을 충족하거나 [1], [3] 조건을 충족하는 쿼리에서 사용되는 읽기 방식이다.   

1. range나 const 또는 ref와 같은 접근 방식으로 인덱스를 사용하지 못하는 경우       
2. 인덱스에 포함된 칼럼만으로 처리할 수 있는 쿼리인 경우 (데이터 파일을 읽지 않아도 되는 경우)       
3. 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우 (별도의 정렬 작업을 피할 수 있는 경우)    
<br />      




ALL을 제외한 나머지는 모두 인덱스를 사용하는 접근 방법이다.    
ALL은 인덱스를 사용하지 않는 풀 테이블 스캔 접근 방식을 의미한다.     
index_merge를 제외한 나머지 접근 방법은 하나의 인덱스만 사용한다.   

<br />    

## 2.5 possible_keys    
MySQL 옵티마이저는 쿼리를 처리하기 위해 여러 가지 처리 방법을 고려하고 그중에서 비용이 가장 낮을 것으로 예상하는 실행 계획을 선택해서 쿼리를 실행한다.      
그런데 possible_keys의 내용은 MySQL 옵티마이저가 최적의 실행 계획을 만들기 위해 후보로 선정했던 접근 방식에서 사용되는 인덱스의 목록이다.   
즉 사용될 법했던 인덱스의 목록인 것이다. 이 인덱스들을 사용한다고 판단하지 않도록 주의해야 한다.   

<br />   

## 2.6 key    
Key 칼럼에 표시되는 인덱스는 최종 선택된 실행 계획에서 사용하는 인덱스를 의미한다.     
그러므로 쿼리를 튜닝할 때는 Key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것도 중요하다.   
Key 칼럼에 표시되는 값이 PRIMARY인 경우에는 프라이머리 키를 사용한다는 의미이다.   

<br />   

## 2.7 key_len      
실제 업무에서 사용하는 테이블은 단일 칼럼만으로 만들어진 인덱스보다 다중 칼럼으로 만들어진 인덱스가 더 많다.      
key_len은 쿼리를 처리하기 위해 다중 칼럼으로 구성된 인덱스에서 몇 개의 칼럼까지 사용했는지 알려준다.      

<br />    

## 2.8 ref   
접근 방법이 ref 방식이면 참조 조건(Equal 비교 조건)으로 어떤 값이 제공됐는지 보여 준다.   
* const : 상수 값을 지정   
* 테이블 명, 칼럼 명 : 다른 테이블의 칼럼명   
* func : 참조용으로 사용된 값을 그대로 사용하지 않고 연산을 거쳐서 참조한 것   

<br />  

## 2.9 rows   
MySQL 옵티마이저는 각 조건에 대해 가능한 처리 방식을 나열하고, 각 처리 방식의 비용을 비교해 최종적으로 하나의 실행 계획을 수립한다.     
대상 테이블에 얼마나 많은 레코드가 포함돼 있는지 또는 각 인덱스 값의 분포도가 어떤지를 통계 정보를 기분으로 조사해서 예측한다.    

MySQL 실행 계획의 rows는 실행 계획의 효율성 판단을 위해 예측했던 레코드 건수를 보여준다.       
반환하는 레코드의 예측치가 아니라 쿼리를 처리하기 위해 디스크로부터 읽고 체크해야 하는 레코드를 의미한다.    

<br />    

## 2.10 Extra    
쿼리의 실행 계획에서 성능에 관련된 중요한 내용이 Extra 칼럼에 자주 표시된다.    
   

<details>
<summary>Extra 자세히 알아보기</summary>
<div markdown="1">   

### const row not found (MySQL 5.1부터)    
쿼리의 실행 계획에서 const 접근 방식으로 테이블을 읽었지만 실제로 해당 테이블에 레코드가 1건도 존재하지 않는다는 뜻이다.    
이 경우 테이블에 적절한 테스트용 데이터를 저장하고 실행해보는 것이 좋다.   
<br />         
  
### Distinct
```
EXPLAIN 
SELECT DISTINCT d.dep_no  
FROM department d, dept_emp de 
WHERE de.dept_no=d.dept_no;
```    

위 쿼리에서 실제 조회하려는 값은 dept_no인데, departments 테이블과 dept_emp 테이블에 모두 존재하는     
dept_no만 중복 없이 유니크하게 가져오는 쿼리다.       
그래서 두 테이블을 조인해서 그 결과에 다시 DISTINCT 처리를 넣은 것이다.     

Extra 칼럼에 Distinct가 표시되는 경우, 쿼리의 DISTINCT를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고    
꼭 필요한 것만 조인했으며 dept_emp 테이블에서는 꼭 필요한 레코드만 읽었다.       

<br />         

### Full scan on NULL key   
이 처리는 `coll IN (SELECT col2 FROM ...)`과 조건이 포함된 쿼리에서 자주 발생할 수 있는데   
만약 col1의 값이 NULL이 된다면 결과적으로 조건은 `NULL IN (SELECT col2 FROM ...)`과 같이 바뀐다.     
SQL 표준에서 NULL은 알 수 없는 값으로 정의하고 있으며, 정의대로 연산을 수행하기 위해 이 조건은 다음과 같이 비교해야 한다.   
  
- 서브 쿼리가 1건이라도 결과 레코드를 가진다면 최종 비교 결과는 NULL    
- 서브 쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 비교 결과는 FALSE

이 비교 과정에서 col1이 NULL이면 **풀 테이블 스캔**(Full scan)을 해야만 결과를 알아낼 수 있다.     
즉 Extra 칼럼의 `Full scan on NULL key`는 col1이 NULL을 만나면 풀 테이블 스캔을 사용할 것이라는 사실을 알려주는 키워드다.   

만약 `col1 IN (SELECT col2 FROM ...)` 조건에서 col1이 NOT NULL로 정의된 칼럼이라면    
이러한 예비책은 사용되지 않고 Extra 칼럼에도 표시되지 않을 것이다.     

만약 칼럼이 NOT NULL로 정의되지는 않았지만 이러한 NULL 비교 규칙을 무시해도 된다면 col1이 절대 NULL은 될 수 없다는 것을    
MySQL 옵티마이저에게 알려주면 된다. 쿼리의 조건에 `col1 IS NOT NULL`이라는 조건을 지정하는 것이다.    

IN이나 NOT IN 연산자의 왼쪽에 있는 값이 실제로 NULL이 없다면 풀 테이블 스캔은 발생하지 않으므로 걱정하지 않아도 되지만        
IN이나 NOT IN 연산자의 왼쪽 값이 NULL인 레코드가 있고, 서브 쿼리에 개별적으로 WHERE 조건이 지정돼 있다면 상당한 성능 문제가 발생할 수도 있다.        
(WHERE 절에 NOT IN과 함께 사용된 서브 쿼리 부분을 참고)      

<br />    

### impossible HAVING (MySQL 5.1부터)       
HAVING 절의 조건을 만족하는 레코드가 없을 때 표시된다.     
이는 쿼리가 제대로 작성되지 못한 경우가 대부분이므로 다시 점검하는 것이 좋다.    

<br />    

### impossible WHERE (MySQL 5.1부터)     
WHERE 조건이 항상 FALSE가 될 수밖에 없는 경우 표시된다.    

<br />    

### Impossible WHERE noticed after reading const tables    
```
EXPLAIN 
SELECT * FROM employees WHERE emp_no=0;
```
이 쿼리는 실제로 실행되지 않으면 `emp_no=0`인 레코드가 있는지 없는지 판단할 수 없다.    
실행 계획만 확인했을 뿐인데 옵티마이저는 사번이 0번인 사원이 없다는 것까지 확인했다.    

이를 토대로 MySQL이 실행 계획을 만드는 과정에서 쿼리의 일부를 실행해 본다는 사실을 알 수 있다.   
또한 이 쿼리는 employees 테이블의 프라이머리 키를 **동등 조건으로 비교**하고 있다. 이럴 때는 const 접근 방식을 사용한다는 것을 이미 살펴봤다.      
const 접근 방식이 필요한 부분은 실행 계획 수립 단계에서 **옵티마이저가 직접 쿼리의 일부를 실행**하고 **실행된 결과 값을 원본 쿼리의 상수로 대체**한다.    

즉 WHERE 조건절의 서브 쿼리는 옵티마이저가 실행한 결과를 다음과 같이 대체한 다음, 본격적으로 쿼리를 실행한다.    

<br />     

### No matching min/max row (MySQL 5.1부터)       
WHERE 조건절을 만족하는 레코드가 한 건도 없는 경우 일반적으로 `Impossible WHERE ...` 문장이 표시된다.      
만약 `MIN()`이나 `MAX()`와 같은 집합 함수가 있는 쿼리의 조건절에 일치하는 레코드가 한 건도 없을 때는      
`No matching min/max row`라는 메시지가 출력된다.           

<br />    

### no matching row in const table (MySQL 5.1부터)        
조인에 사용된 테이블에서 const 방식으로 접급할 때 일치하는 레코드가 없다면 이 메시지가 표시된다.    

<br />     

### No tables used (MySQL 5.0의 "No tables" 에서 변경됨)    
FROM 절이 없는 쿼리 문장이나 "FROM DUAL" 형태의 쿼리 실행 계획에서는 Extra 칼럼에 이 메시지가 표시된다.    
(DUAL은 칼럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블)      

```
EXPLAIN SELECT 1;
EXPLAIN SELECT 1 FROM dual;
```

<br />       

### Not exists    
A 테이블에는 존재하지만 B 테이블에는 없는 값을 조회해야 하는 쿼리가 자주 사용되고 다음과 같은 방법으로 구현한다.        
* NOT IN (subquery) 형태
* NOT EXISTS 연산자          

이러한 형태의 조인을 안티-조인(Anti-JOIN)이라고 한다.   
똑같은 처리를 아우터 조인(LEFT OUTER JOIN)을 이용해도 구현할 수 있다.      

일반적으로 안티-조인으로 처리해야 하지만 레코드의 건수가 많을 때는 아우터 조인을 이용하면 더 빠른 성능을 낼 수 있다.     

아우터 조인을 이용해 dept_emp 테이블에는 있지만 departments 테이블에는 없는 dept_no을 조회하는 쿼리를 예제로 살펴보자.    
아래 쿼리는 departments 테이블을 아우터로 조인해서 ON절이 아닌 WHERE절에     
아우터 테이블(departments)의 dept_no 칼럼이 NULL인 레코드만 체크해서 가져온다.        
즉 안티-조인은 일반 조인(INNER JOIN)을 했을 때 나오지 않는 결과만 가져오는 방법이다.    

```
EXPLAIN
SELECT * 
FROM dept_emp de 
  LEFT JOIN departments d ON de.dept_no=d.dept_no
WHERE d.dept_no IS NULL;
```

이렇게 아우터 조인을 이용해 안티-조인을 수행하는 쿼리에서는 Extra 칼럼이 Not exists 메시지가 표시된다.        

> Extra 칼럼의 Not exists와 SQL의 NOT EXISTS 연산자를 혼동하지 않도록 주의    

<br />    

### Range checked for each record (index map: N)           
두 개의 테이블을 조인하는 다음 쿼리를 보면서 이 메시지의 의미를 이해해 보자.        
조인 조건에 상수가 없고 둘 다 변수(e1.emp_no, e2.emp_no)인 경우, MySQL 옵티마이저는 e1 테이블을 먼저 읽고      
조인을 위해 e2를 읽을 때, 인덱스 레인지 스캔과 풀 테이블 스캔 중에서 어느 것이 효율적일지 판단할 수 없게 된다.       

즉 e1 테이블의 레코드를 하나씩 읽을 때마다 e1.emp_no 값이 계속 바뀌므로 쿼리의 비용 계산을 위한 기준값이 계속 변하는 것이다.   
그래서 어떤 접근 방법으로 e2 테이블을 읽는 것이 좋을지 판단할 수 없는 것이다.    

```
EXPLAIN 
SELECT * 
FROM employees e1, employees e2 
WHERE e2.emp_no >= e1.emp_no;
```

e1 테이블의 emp_no가 작을 때는 e2 테이블을 풀 테이블 스캔으로 접근하고,     
e1 테이블의 emp_no가 큰 값일 때는 e2 테이블을 인덱스 레인지 스캔으로 접근하는 형태를 수행하는 것이 최적의 조인 방법일 것이다.     

따라서 이 메시지의 의미는 "레코드마다 인덱스 레인지 스캔을 체크한다."라고 할 수 있다.     


<br />  

### Scanned N databases (MySQL 5.1부터)    
MySQL 5.0 부터 INFORMATION_SCHEMA라는 DB가 제공된다. MySQL 서버 내에 존재하는 DB의 메타 정보를 모아둔 DB다.       
`Scanned N databases`에서 N은 몇 개의 DB 정보를 읽었는지 보여주는 것이다.   

<br />    

### Select tables optimized away    
`MIN()` 또는 `MAX()`만 SELECT 절에 사용되거나 또는 GROUP BY로 `MIN()`, `MAX()`를 조회하는 쿼리가 적절한 인덱스를 사용할 수 없을 때   
인덱스의 오름차순 또는 내림차순으로 1건만 읽는 형태의 최적화가 적용되면 이 메시지가 표시된다.   

<br />    

### Skip_open_table, Open_frm_only, Open_trigger_only, Open_full_table (MySQL 5.1부터)      
* Skip_open_table : 테이블의 메타 정보가 저장된 파일을 별도로 읽을 필요가 없음    
* Open_frm_only : 테이블의 메타 정보가 저장된 파일만 열어서 읽음      
* Open_trigger_only : 트리거 정보가 저장된 파일만 열어서 읽음       
* Open_full_table : 최적화되지 못해서 테이블 메타 정보 파일과 데이터 및 인덱스 파일까지 모두 읽음       

<br />       

### unique row not found (MySQL 5.1부터)    
두 개의 테이블이 각각 유니크(프라이머리 키 포함) 칼럼으로 아우터 조인을 수행하는 쿼리에서    
아우터 테이블에 일치하는 레코드가 존재하지 않을 때 이 메시지가 표시된다.          

<br />   

### Using filesort    
ORDER BY를 처리하기 위해 인덱스를 이용할 수도 있지만 적절한 인덱스를 사용하지 못할 때는    
MySQL 서버가 조회된 레코드를 다시 한 번 정렬해야 한다.   
ORDER BY 처리가 인덱스를 사용하지 못할 때만 실행 계획의 Extra 칼럼에는 이 메시지가 표시되며   
이는 조회된 레코드를 정렬용 메모리 버퍼에 복사해 퀵 소트 알고리즘을 수행하게 된다.      

<br />   

### Using index (커버링 인덱스)     
데이터 파일을 전혀 읽지 않고 인덱스만 읽어서 쿼리를 모두 처리할 수 있을 때 Extra 칼럼에 이 메시지가 표시된다.       
인덱스를 이용해 처리하는 쿼리에서 가장 큰 부하를 처리하는 부분은 인덱스를 검색해 일치하는 레코드의 나머지 칼럼 값을 가져오기 위해   
데이터 파일을 찾아서 가져오는 작업이다. 최악의 경우 인덱스를 통해 검색된 결과 레코드 한 건 한 건마다 디스크를 한 번씩 읽어야 할 수도 있다.     

**예제 1) 인덱스 레인지 스캔으로 처리된다면 디스크에서 읽기 작업이 얼마나 필요할까?**  
```
SELECT first_name, birth_date
FROM employees WHERE first_name BETWEEN 'Babette' AND 'Gad';
```

1. 이 예제 쿼리는 employees 테이블의 first_name 칼럼에 생성된 인덱스(ix_firstname)을 이용해 일치하는 레코드를 검색할 것이다.         
2. 그리고 일치하는 레코드 5건에 대해 birth_date 칼럼의 값을 읽기 위해 각 레코드가 저장된 데이터 페이지를 디스크로부터 읽어야 한다.       
<br />   

실제 ix_firstname 인덱스에서 일치하는 레코드 5건을 검색하기 위해 디스크 읽기 3~4번만으로 필요한 인덱스 페이지를 모두 가져올 수 있다.   
하지만 각 레코드의 나머지 데이터를 가져오기 위해 최대 5번의 디스크 읽기를 더 해야 한다.    

<br />     

**예제 2) 다음은 birth_date 칼럼은 빼고 first_name 칼럼만 SELECT하는 쿼리를 생각해보자.**    
이 쿼리도 인덱스 레인지 스캔을 이용해 처리된다고 가정한다.   
```
SELECT first_name
FROM employees WHERE first_name BETWEEN 'Babette' AND 'Gad';
```

위 쿼리는 first_name 칼럼만 있으면 이 쿼리는 모두 처리되는 것이다.       
그래서 첫 번째 예제 쿼리의 두 작업 중 1번 과정만 실행하면 된다.      
필요한 칼럼이 모두 인덱스에 있으므로 나머지 칼럼이 저장된 데이터 파일을 읽어 올 필요가 없다.       
이 쿼리는 디스크에서 4~5개의 페이지만 읽으면 되기 때문에 매우 빠른 속도로 처리된다.     


두 번째 예제와 같이 인덱스만으로 쿼리를 수행할 수 있을 때 `Using index` 메시지가 Extra 칼럼에 표시된다.    
이렇게 인덱스만으로 처리되는 것을 커버링 인덱스라고 한다.    
인덱스 레인지 스캔을 사용하지만 쿼리의 성능이 만족스럽지 못한 경우라면 인덱스에 있는 칼럼만 사용하도록 쿼리를 변경해 큰 성능 향상을 볼 수 있다.      

InnoDB의 모든 테이블은 클러스터링 인덱스로 구성돼 있다. 
그리고 이 때문에 InnoDB 테이블의 모든 보조 인덱스는 데이터 레코드의 주소 값으로 프라이머리 키 값을 가진다.       
InnoDB 테이블에서 first_name 칼럼만으로 인덱스를 만들어도 결국 그 인덱스에 emp_no 칼럼이 같이 저장되는 효과를 낸다.    
이러한 클러스터링 인덱스 특성 때문에 쿼리가 커버링 인덱스로 처리될 가능성이 상당히 높다.    

<br />      

**예제 3) 다음 쿼리도 인덱스 레인지로 처리된다고 가정하자.**   
```
SELECT emp_no, first_name
FROM employees WHERE first_name BETWEEN 'Babette' AND 'Gad';
```

이 쿼리에도 첫 번째나 두 번째 예제처럼 같은 WHERE 조건이 지정돼 있어서 first_name 칼럼의 인덱스를 이용해 일치하는 레코드를 검색할 것이다.       
그런데 두 번째 예제와는 달리 emp_no을 더 가져와야 한다.     
하지만 emp_no은 employees 테이블의 프라이머리 키이기 때문에 이미 인덱스에 포함돼 있어 데이터 파일을 읽지 않아도 된다.       
즉 InnoDB의 보조 인덱스에는 데이터 레코드를 찾아가기 위한 주소로 사용하기 위해 프라이머리 키를 저장해두는 것이지만     
더불어 추가 칼럼을 하나 더 가지는 인덱스의 효과를 얻을 수 있게 되는 것이다.      

레코드 건수에 따라 차이는 있겠지만 쿼리를 커버링 인덱스로 처리할 수 있을 때와 그렇지 못할 때의 성능 차이는 수십 배에서 수백 배까지 날 수 있다.     
하지만 무조건 커버링 인덱스로 처리하려고 인덱스에 많은 칼럼을 추가하면 더 위험한 상황이 초래될 수도 있다.    
너무 과도하게 인덱스의 칼럼이 많아지면 인덱스의 크기가 커져서 메모리 낭비가 심해지고 레코드를 저장하거나 변경하는 작업이 매우 느려질 수 있기 때문이다.          

<br />      

### Using index for group-by        
GROUP BY 처리를 위해 MySQL 서버는 그룹핑 기준 칼럼을 이용해 정렬 작업을 수행하고 다시 정렬된 결과를 그룹핑하는 형태의 고부하 작업을 필요로 한다.      
하지만 GROUP BY 처리가 인덱스(B-Tree 인덱스에 한해)를 이용하면 정렬된 인덱스 칼럼을 순서대로 읽으면서 그룹핑 작업만 수행한다.     
이렇게 GROUP BY 처리에 인덱스를 이용하면 레코드의 정렬이 필요하지 않고 인덱스의 필요한 부분만 읽으면 되기 때문에 상당히 효율적이고 빠르게 처리된다.    
GROUP BY 처리가 인덱스를 이용할 때 쿼리의 실행 계획에서는 Extra 칼럼에 이 메시지가 표시된다.    

GROUP BY 처리를 위해 인덱스를 읽는 방법을 "루스 인덱스 스캔"이라고 한다.    
<br />         

**- 타이트 인덱스 스캔(인덱스 스캔)을 통한 GROUP BY 처리**  
인덱스를 이용해 GROUP BY 절을 처리할 수 있더라도 `AVG()`나 `SUM()` 또는 `COUNT(*)`와 같이     
조회하려는 값이 모든 인덱스를 다 읽어야 할 때는 필요한 레코드만 듬성듬성 읽을 수가 없다.          
이런 경우에는 이 메시지가 출력되지 않는다.    
<br />       

**- 루스 인덱스 스캔을 통한 GROUP BY 처리**      
단일 칼럼으로 구성된 인덱스에서는 그룹핑 칼럼 말고는 아무것도 조회하지 않는 쿼리에서 루스 인덱스 스캔을 사용할 수 있다.      
그리고 다중 칼럼으로 만들어진 인덱스에서는 GROUP BY 절이 인덱스를 사용할 수 있어야 하고 `MIN()`이나 `MAX()`와 같이         
조회하는 값이 인덱스의 첫 번째 또는 마지막 레코드만 읽어도 되는 쿼리는 "루스 인덱스 스캔"이 사용될 수 있다.        
이때는 인덱스를 듬성듬성하게 필요한 부분만 읽는다.    
<br />      

GROUP BY에서 인덱스를 사용하려면 우선 GROUP BY 조건의 인덱스 사용 요건이 갖춰져야 한다.     
WHERE 절에서 사용하는 인덱스에 의해서도 사용 여부가 영향을 받는다.   

**- WHERE 조건절이 없는 경우**     
WHERE 절의 조건이 전혀 없는 쿼리는 GROUP BY와 조회하는 칼럼이 "루스 인덱스 스캔"을 사용할 수 있는 조건만 갖추면 된다.   
그렇지 못한 쿼리는 타이트 인덱스 스캔이나 별도의 정렬 과정을 통해 처리된다.     

**- WHERE 조건절이 있지만 검색을 위한 인덱스를 사용하지 못하는 경우**    
GROUP BY 절은 인덱스를 사용할 수 있지만 WHERE 조건절이 인덱스를 사용하지 못할 때는 먼저 GROUP BY를 위해 인덱스를 읽은 후,    
WHERE 조건의 비교를 위해 데이터 레코드를 읽어야만 한다.   
그래서 이 경우도 "루스 인덱스 스캔"을 이용할 수 없으며 타이트 인덱스 스캔 과정을 통해 GROUP BY가 처리된다.     

다음 쿼리는 WHERE 절은 인덱스를 사용하지 못하지만 GROUP BY가 인덱스를 사용하는 예제다.   
```
EXPLAIN
SELECT first_name FROM employees 
WHERE birth_date > '1994-01-01' GROUP BY first_name;
```

**- WHERE 절의 조건이 있으며, 검색을 위해 인덱스를 사용하는 경우**    
하나의 단위 쿼리가 실행되는 경우에 index_merge 이외의 접근 방법에서는 단 하나의 인덱스만 사용할 수 있다.      
그래서 WHERE 절의 조건이 인덱스를 사용할 수 있으며 GROUP BY가 인덱스를 사용할 수 있는 조건이 더 까다로워진다.    
즉 WHERE 절의 조건이 검색하는 데 사용했던 인덱스를 GROUP BY 처리가 다시 사용할 수 있을 때만 루스 인덱스 스캔을 사용할 수 있다.   
만약 WHERE 조건절이 사용할 수 있는 인덱스와 GROUP BY 절이 사용할 수 있는 인덱스가 다른 경우라면          
일반적으로 옵티마이저는 WHERE 조건절이 인덱스를 사용하도록 실행 계획을 수립하는 경향이 있다.       
때로는 전혀 작업 범위를 좁히지 못하는 WHERE 조건이라 하더라도 GROUP BY보다는 WHERE 조건이 먼저 인덱스를 사용할 수 있게 실행 계획이 수립된다.    

```
EXPLAIN 
SELECT emp_no 
FROM salaries WHERE emp_no BETWEEN 10001 AND 200000
GROUP BY emp_no;
```

위 쿼리의 경우 Extra에 `Using where`과 `Using index for group-by`가 출력된다.


> 루스 인덱스 스캔은 DISTINCT나 GROUP BY가 포함된 쿼리에서 최적의 튜닝 방법이다.           

<br />        

### Using join buffer (MySQL 5.1부터)       
일반적으로 빠른 쿼리 실행을 위해 조인이 되는 칼럼은 인덱스를 생성한다.   
실제로 조인이 필요한 인덱스는 조인되는 양쪽 테이블 칼럼 모두가 필요한 것이 아니라 조인에서 뒤에 읽는 테이블의 칼럼에만 필요하다.    
옵티마이저도 조인되는 두 테이블에 있는 각 칼럼에서 인덱스를 조사하고, **인덱스가 없는 테이블이 있으면 그 테이블을 먼저 읽어서** 조인을 실행한다.   
**뒤에 읽는 테이블은 검색 위주로 사용**되기 때문에 인덱스가 없으면 성능에 미치는 영향이 매우 크기 때문이다.    

> 먼저 읽는 테이블을 드라이빙(Driving) 테이블이라 하고
> 뒤에 읽히는 테이블을 드리븐(Driven) 테이블이라고 한다.  
 
조인이 수행될 때 드리븐 테이블의 조인 칼럼에 적절한 인덱스가 있디면 아무런 문제가 되지 않는다.      
하지만 드리븐 테이블에 검색을 위한 적절한 인덱스가 없다면 드라이빙 테이블로부터     
읽은 레코드의 건수만큼 매번 드리븐 테이블을 풀 테이블 스캔이나 인덱스 풀 스캔해야 할 것이다.       

이때 드리븐 테이블의 비효율적인 검색을 보완하기 위해 MySQL 서버는 드라이빙 테이블에서 읽은 레코드를 임시 공간에 보관해두고   
필요할 때 재사용할 수 있게 해준다. > 이 메모리 공간을 조인 버퍼라고 한다.   
조인 버퍼가 사용되는 실행 계획의 Extra 칼럼에 `Using join buffer` 메시지가 표시된다.         

다음 쿼리는 조인 조건이 없는 카테시안 조인을 수행하는 쿼리다.   
이런 카테시안 조인을 수행하는 쿼리는 항상 조인 버퍼를 사용한다.    
```
EXPLAIN 
SELECT * 
FROM dept_emp de, employees e
WHERE de.from_date > '2005-01-01' AND e.emp_no < 10904;
```

<br />      

### Using sort_union(...), Using union(...), Using intersect(...)   
쿼리가 Index_merge 접근 방식(실행 계획의 type 칼럼이 index_merge)으로 실행되는 경우에 2개 이상의 인덱스가 동시에 사용될 수 있다.    
두 인덱스로부터 읽은 결과를 어떻게 병합했는지 조금 더 상세하게 설명하기 위해 다음 3개 중에서 하나의 메시지를 출력한다.      

1. Using sort_union(...)    
각각의 인덱스를 사용할 수 있는 조건이 AND로 연결된 경우 각 처리 결과에서 교집합을 추출해내는 작업을 수행했다는 의미    
<br />     
2. Using union(...)      
각 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우 각 처리 결과에서 합집합을 추출해내는 작업을 수행했다는 의미    
<br />    
3. Using intersect(...)    
Using union과 같은 작업을 수행하지만 Using union으로 처리될 수 없는 경우(OR로 연결된 상대적으로 대량의 range 조건)이 방식으로 처리된다.      
Using sort_union과 Using union의 차이는     
Using sort_union은 프라이머리 키만 먼저 읽어서 정렬하고 병합한 후 비로소 레코드를 읽어서 반환할 수 있다는 것이다.    
<br />        
   
Using union()과 Using sort_union()은 둘 다 충분히 인덱스를 사용할 수 있는 조건이 OR로 연결된 경우에 사용된다.  
Using union()은 대체로 동등 비교처럼 일치하는 레코드 건수가 많지 않을 때 사용   
각 조건이 작다 또는 크가와 같이 상대적으로 많은 레코드에 일치하는 조건이 사용되는 경우 Using sort_union()이 사용된다.   
하지만 실제로 레코드 건수에 거의 관계없이 각 WHERE 조건에 사용되는 비교 조건이 동등 조건이면 Using union() 사용,   
그렇지 않으면 Using sort_union()이 사용된다.    


<br />      

### Using temporary      
MySQL이 쿼리를 처리하는 동안 중간 결과를 담아 두기 위해 임시 테이블(Temporary table)을 사용한다.      
임시 테이블은 메모리상에 생성될 수도 있고 디스크상에 생성될 수도 있다.      
이 메시지가 표시되면 임시 테이블을 사용한 것인데 이때 사용된 임시 테이블이 메모리에 생성되었는지 디스크에 생성되었는지는 실행 계획만으로 판단할 수 없다.          

인덱스를 사용하지 못하는 GROUP BY 쿼리는 실행 계획에서 "Using temporary" 메시지가 표시되는 대표적인 형태의 쿼리다.   


<br />      

### Using where     
MySQL은 내부적으로 크게 MySQL 엔진과 스토리지 엔진이라는 두 개의 레이어로 나눠서 볼 수 있다.    
MySQL 엔진 레이어에서 별도의 가공을 해서 필터링 작업을 거쳐 처리한 경우 이 메시지가 표시된다.       

```
EXPLAIN 
SELECT * FROM employees 
WHERE emp_no BETWEEN 10001 AND 10100 AND gender='F';
```

위 쿼리에서 작업 범위 제한 조건은 `emp_no BETWEEN 10001 AND 10100`이고   
`gender='F'`은 체크 조건임을 쉽게 알 수 있다.    
그런데 emp_no을 만족하는 레코드 건수는 100건이지만 두 조건을 모두 만족하는 레코드는 37건이라고 가정해보자.    
이는 스토리지 엔진은 100개를 읽어서 MySQL 엔진에 넘겨줬지만 MySQL 엔진은 그중에서 63건의 레코드는 그냥 필터링해서 버렸다는 의미다.    
여기서 "Using where"은 63건의 레코드를 버리는 처리를 의미한다.    

MySQL 5.1부터는 실행 계획에 Filtered 칼럼이 함께 표시되어 "Using where"이 성능상의 이슈가 있는지 없는지 알아낼 수 있다.     

> 위의 쿼리를 통해 인덱스 최적화를 좀 더 알아보자.   
> 위 처리 과정에서 쿼리에 일치하는 레코드는 37건밖에 안 되지만 스토리지 엔진은 100건의 레코드를 읽은 것이다.    
> 그런데 만약 employees 테이블에 (emp_no + gender)로 인덱스가 준비돼 있었다면?   
> 이때는 두 조건 모두 작업 범위의 제한 조건으로 사용되어 필요한 37개의 레코드만 정확하게 읽을 수 있다.     
> 
> ```
> CREATE TABLE tb_likefilter ( 
>   category INT, 
>   name VARCHAR(30),
>   INDEX ix_category_name(category, name)
> );
> 
> SELECT * FROM tb_likefilter WHERE category=10 AND name LIKE '%abc%';
> ```
> 위 쿼리의 경우 `name LIKE '%abc%'` 조건은 작업 범위 제한 조건으로 사용되지 못한다.   
> 이처럼 작업 범위 제한 조건으로 사용되지 못하는 조건은 스토리지 엔진에서 인덱스를 통해 체크되는 것이 아니라 MySQL 엔진에서 처리된다.    
> 즉 스토리지 엔진에서 `category=10`을 만족하는 모든 레코드를 읽어서 MySQL 엔진으로 넘겨주고   
> MySQL 엔진에서 LIKE 조건 체크를 수행해서 일치하지 않는 레코드는 버리는 것이다.   
> 
> MySQL 5.1의 InnoDB 플러그인 버전부터는 이원화된 구조의 불합리를 제거하기 위해   
> WHERE 절의 범위 제한 조건뿐 아니라 체크 조건까지 모두 스토리지 엔진으로 전달된다.      
> 스토리지 엔진에서 그 조건에 정확히 일치하는 레코드만 읽고 MySQL 엔진으로 전달하기 때문에 이런 비효율적인 부분이 사라진 것이다.   
> 즉 MySQL 5.1부터는 위 시나리오에서 스토리지 엔지이 꼭 필요한 레코드만 읽게 되는 것이다.   
> MySQL에서 이러한 기능을 "Condition push down" 이라고 표현한다.   


<br />      

### Using where with pushed condition   
이 메시지는 "Condition push down"이 적용됐음을 의미하는 메시지다.    
MySQL 5.1부터 InnoDB나 MyISAM 스토리지 엔진에도 도입되어 각 스토리지 엔진의 비효율이 상당히 개선됐다고 볼 수 있다.   

하지만 InnoDB나 MyISAM 스토리지 엔진을 사용하는 테이블에서는 이 메시지가 뜨지 않는다.    
이 메시지는 NDB 클러스터 스토리지 엔진을 사용하는 테이블에만 표시되는 메시지다.   
NDB 클러스터는 네트워크를 통해 MySQL 엔진으로 레코드가 전달된다.   
그래서 실제 "Condition push down"이 사용되지 못하면 상당한 성능 저하가 발생할 수 있다.    

<br />      

</div>
</details>     

<br />      


## 2.11 EXPLAIN EXTENDED(Filtered 칼럼)       
필터링이 얼마나 효율적으로 실행됐는지를 사용자에게 알려주기 위해 Filtered 칼럼이 새로 추가되었다.    
실행 계획에서 Filtered 칼럼을 함께 조회하려면 `EXPLAIN EXTENDED` 명령을 사용하면 된다.   

MySQL 엔진에 의해 필터링되어 제거된 레코드는 제외하고 최종적으로 레코드가 얼마나 남았는지의 비율이 표시된다.      
예를들어 Filtered 칼럼에 20이 출력되면 20%만 남았다는 것을 의미한다.   
실제 값이 아니라 단순히 통계 정보로부터 예측된 값이다.    

<br />  

## 2.12 EXPLAIN EXTENDED(추가 옵티마이저 정보)    
EXPLAIN 명령의 EXTENDED 옵션은 숨은 기능이 하나 더 있다.  
MySQL 엔진에서 쿼리의 실행 계획을 산출하기 위해 쿼리 문장을 분석해 파스 트리를 생성한다.    
또한 일부 최적화 작업도 이 파스 트리를 이용해 수행한다.   

또 다른 기능은 분석된 파스 트리를 재조합해서 쿼리 문장과 비슷한 순서대로 나열해서 보여주는 것이다.   
EXPLAIN EXTENDED 명령을 이용해 옵티마이저가 쿼리를 어떻게 해석하고 어떻게 쿼리를 변환했으며   
어떤 특수한 처리가 추가되었는지 등을 판단할 수 있다.   

<br />  

## 2.13 EXPLAIN PARTITIONS(Partitions 칼럼)    
이 옵션으로 파티션 테이블의 실행 계획 정보도 자세히 확인할 수 있다.     
EXTENDED 옵션과 함께 사용할 수 없다.   

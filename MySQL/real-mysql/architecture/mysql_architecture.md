# MySQL 아키텍처      

쿼리를 작성하고 튜닝할 때 필요한 기본적인 구조에 대해서 알아보자.   


## MySQL의 전체 구조    

![스크린샷 2021-01-12 오전 12 20 44](https://user-images.githubusercontent.com/33855307/104200470-0e6a9800-546c-11eb-9aa0-cdc3a0db6534.png)     
<br />          


* MySQL 엔진           
SQL 문장을 분석하거나 최적화하는 역할            
<br />    
  
* 스토리지 엔진   
실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 역할               
<br />    
  
* 핸들러 API   
MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 요청을 하는데,               
이러한 요청을 **핸들러 요청**이라고 하며 여기서 사용되는 API를 **핸들러 API**라고 한다.               

<br />             

## MySQL 스레딩 구조      

![스크린샷 2021-01-12 오전 12 37 18](https://user-images.githubusercontent.com/33855307/104202502-58ed1400-546e-11eb-9b1a-ce3f749fcf75.png)     

MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.      


* 포그라운드 스레드 (클라이언트 스레드, 사용자 스레드)     
포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재하며, 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리하는 것이 임무다.     
데이터를 MySQL의 데이터가 버퍼나 캐시로부터 가져오며 버퍼나 캐시에 없는 경우 직접 디스크의 데이터나 인덱스 파일에서 읽어와서 작업한다.    
    - MyISAM 테이블: 디스크 쓰기 작업까지 포그라운드 스레드가 처리   
    - InnoDB 테이블: 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리한다.       
<br />     
      
* 백드라운드 스레드       
MyISAM은 해당 없음. InnoDB는 여러 가지 작업이 백그라운드로 처리된다.          
그 중에서 중요한 역할은 로그 스레드와 쓰기 스레드(버퍼 데이터를 디스크로 내려쓰는 작업)이다.           
<br />        

SQL 처리 도중 데이터의 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.       
- InnoDB : 쓰기 작업을 버퍼링해서 일괄 처리하는 기능 탑재                  
  INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우, 데이터가 디스크의 데이터 파일로 완전히 저장될 때까지 기다리지 않아도 된다.       
- MyISAM : 사용자 스레드(포그라운드 스레드)가 쓰기 작업까지 함께 처리          
  일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.          

<br />        

## 메모리 할당 및 사용 구조    
MySQL에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.         
둘의 차이는 **MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용하는지 아닌지**에 따라 구분된다.     
<br />       

![스크린샷 2021-01-12 오전 12 48 51](https://user-images.githubusercontent.com/33855307/104203856-f4cb4f80-546f-11eb-8282-c57a121ed080.png)    
<br />           


* 글로벌 메모리 영역     
  - MySQL 서버 시작 시 무조건 운영체제로부터 할당     
  - 클라이언트 스레드 수의 무관, 일반적으로 하나의 메모리 공간 할당       
  - 생성된 글로벌 영역이 N개라도 모든 스레드에 의해 공유됨      
<br />        
    
* 로컬 메모리 영역 (세션 메모리 영역, 클라이언트 메모리 영역)
  - 클라이언트가 MySQL 서버에 접속하면 요청 처리를 위해 스레드를 하나씩 할당하는데 클라이언트 스레드가 사용하는 메모리 공간이다.          
  - 각 클라이언트 스레드가 족립적이고 절대 공유되어 사용되지 않음                
  - 각 쿼리의 용도별로 필요할 때만 공간이 할당, 필요하지 않은 경우 MySQL이 메모리 공간을 할당하지 않을 수 있음           

<br />       


## 플러그인 스토리지 엔진 모델             
기본적으로 제공되는 스토리지 엔진 이외에 부가적인 기능을 더 제공하는 스토리지 엔진이나 플러그인 형태로 개발해서 사용할 수 있다.     
  
MySQL에서 쿼리가 실행되는 과정을 크게 다음과 같이 나눈다면 거의 대부분의 작업이 MySQL 엔진에서 처리되고,   
마지막 **데이터 읽기/쓰기** 작업만 스토리지 엔진에 의해 처리된다.     
MySQL 엔진은 스토리지 엔진을 조정하기 위해(데이터를 읽고 쓰는 명령을 위해) 핸드러를 사용한다.               

```
SQL 파서 ↔ SQL 옵티마이저 ↔ SQL 실행기 ↔ 데이터 읽기/쓰기 ↔ 디스크 스토리지
<------------------------------->  
      MySQL 엔진의 처리 영역        
```

* MySQL에서 어떤 스토리지 엔진을 사용하더라도 **데이터 읽기/쓰기** 영역의 처리만 차이가 있음      
* 실질적인 GROUP BY나 ORDER BY 등 많은 복잡한 처리는 MySQL 엔진의 처리 영역인 쿼리 실행기에서 처리됨        

여기서 중요한 것은 하나의 쿼리 작업은 여러 하위 작업으로 나뉘는데, 각 하위 작업이 MySQL 엔진 영역에서 처리되는지 아니면     
스토리지 엔진 영역에서 처리되는지 구분할 줄 알아야 한다. 즉, 단위 작업을 추가 처리하고 MySQL 엔진 영역과 스토리지 엔진 영역의 차이를 알아야 한다.   
<br />       

MySQL 서버에서 지원되는 스토리지 엔진은 다음과 같다.      

```
mysql> SHOW ENGINES;
```

![스크린샷 2021-01-12 오후 9 38 45](https://user-images.githubusercontent.com/33855307/104315622-95784880-551e-11eb-8352-bb8a950911a2.png)    

Support 칼럼에 표시될 수 있는 값은 다음과 같다.    

* YES  
MySQL 서버에 해당 스토리지 엔진이 포함돼 있고, 사용 가능으로 활성화된 상태    

* DEFAULT   
YES와 동일한 상태이지만 필수 스토리지 엔진임을 의미  
(이 스토리지 엔진이 없으면 MySQL이 시작되지 않을 수도 있음을 의미)  

* NO
현재 MySQL 서버에 포함되지 않았음을 의미   

* DISABLED    
현재 MySQL 서버에는 포함됐지만 파라미터에 의해 비활성화된 상태     


  
스토리지 엔진과 플러그인의 내용은 `SHOW PLUGINS;` 명령어로 확인할 수 있다.       

<br />    

## 쿼리 실행 구조          
다음은 쿼리를 실행하는 관점에서 MySQL 구조를 간략하게 그린 것이다.    
      
![스크린샷 2021-01-12 오후 9 53 02](https://user-images.githubusercontent.com/33855307/104316941-8eead080-5520-11eb-9653-42e8de97a916.png)        

* 파서      
파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내는 작업을 한다.       
쿼리 문장의 기본 문법 오류는 이 과정에서 발견되며 사용자에게 오류 메시지를 전달한다.       
<br />   

* 전처리기      
파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다.      
<br />

* 옵티마이저     
옵티마이저란 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정하는 역할을 담당하는데   
DBMS의 두뇌에 해당한다고 볼 수 있다.   
<br />

* 실행 엔진            
실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행한다.
    - 옵티마이저: 회사의 경영진         
    - 실행 엔진: 중간 관리자          
    - 핸들러: 각 업무의 실무자    
<br />

* 핸들러 (스토리지 엔진)      
핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.     
핸들러는 결국 스토리지 엔진을 의미하며 예를들어 MyISAM 테이블을 조작하는 경우에는 핸들러가 MyISAM 스토리지 엔진이 된다.      

<br />            


## 복제(Replication)           

![스크린샷 2021-01-13 오후 11 39 19](https://user-images.githubusercontent.com/33855307/104466468-9e3d4d00-55f8-11eb-87a4-f7c8350c9fe3.png)     

복제는 2대 이상의 MySQL 서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술이다.     
일반적으로 INSERT나 UPDATE와 같은 쿼리를 이용해 데이터를 변경할 수 있는 MySQL 서버인 마스터와           
SELECT 쿼리로 데이터를 읽기만 할 수 있는 MySQL 서버인 슬레이브로 나뉜다.          
마스터는 반드시 1개이며 슬레이브는 1개 이상으로 구성될 수 있다.           
<br />   

* 마스터(Master)        
일반적으로 변경이 허용되는 서버는 마스터로 한정할 때가 많다.   
그렇게 않은 경우 복제되는 데이터의 일관성을 보장하기 어렵기 때문이다.     
마스터 서버에서 실행되는 DML, DDL 가운데 데이터의 구조나 내용을 변경하는 **모든 쿼리 문장은 바이너리 로그에 기록**한다.     
슬레이브 서버에서 변경 내역을 요청하면 마스터 장비는 그 바이너리 로그를 읽어 슬레이브로 넘긴다.      

* 슬레이브(Slave)      
데이터(바이너리 로그)를 받아 올 마스터 장비의 정보를 가지고 있는 경우 슬레이브가 된다.    
슬레이브 서버의 I/O 스레드는 마스터 서버에 접속해 변경 내역을 요청하고, **받아 온 변경 내역을 릴레이 로그에 기록한다.**            
그리고 슬레이브 서버의 **SQL 스레드가 릴레이 로그에 기록된 변경 내역을 재실행(replay)함으로써** 슬레이브의 데이터를 마스터와 동일한 상태로 유지한다.   
I/O 스레드와 SQL 스레드는 마스터 MySQL에서는 기동되지 않으며, 복제가 설정된 슬레이브 MySQL 서버에서 자동적으로 기동하는 스레드다.        
<br />     

다음은 복제를 사용할 경우의 주의 사항이다.   

* 슬레이브는 하나의 마스터만 설정 가능   
MySQL의 복제에서 하나의 슬레이브는 하나의 마스터만 가질 수 있다.    
<br />  

* 마스터와 슬레이브의 데이터 동기화를 위해 슬레이브는 읽기 전용으로 설정    
마스터와 슬레이브로 복제가 구성된 상태에서 데이터는 마스터로 접속해서 변경해야 하는데,    
일부 변경 작업이 마스터에서 실행되고 일부는 슬레이브에서 실행된다면 데이터 동기화에 상당한 노력이 필요하다.     
<br />  

* 슬레이브 서버용 장비는 마스터와 동일한 사양이 적합         
마스터 서버에서 수많은 동시 사용자가 실행한 데이터 변경 쿼리 문장이 슬레이브 서버에서는 하나의 스레드로 모두 처리돼야 한다.          
그래서 변경이 매우 잦은 MySQL 서버일수록 마스터 서버의 사양보다 슬레이브 서버의 사양이 더 좋아야             
마스터에서 동시에 여러 개의 스레드로 실행된 쿼리가 슬레이브에서 지연되지 않고 하나의 스레드로 처리될 수 있다.         
<br />  

* 복제가 불필요한 경우에는 바이너리 로그 중지            
바이너리 로그를 작성하기 위해 MySQL은 많은 자원을 소모하고 성능이 저하된다.          
바이너리 로그를 안정적으로 기록하기 위해 갭 락(Gap lock)을 유지하고,        
매번 트랜잭션이 커밋될 때마다 데이터를 변경시킨 쿼리 문장을 바이너리 로그에 기록해야 한다.           
<br />  

* 바이너리 로그와 트랜잭션 격리 수준(Isolation level)      
바이너리 로그 파일은 어떤 내용이 기록되느냐에 따라 STATEMENT 포맷 방식과 ROW 포맷 방식이 있다.    
    - STATEMENT : 바이너리 로그 파일에 마스터에서 실행되는 쿼리 문장을 기록하는 방식        
    이 방식은 마스터와 슬레이브의 데이터 일치를 위해 REPEATABLE READ 격리 수준만 사용 가능하다.             
    - ROW : 마스터에서 실행된 쿼리에 의해 변경된 레코드 값을 기록하는 방식            

>MySQL 5.0 이하는 STATEMENT 방식만 제공          
>MySQL 5.0 + STATEMENT 포맷의 바이너리 로그 + REPEATABLE READ 격리 수준 환경에서        
>INSERT INTO ... SELECT ... FROM ... 형태의 쿼리 문장을 사용할 때 주의해야 한다.   

<br />      

* 참고    
  - 문장(SQL) 기반 복제: 바이너리 로그에 SQL 문장을 기록하는 방식       
    SQL 기반 복제가 정상적으로 작동하려면 REPEATABLE-READ 이상의 트랜잭션 격리 수준을 사용해야 하며  
    그로 인해 InnoDB 테이블에서 레코드 간의 간격을 잠그는 갭 락이나 넥스트 키 락이 필요해진다.               
  - 레코드 기반 복제: 바이너리 로그에 변경된 레코드를 기록하는 방식
  반면 레코드 기반 복제는 마스터와 슬레이브 MySQL 서버 간 네트워크 트래픽을 많이 발생시킬 수는 있지만    
  READ-COMMITTED 트랜잭션 격리 수준에도 작동할 수 있으며 InnoDB 테이블에서 잠금의 경합은 줄어든다.      

<br />         

## 쿼리 캐시          
![스크린샷 2021-01-14 오전 12 11 01](https://user-images.githubusercontent.com/33855307/104470382-0130e300-55fd-11eb-9e10-42d6d43c54c4.png)     


쿼리 캐시(Query Cache)는 MySQL의 독특한 기능 중 하나로서 적절히 설정하면 상당한 성능 향상 효과를 얻을 수 있다.       

쿼리 캐시는 단어의 의미와는 달리 SQL 문장을 캐시하는 것이 아니라 쿼리의 결과를 메모리에 캐시해 두는 기능이다.       
쿼리 캐시의 구조는 간단히 키와 값의 쌍으로 관리되는 맵(Map)과 같은 데이터 구조로 구현돼 있다.         
키를 구성하는 것은 쿼리 문장 자체일 것이며, 값은 해당 쿼리 실행 결과가 될 것이다.          
<br />    

그러나 데이터베이스에서 쿼리를 처리할 때 상당히 많은 부분의 처리 절차가 있다.        
동일한 쿼리 문장이 요청됐다고 바로 캐시된 결과를 보내서는 안되고 반드시 확인 절차가 필요하다.        


Q1. 요청된 쿼리 문장이 쿼리 캐시에 존재하는가?                  
비교 방식은 요청된 쿼리 문장 자체가 동일한지 여부를 비교하는 것이기 때문에 간단하고 빠르게 진행된다.      
공백, 대소문자까지 완전히 동일해야 하기 때문에 애플리케이션 전체 쿼리 가운데 동일하거나 비슷한 작업을 하는 쿼리는   
하나의 쿼리로 통일해 문자열로 관리하는 것이 좋다.        

  
Q2. 해당 사용자가 그 결과를 볼 수 있는 권한을 가지고 있는가?          
어떤 사용자가 요청한 쿼리가 캐시에 저장돼 있더라도 이 사용자가 해당 테이블의 읽기 권한이 없다면 캐시 결과를 보여주면 안 된다.      

                    
Q3. 트랜잭션 내에서 실행된 쿼리인 경우, 그 결과가 가시 범위 내의 트랜잭션에서 만들어진 결과인가? (InnoDB의 경우)            
InnoDB의 모든 트랜잭션은 각 트랜잭션 ID를 갖게 된다.    
InnoDB에서는 트랜잭션 격리 수준을 준수하기 위해 각 트랜잭션은 자신의 ID보다 ID 값이 큰 트랜잭션에서 변경한 작업 내역이나 쿼리 결과는 참조할 수 없다.    
이를 트랜잭션의 가시 범위라고 한다. 쿼리 캐시도 그 결과를 만들어낸 트랜잭션의 ID가 가시 범위 내에 있을 때만 사용할 수 있는 것이다.    

     
Q4. 쿼리에 사용된 기능(내장 함수나 저장 함수 등)이 캐시돼도 동일한 결과를 보장하는가?                          

Q4-1. CURRENT_DATE(), SYSDATE(), RAND() 등과 같이 호출 시점에 따라 결과가 달라지는 요소가 있는가?       
SYSDATE()나 RAND() 같은 함수는 동일 사용자가 동일 쿼리를 실행하더라도 호출하는 시간에 따라 결과가 달라진다.    
CURRENT_DATE(), SYSDATE(), RAND() 뿐만 아니라     
NOT DETERMINISTIC으로 정의된 스토어드 함수 등은 사용하지 않는 편이 쿼리 캐시의 효율을 높이는 데 도움된다.      

          
Q4-2. 프리페어 스테이트먼트의 경우 변수가 결과에 영향을 미치는가?          
프리페어 스테이트먼트(바인드 변수가 사용된 쿼리)의 경우 쿼리 문장 자체에 변수("?")가 사용되기 때문에 쿼리 문장 자체로 쿼리 캐시를 찾을 수가 없다.    
MySQL 5.0까지는 프리페어 스테이트먼트로 실행된 쿼리는 쿼리 캐시를 사용할 수 없었지만 MySQL 5.1부터는 이런 제약이 없어졌다.      
    
      
Q5. 캐시가 만들어지고 난 이후 해당 데이터가 다른 사용자에 의해 변경되지 않았는가?          
쿼리 결과가 캐시에 저장된 이후 데이터가 변경되면 어떻게 될까?      
이미 변경된 데이터를 캐시하는 것은 의미가 없기 때문에 데이터 제거(무효화, Invalidation)해야 한다.   
쿼리 캐시는 빠른 처리를 위해 아주 단순하게 작동하도록 설계돼 있다. 따라서 쿼리 캐시에 있는 데이터를 무효화하는 작업은 테이블 단위로 처리된다.   

만약 쿼리 캐시를 1GB로 아주 크게 설정하고 쿼리 캐시를 꽉 채웠다고 가정하자.   
해당 테이블에 레코드 하나를 INSERT하면 MySQL 서버는 캐시에 채워져 있는 1GB의 내용을 모두 제거해야 한다.   
이 작업만으로도 상당한 시간이 소모될 것이다.     
쿼리 캐시를 위한 메모리 공간이 크다고 무조건 좋은 것이 아니며 적절한 크기 이상으로 설정할 경우 캐시 자체가 부하의 원인이 될 가능성도 있다.   

       
Q6. 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가?                        
쿼리 캐시의 크기를 64MB로 설정했는데 만약 어떤 쿼리 하나가 60MB 정도의 쿼리 결과를 만들어내면 하나의 쿼리 때문에 쿼리 캐시를 다 소모해 버릴 수 있다.    
이러한 현상을 방지하고자 특정 크기 미만의 쿼리 결과만 캐시하도록 설정하는 시스템 파라미터가 있다.   
 
 
Q7. 그 밖에 쿼리 캐시를 사용하지 못하게 만드는 요소가 사용됐는가?                            
* 임시 테이블(Tempoary table)에 대한 쿼리                              
* 사용자 변수의 사용                   
* 칼럼 기반의 권한 설정                   
* LOCK IN SHARE MODE 힌트                  
SELECT 문장의 끝에 붙여서 조회하는 레코드에 공유 잠금을 설정하는 쿼리                  
* FOR UPDATE 힌트                
SELECT 문장의 끝에 붙여서 조회하는 레코드에 배타적 잠금을 설정하는 쿼리                  
* UDF(User Defined Function)의 사용                  
* 독립적인 SELECT 문자이 아닌 일부분의 서브 쿼리                  
* 스토어드 루틴에서 사용된 쿼리                   
* SQL_NO_CACHE 힌트                  
SELECT 문장에서 SELECT 키워드 뒤에 붙이는 힌트                 
이 힌트가 사용되면 쿼리 캐시를 사용하지 않는다.                
<br />    


> * 참고    
> 게시판 테이블에 조회수를 함께 저장하면 SELECT 실행하기전 UPDATE로 조회수를 증가시킨다.   
> 이 경우 쿼리 캐시를 저장하고 삭제하는 오버헤드만 추가하는 꼴이 돼버리는 것이다.   
> UPDATE, SELECT 순서를 바꿔도 마찬가지다.    
> 테이블을 분리하거나 조회수를 일정한 횟수만큼 누적한 후 한꺼번에 업데이터하는 편이 좋다.

<br />      

## MySQL 로그 파일   

MySQL은 다른 상용 DBMS와 비교하면 DBA나 개발자를 위한 진단 도구가 상당히 부족한 편이다.   
그렇지만 로그 파일을 이용하면 MySQL의 상태나 부하를 일으키는 원인을 찾아서 해결할 수 있다.   
<br />                    

#### 에러 로그 파일     
MySQL이 실행되는 도중에 발생하는 에러나 경고 메시지가 출력되는 로그 파일이다.     
MySQL 컨피큐레이션 파일에 "log_error" 이름의 파라미터에 정의된 경로에 있는 파일이거나    
별도로 정의되지 않은 경우 데이터 디렉토리에 ".err"이라는 확장자가 붙은 파일이다.   

다음과 같은 메시지가 자주 보일 것이다.     
* MySQL이 시작하는 과정과 관련된 정보성 및 에러 메시지                   
* 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지                     
* 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지                     
* 비정상적으로 종료된 커넥션 메시지                   
* InnoDB의 모니터링 명령이나 상태 조회 명령의 결과 메시지                   
* MySQL의 종료 메시지                             
<br />                    

#### 제너럴 쿼리 로그 파일(제너럴 로그 파일, General log)      
가끔 MySQL 서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아서 검토해 볼 때가 있는데,     
이때는 쿼리 로그를 활성화해서 쿼리를 쿼리 로그 파일로 기록한 다음 그 파일을 검토하면 된다.      
슬로우 쿼리와는 조금 다르게 제너럴 쿼리 로그는 실행되기 전에 MySQL이 쿼리 요청을 받으면   
바로 기록하기 때문에 쿼리 실행 중에 에러가 발생해도 일단 로그 파일에 기록된다.     
<br />                    

#### 슬로우 쿼리 로그   
MySQL 서버의 쿼리 튜닝은 두 가지 경우로 나뉠 수 있다.   

* 서비스가 적용되기 전에 전체적으로 튜닝          
검토해야 할 대상 쿼리가 전부라서 모두 튜닝하면 된다.       

* 서비스 운영 중에 MySQL 서버의 전체적인 성능 저하를 검사    
어떤 쿼리가 문제의 쿼리인지 판단하기 상당히 어렵다.       
이런 경우에 서비스에서 사용되고 있는 쿼리 중에서 어떤 쿼리가 문제인지를 판단하는 데 슬로우 쿼리 로그가 많은 도움이 된다.       
<br />                    

#### 바이너리 로그와 릴레이 로그   
바이너리 로그 파일은 마스터 MySQL 서버에 생성되고 릴레이 로그는 슬레이브 MySQL 서버에 생성되는 것 말고는    
바이너리 로그와 릴레이 로그 파일의 내용이나 포맷은 동일하다.       
바이너리 로그에는 순수한 SELECT 문장과 같이 데이터의 구조나 내용을 변경하지 않는 쿼리는 기록되지 않는다.   
<br />                    



## MyISAM 스토리지 엔진 아키텍처    

MyISAM 스토리지 엔진의 성능에 영향을 미치는 요소인 키 캐시와 운영체제의 캐시/버퍼에 대해 알아보자.   

<br />    

![스크린샷 2021-01-15 오전 12 10 29](https://user-images.githubusercontent.com/33855307/104609165-1aea2d00-56c6-11eb-9e0b-91d63542d70b.png)     

<br />    

#### 키 캐시    
InnoDB의 버퍼 풀과 비슷한 역할을 하는 것이 MyISAM의 키 캐시(key cache, 키 버퍼라고도 불림)다.   
하지만 이름대로 MyISAM 키 캐시는 인덱스만 대상으로 작동하며 인덱스의 디스크 쓰기 작업에 대해서만 부분적으로 버퍼링 역할을 한다.   

<br />         

#### 운영체제의 캐시 및 버퍼                
MyISAM 테이블의 인덱스는 키 캐시를 이용해 디스크를 검색하지 않고도 충분히 빠르게 검색할 수 있다.     
하지만 MyISAM 테이블의 데이터는 디스크로부터의 I/O를 해결해 줄 만한 어떠한 캐시나 버퍼링 기능이 MyISAM 엔진에는 없기 때문에      
MyISAM 테이블의 데이터 읽기나 쓰기 작업은 항상 운영체제의 디스크 읽기 또는 쓰기 작업으로 요청될 수밖에 없다.          
대부분의 운영체제는 디스크로부터 읽고 쓰는 파일에 대한 캐시나 버퍼링 매커니즘을 갖고 있기 때문에     
MySQL 서버가 요청하는 디스크 읽기 작업을 위해 매번 디스크의 파일을 읽지는 않는다.         

운영체제의 캐시 공간은 남는 메모리를 사용하는 것이 기본 원칙이다.     
MySQL이나 다른 애플리케이션에서 메모리를 모두 사용해버리면 운영체제가 캐시 용도로 사용할 수 있는 메모리 공간이 없어져 버린다.      
이런경우 MyISAM 테이블의 데이터를 캐시하지 못하게 되며, MyISAM 테이블에 대한 쿼리 처리가 느려진다.    
데이터베이스가 MyISAM 테이블을 주로 사용하고 있다면 운영체제가 사용할 수 있는 캐시 공간을 위해 충분한 메모리를 비워둬야 이러한 문제를 방지할 수 있다.     
(최대 물리 메모리의 40% 이상을 넘지 않게 설정)           
 
<br />     


## MEMORY 스토리지 엔진 아키텍처       
MEMORY 스토리지 엔진은 HEAP 스토리지 엔진이라고도 하는데, 이름 그대로 데이터를 메모리에 저장하는 것이 특징이다.              
MEMORY 스토리지 엔진은 데이터의 크기가 작고 아주 빠른 처리가 필요한 경우에만 적합한 스토리지 엔진이다.           
<br />   
#### MEMORY 스토리지 엔진을 사용할 경우 주의사항         

* 테이블의 최대 크기   
MEMORY 스토리지 엔진을 사용하는 테이블은 저장할 수 있는 데이터의 최대 용량이 정해져 있다.       
<br />       

* 고정 길이 칼럼만 지원   
모든 칼럼은 항상 고정 길이로만 생성된다.      
불필요하게 너무 큰 데이터 타입을 사용하지 않는 것이 좋고 가능하면 칼럼의 크기는 최소한으로 결정하는 것이 메모리 공간을 절약하는 데 많은 도움이 된다.   
<br />    

* BLOB이나 TEXT와 같은 LOB(Large Object) 타입은 지원하지 않음
<br />    

* MEMORY 테이블은 기본적으로 해시 인덱스 사용   
InnoDB나 MyISAM 테이블을 생성할 때 별다른 내용을 명시하지 않고 인덱스를 생성하면 기본적으로 B-Tree 인덱스가 생성되지만     
MEMORY 스토리지 엔진을 사용하는 테이블은 해시 인덱스를 사용한다.    

<br />        

#### MEMORY 스토리지 엔진의 용도   
사용자가 명시적으로 MEMORY 테이블을 정의해서 사용하는 경우도 있지만, MEMORY 테이블은 MySQL 엔진이 쿼리를 처리하는 과정에서     
임시로 생성되는 임시 테이블 용도로 더 자주 사용된다.   
임시 테이블의 특징은 해당 커넥션에서만 유효하다는 점이다.    

<br />   

## NDB 클러스터 스토리지 엔진      
NDB 클러스터는 다른 스토리지 엔진과는 작동 방식이나 용도가 많이 다르다.   
"Network DataBase" 네트워크를 통해 데이터 분산을 지원하는 스토리지 엔진이라는 의미이다.   
데이터의 분산이나 그로 인한 성능 향상보다는 가용성에 집중된 스토리지 엔진이다.   

<br />      

#### NDB 클러스터의 특성     
InnoDB나 MyISAM 같은 범용적인 스토리지 엔진과는 많은 차이가 있고 용도가 명확한 편이다.     

* 무공유(Shared-nothing) 클러스터링      
NDB 클러스터는 클러스터 그룹 내의 모든 노드가 아무것도 공우하지 않는 무공유 아키텍처로 구현돼 있다.    
데이터를 저장하는 스토리지도 분산되어 관리되기 때문에 하나의 데이터 저장소가 작동을 멈추더라도 서비스에 영향을 미치지 않는다.   
<br />  

* 메모리 기반의 스토리지 엔진        
NDB 클러스터는 메모리를 기본 데이터 스토리지로 사용한다.   
데이터의 저장소가 메모리라서 클러스터의 모든 데이터 저장소가 동시에 재시작된다면 클러스터의 모든 데이터는 사라지는 것이 당연해 보인다.     
NDB 클러스터는 주기적으로 메모리의 모든 데이터를 디스크로 내려 쓰고 있으며, InnoDB 스토리지 엔진과 같이 트랜잭션 로그를 디스크에 기록하는 식으로 작동한다.      
<br />  

* 자동화된 페일 오버(Fail-over)      
NDB 클러스터는 모든 구성 노드가 서로의 상태를 계속 체크하고 있기 때문에   
특정 노드에 문제가 발생해도 다른 사용 가능한 노드가 그 역할을 이어받는 형태로 페일 오버가 가능하다.      
<br />  

* 분산된 데이터 저장소간의 동기 방식(Sync) 복제   
NDB 클러스터에서 데이터 저장소는 분산되어 관리되는데, 각 데이터 저장소는 전체 데이터를 N등분해서 자신이 전담하는 파티션(프라이머리 파티션)과    
백업으로 보조 파티션(세컨드리 파티션)을 구성한다.     
각 데이터 저장소는 분산된 서로의 데이터를 동기화해야 하는데 NDB 클러스터는 비동기 방식이 아닌 동기 방식으로 서로의 데이터를 전달한다.   
<br />  

* 온라인 스키마 변경   
NDB 클러스터에서는 테이블에 칼럼이나 인덱스를 추가하면서 동시에 INSERT나 UPDATE와 같은 DML 쿼리를 처리할 수 있다. 이를 온라인 스키마 변경이라고 한다.     
스키마 변경으로 서비스를 멈춰야 한다는 것은 가용성을 저해하는 요소이며, NDB 클러스터에서 온라인 스키마 변경은 기본 요건이라고 볼 수 있다.   
<br />  

* NoSQL(MySQL과의 독립성)
NDB 클러스터는 NoSQL의 원조라고 볼 수 있다. NDB 클러스터는 MySQL과는 별도로 작동하는 데이터 저장소다.       
이는 MySQL 서버가 없어도 다른 NoSQL 도구와 같이 NDB 클러스터를 사용할 수 있다는 것을 의미한다.           
지금 사용되는 NoSQL 도구는 RDBMS와 같은 엄격한 트랜잭션을 지원하지 않는다.   
하지만 NDB 클러스터는 대부분의 NoSQL 기능을 지원하면서 트랜잭션에 레코드 기반의 잠금까지 제공하는데, 이는 NDB 클러스터의 큰 장점이라고 볼 수 있다.    
<br />  

* 네트워크 DB  
NDB 클러스터는 내부적으로 데이터를 저장하고 읽기 위해 네트워크를 기반으로 작동한다.     
이는 하나의 서버에 모든 처리가 일어나는 MyISAM이나 InnoDB 스토리지 엔진과는 상당히 다른 개념이다.      

<br />     

#### NDB 클러스터의 아키텍처      

**NDB 클러스터 노드의 종류**         
NDB 클러스터는 관리 노드와 데이터노드, 그리고 SQL 노드로 구성되는데 각 노드는 SPoF 방지하기 위해 모두 이중화될 수 있도록 구현돼 있다.   
일반적으로 각 노드는 하나의 물리적인 장비로 매핑되지만 반드시 그래야 하는 것은 아니다.    
여기서 말하는 노드는 하나의 프로세스로 매핑해서 이해하면 된다.   
<br />

* 관리 노드(Management node)        
관리 노드는 실제 NDB 클러스터가 정상 상태에서 서비스되는 도중에는 거의 하는 일이 없다.     
관리 노드는 NDB 클러스터의 전체적인 구조에 대한 정보를 다른 노드에게 전파하거나 각 노드의 장애 상황을 전파하는 역할을 담당한다.   
또한 관리 노드는 중재자(Arbitrator) 역할을 수행한다. 
중재자 역할이란 클러스터의 노드 간 통신이 되지 않는 경우 데이터 노드가 서로 자기의 역할을 잘못 판단하게 되면 데이터의 일관성이 손상되는데 
이를 방지하는 기능을 한다.   
<br />

* 데이터 노드(Data node)                       
NDB 클러스터의 핵심이라고 할 수 있는 데이터 노드는 클러스터에 대한 전반적인 작업을 수행하는 노드다.                 
대표적으로는 데이터를 저장한느 스토리지를 관리하고 SQL 노드에서 오는 데이터 조작 요청을 모두 처리한다.                  
API 노드의(표준 SQL이 아닌 C/C++, 자바를 이용해 데이터를 조작하는 API를 사용하는 클라이언트) 요청도 처리한다.                   
데이터 노드는 내부적으로 데이터의 클러스터링을 위해 데이터를 쪼개고(파티션) 해당 데이터를 복사해서 백업해둔다.                
클러스터의 모든 데이터는 수직으로 파티션되어 각 데이터 노드에 분산되는데 이때 테이블은 프라이머리 키 값에 의해 자동으로 파티션된다.               
필요한 경우 테이블을 파티션하는 방법을 사용자가 직접 결정할 수도 있다.               
<br />    

* SQL 노드(SQL node, API node)        
NDB 클러스터에 접속해 데이터를 읽고 쓰는 방법은 MySQL 서버를 통해 SQL 문법으로 처리할 수도 있지만     
자바나 C 같은 프로그래밍 언어를 이용해 클러스터의 데이터를 조작할 수도 있다.        
후자의 방법은 NDB API를 이용하는 방법으로 API 노드라고도 표현한다. 반면 MySQL 서버를 이용해 NDB 클러스터에 접속하는 경우를 SQL 노드라 한다.      

<br />         

각 노드 간의 연동은 다음과 같다.  <br />      
![스크린샷 2021-01-15 오후 2 54 18](https://user-images.githubusercontent.com/33855307/104686932-92a96d80-5741-11eb-872d-4b31fe5df91b.png)         
<br />       

이하 생략 141p 참고   
<br />       
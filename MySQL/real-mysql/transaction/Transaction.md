# 트랜잭션과 잠금        
MySQL의 동시성에 영향을 미치는 잠금(Lock)과 트랜잭션, 트랜잭션 격리수준에 대해 알아보자.    

* 트랜잭션    
작업의 완전성을 보장해주는 것이다.              
논리적인 작업셋을 완벽하게 처리 또는 처리하지 못할 경우 원상태로 복구해서          
작업의 일부만 적용되는 현상(Partial update)이 발생하지 않게 만들어주는 기능이다.          

* 잠금   
동시성을 제어하기 위한 기능       
<br />         
   
## 트랜잭션   

#### MySQL에서 트랜잭션         
트랜잭션은 하나의 쿼리가 있든, 두 개 이상의 쿼리가 있든 관계없이 100% 적용되거나 아무것도 적용되지 않아야 함을 보장해 주는 것이다.
트랜잭션 관점에서 InnoDB 테이블과 MyISAM 테이블의 차이를 살펴보자.          

```
CREATE TABLE tab_myisam ( fdpk INT NOT NULL, 
    PRIMARY KEY ( fdpk ) ) ENGINE=MyISAM;

CREATE TABLE tab_innodb ( fdpk INT NOT NULL, 
    PRIMARY KEY ( fdpk ) ) ENGINE=INNODB;
```

테스트용 테이블에 각각 레코드 1건씩 저장 후 `AUTO-COMMIT` 모드에서 다음 쿼리 문장을 InnoDB 테이블과 MyISAM 테이블에서 각각 실행해보자.   

```
INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
```

두 개의 스토리지 엔진에서 결과는 다음과 같다.   

```
mysql> INSERT INTO tab_myisam (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> INSERT INTO tab_innodb (fdpk) VALUES (1), (2), (3);
ERROR 1062 (23000): Duplicate entry '3' for key 'PRIMARY'

mysql> SELECT * FORM tab_myisam;
+------+
| fdpk |
+------+
|     1|
|     2|
|     3|
+------+

mysql> SELECT * FORM tab_innodb;
+------+
| fdpk |
+------+
|     1|
+------+
```

두 INSERT 문장 모두 PRIMARY KEY 중복 오류로 쿼리가 실패했다.   
그런데 MyISAM 테이블에 "1"과 "2"는 INSERT된 상태로 남아있다.   

MEMORY 스토리지 엔진이나 MERGE 스토리지 엔진을 사용하는 테이블도 MyISAM 테이블과 동일하게 작동한다.   
MyISAM 테이블에서 발생하는 이러한 현상을 부분 업데이트라고 표현하며, 부분 업데이트 현상은 테이블 데이터의 정합성을 맞추는데 상당히 어려운 문제를 만들어낸다.
<br />    

#### 주의사항    
트랜잭션 또한 DBMS의 커넥션과 동일하게 최소의 코드에만 적용하는 것이 좋다.   
-> 프로그램 코드에서 트랜잭션의 범위를 최소화하라는 의미다.   

다음은 게시물 작성 후 저장하는 기능의 서버 처리 과정이다.     
```  
1. 처리 시작   
=> 데이터베이스 커넥션 생성
=> 트랜잭션 시작    
2. 사용자의 로그인 여부 확인 
3. 사용자의 글 내용 오류 여부 확인 
4. 첨부 파일 확인 및 저장 
5. 사용자의 입력 내용 DBMS에 저장 
6. 첨부 파일 정보를 DBMS에 저장 
7. 저장된 내용 또는 기타 정보 DBMS에서 조회 
8. 게시물 등록에 대한 알림 메일 발송 
9. 알림 메일 발송 이력을 DBMS에 저장 
<= 트랜잭션 종료 (COMMIT)
<= 데이터베이스 커넥션 반납 
10. 처리 완료
```  

위 절차 중 DBMS의 트랜잭션 처리에 좋지 않은 영향을 끼치는 부분을 알아보자.   

많은 개발자가 데이터베이스의 커넥션을 생성하는 코드를 1번과 2번 사이에 구현하며 그와 동시에 "START TRANSACTION" 명령으로 트랜잭션을 시작한다.   
그리고 9번과 10번 사이에서 트랜잭션을 COMMIT하고 커넥션을 종료한다.   
커넥션을 소유하는 시간이 길어지면 어느 순간 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다.

더 큰 위험은 8번 작업이라고 볼 수 있다.          
프로그램이 실행되는 동안 메일 서버와 통신할 수 없는 상황이 발생한다면 웹 서버뿐 아니라 DBMS 서버까지 위험해지는 상황이 발생할 것이다.           
메일 전송이나 FTP 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등의 작업은 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.

이 처리 절차에서 DBMS의 작업이 크게 4가지가 있다.     
* 사용자가 입력한 정보를 저장하는 5, 6번 작업은 반드시 하나의 트랜잭션으로 묶어야함    
* 7번 작업은 저장된 데이터의 단순 확인 및 조회이므로 트랜잭션에 포함될 필요 없음     
* 9번 작업은 조금 성격이 다르기 때문에 이전 트랜잭션(5, 6번)에 함께 묶지 않아도 무방해보임    
이러한 작업은 별도의 트랜잭션으로 분리하는 것이 좋다.   
* 7번 작업은 단순 조회라고 본다면 별도로 트랜잭션을 사용하지 않아도 무방해보임  
<br />        
  
이러한 내용을 적용해서 처리 절차를 다시 설계해보자.   

``` 
1. 처리 시작 
2. 사용자 로그인 여부 확인 
3. 사용자의 글 내용의 오류 발생 여부 확인 
4. 첨부된 파일 확인 및 저장 
=> 데이터베이스 커넥션 생성 
=> 트랜잭션 시작 
5. 사용자의 입력 내용을 DBMS에 저장 
6. 첨부 파일 정보를 DBMS에 저장 
<= 트랜잭션 종료(COMMIT)
7. 저장된 내용 또는 기타 정보를 DBMS에서 조회 
8. 게시물 등록에 대한 알림 메일 발송 
=> 트랜잭션 시작 
9. 알림 메일 발송 이력을 DBMS에 저장 
<= 트랜잭션 종료(COMMIT)
<= 데이터베이스 커넥션 종료
10. 처리 완료 
``` 

위 예제가 최적의 설계가 아닐 수 있으나 설명하고자 하는 것은 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와         
트랜잭션이 활성화돼 있는 프로그램의 범위를 최소화해야 한다는 것이다.

<br />    

## MySQL 엔진의 잠금    
MySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눠볼 수 있다.   

* MySQL 엔진 레벨의 잠금: 모든 스토리지 엔진에 영향을 미친다.    
테이블 데이터 동기화를 위한 잠금 이외에도 유저 락과 네임 락이라는 것도 제공한다.      
* 스토리지 엔진 레벨의 잠금: 스토리지 엔진 간 상호 영향을 미치지 않는다.              

<br />               

#### 글로벌 락            
글로벌 락은 MySQL에서 제공하는 잠금 가운데 가장 범위가 크다.   
한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 DDL 문장이나 DML 문장을 실행하는 경우     
글로벌 락이 해제될 때까지 해당 문장이 대기 상태로 남는다.   
**범위는 MySQL 서버 전체**이며, 작업 대상 테이블이나 데이터베이스가 다르더라도 동일하게 영향을 미친다.
여러 데이터베이스에 존재하는 MyISAM이나 MEMORY 테이블에 대해 **mysqldump로 일관된 백업을 받아야 할 때 글로벌 락을 사용해야 한다.**      

<br />            

#### 테이블 락(TABLE LOCK)     
개별 테이블 단위로 설정되는 잠금이며, 명시적 또는 묵시적으로 특정 테이블의 락을 획득할 수 있다.   
테이블 락은 MyISAM 뿐만 아니라 InnoDB 스토리지 엔진을 사용하는 테이블도 동일하게 설정할 수 있다.   
명시적인 테이블 락도 특별한 상황이 아니면 애플리케이션에서 거의 사용할 필요가 없다.   
글로벌 락과 동일하게 온라인 작업에 상당한 영향을 미치기 때문이다.   

묵시적인 테이블 락은 MyISAM이나 MEMORY 테이블에 데이터를 변경하는 쿼리를 실행하면 발생한다.   
MySQL 서버가 데이터가 변경되는 테이블에 잠금을 설정하고 데이터를 변경한 후, 즉시 잠금을 해제하는 형태로 사용된다.   
하지만 InnoDB 테이블의 경우 스토리지 엔진 차원에서 레코드 기반의 잠금을 제공하기 때문에     
단순 데이터 변경 쿼리로 인해 묵시적인 테이블 락이 설정되지는 않는다.       
더 정확히는 InnoDB 테이블에도 테이블 락이 설정되지만 **대부분의 데이터 변경(DML) 쿼리에서는 무시**되고 **스키마를 변경하는 쿼리(DDL)의 경우에만 영향**을 미친다.    

<br />     

#### 유저 락(USER LOCK)   
유저 락은 단순히 사용자가 지정한 문자열(String)에 대해 획득하고 반납(해제)하는 잠금이다.     
예를 들어 데이터베이스 서버 1개에 5대의 웹 서버가 접속해서 서비스를 하고 있는 상황에서 5대의 웹 서버가 어떤 정보를 동기화해야 하는 요건처럼       
여러 클라이언트가 상호 동기화를 처리해야 할 때 데이터베이스의 유저 락을 이용하면 쉽게 해결할 수 있다.        

또한, 많은 레코드를 한 번에 변경하는 트랜잭션의 경우에 유용하게 사용할 수 있다.   
배치 프로그램처럼 한꺼번에 많은 레코드를 변경하는 쿼리는 자주 데드락의 원인이 되곤 한다.   
이러한 경우 동일 데이터를 변경하거나 참조하는 프로그램끼리 분류해서 유저 락을 걸고 쿼리를 실행하면 아주 간단히 해결할 수 있다.    

<br />

#### 네임 락  
데이터베이스 객체(대표적으로 테이블이나 뷰 등)의 이름을 변경하는 경우 획득하는 잠금이다.   
네임 락은 명시적으로 획득하거나 해제할 수 있는 것이 아니고 "RENAME TABLE tab_a TO tab_b" 같이   
테이블의 이름을 변경하는 경우 자동으로 획득하는 잠금이다.     
RENAME TABLE 명령의 경우 원본 이름과 변경될 이름 두 개 모두 한꺼번에 잠금을 설정한다.   

또한 실시간으로 테이블을 바꿔야 하는 요건이 배치 프로그램에서 자주 발생하는데, 다음 예제를 살펴보자.    

```
-- // 배치 프로그램에서 별도의 임시 테이블(rank_new)에 서비스용 랭킹 데이터를 생성 

-- // 랭킹 배치가 완료되면 현재 서비스용 랭킹 테이블(rank)을 rank_backup으로 백업하고 
-- // 새로 만들어진 랭킹 테이블(rank_new)을 서비스용으로 대체하고자 하는 경우 

mysql> RENAME TABLE rank TO rank_backup , rank_new TO rank; 
```

위와 같이 하나의 RENAME TABLE 명령문에 두 개의 RENAME 작업을 한꺼번에 실행하면 실제 애플리케이션에서는   
"Table not found 'rank'"와 같은 상황이 발생시키지 않고 적용하는 것이 가능하다.   
하지만 아래와 같이 2개로 나눠서 실행하면 아주 짧은 시간이지만 'rank' 테이블이 존재하지 않는 순간이 생기게 되며,   
그 순간에 실행되는 쿼리는 "Table not found 'rank'" 오류를 발생시킨다.   

```
mysql> RENAME TABLE rank TO rank_backup;
mysql> RENAME TABLE rank_new To rank;
```

<br />        

## MyISAM과 MEMORY 스토리지 엔진의 잠금         
MyISAM과 MEMORY 스토리지 엔진은 자체적인 잠금을 가지지 않고 MySQL 엔진에서 제공하는 테이블 락을 그대로 사용한다.   
그리고 MyISAM과 MEMORY 스토리지 엔진에서 쿼리 단위로 필요한 잠금을 한꺼번에 요청해서 획득하기 때문에 데드락이 발생할 수 없다.    

<br />     

#### 잠금 획득    
* 읽기 잠금   
테이블에 쓰기 잠금이 걸려 있지 않으면 바로 읽기 잠금을 획득하고 읽기 작업을 시작할 수 있다.   
  
* 쓰기 잠금    
테이블에 아무런 잠금이 걸려 있지 않아야만 쓰기 잠금을 획득할 수 있고, 그렇지 않다면 다른 잠금이 해제될 때까지 대기해야 한다.       

<br />       


## InnoDB 스토리지 엔진의 잠금       
InnoDB 스토리지 엔진은 MySQL에서 제공하는 잠금과는 별개로 스토리지 엔진 내부에서 **레코드 기반의 잠금 방식**을 탑재하고 있다.    

* 레코드 기반의 잠금 방식으로 MyISAM 보다 **뛰어난 동시성 처리**를 제공할 수 있다.     
* 이원화된 잠금 처리 탓에 InnoDB 스토리지 엔진에서 사용되는 잠금에 대한 정보는 MySQL 명령을 이용해 접근하기가 까다롭다.      

<br />    
  
#### InnoDB의 잠금 방식    
* 비관적 잠금(Pessimistic locking)      
현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경 작업을 처리하는 방식을 비관적 잠금이라고 한다.    
"현재 변경하고자 하는 레코드를 다른 트랜잭션에서도 변경할 수 있다." 라는 비관적인 가정을 하기 때문에 먼저 잠금을 획득한 것이다.    
일반적으로 **높은 동시성 처리에는 비관적 잠금이 유리하다고 알려져 있으며 InnoDB는 비관적 잠금 방식을 채택하고 있다.**        
  
* 낙관적 잠금(Optimistic locking)         
낙관적 관점에서는 기본적으로 각 트랜잭션이 같은 레코드를 변경할 가능성은 상당히 희박할 것이라고 가정한다.               
우선 변경 작업을 수행하고 마지막에 잠금 충돌이 있었는지 확인해 문제가 있었다면 ROLLBACK 처리하는 방식을 의미한다.        

<br />       
  
#### InnoDB의 잠금 종류    
InnoDB 스토리지 엔진은 레코드 기반의 잠금 기능을 제공하며, 잠금 정보가 상당히 작은 공간으로 관려되기 때문에           
레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업되는 경우(락 에스컬레이션)는 없다.              
일반 상용 DBMS와는 조금 다르게 InnoDB 스토리지 엔진에서는 레코드 락뿐 아니라 레코드와 레코드 사이의 간격을 잠그는 갭(GAP) 락이라는 것이 존재한다.   

![스크린샷 2021-01-16 오후 1 51 52](https://user-images.githubusercontent.com/33855307/104797538-0b6ffe80-5802-11eb-941a-b14fbb22f06d.png)      
<br />             

* 레코드 락(Record lock, Record only lock)                         
레코드 자체만을 잠그는 것을 레코드 락이라고 하며, 다른 상용 DBMS의 레코드 락과 동일한 역할을 한다.          
한 가지 중요한 차이는 InnoDB 스토리지 엔진은 레코드 자체가 아니라 **인덱스의 레코드를 잠근다**는 점이다.       
만약 인덱스가 하나도 없는 테이블이라 하더라도 **내부적으로 자동 생성된 클러스터 인덱스를 이용**해 잠금을 설정한다.      
InnoDB에서는 대부분 보조 인덱스를 이용한 변경 작업은 넥스트 키 락 또는 갭 락을 사용하지만       
프라이머리 키 또는 유니크에 의한 변경 작업은 갭에 대해서는 잠그지 않고 레코드 자체에 대해서만 락을 건다.        
<br />            
  
* 갭 락(Gap lock)    
갭 락은 레코드 그 자체가 아니라 레코드와 바로 인접한 레코드 사이의 간격만을 잠그는 것을 의미한다.   
갭 락의 역할은 **레코드와 레코드 사이의 간격에 새로운 레코드가 생성(INSERT)되는 것을 제어**하는 것이다.     
갭 락이라는 것은 개념일 뿐이지 자체적으로 사용되지 않고, 이어서 설명할 넥스트 키 락의 일부로 사용된다.   
<br />            
  
* 넥스트 키 락(Next key lock)       
레코드 락과 갭 락을 합쳐 놓은 형태의 잠금을 넥스트 키 락이라고 한다.             
**STATEMENT 포맷의 바이너리 로그**를 사용하는 MySQL 서버에서는 `REPEATABLE READ` 격리 수준을 사용해야 한다. <br />       
InnoDB의 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때       
마스터에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적이다.       
그런데 의외로 넥스트 키 락과 갭 락으로 인해 데드락이 발생하거나 다른 트랜잭션을 기다리게 만드는 일이 자주 발생한다.   
가능하다면 바이너리 로그 포맷을 ROW 형태로 바꿔서 넥스트 키 락이나 갭 락을 줄이는 것이 좋다.   
하지만 아직 ROW 포맷의 바이너리 로그는 그다지 널리 사용되지 않기 때문에 안정성을 확인하는 것이 어려운 상태이며    
STATEMENT 포맷의 바이너리 로그에 비해 로그 파일의 크기가 상당히 커질 가능성이 많다.    
<br />            
  
* 자동 증가 락(Auto increment lock)     
AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT되는 경우      
저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다.        
InnoDB 스토리지 엔진에서는 이를 위해 내부적으로 **AUTO_INCREMENT 락**이라고 하는 **테이블 수준의 잠금**을 사용한다. <br />                        
AUTO_INCREMENT 락은 INSERT와 REPLACE 쿼리 문장과 같이        
**새로운 레코드를 저장하는 쿼리에서만 필요**하며 UPDATE나 DELETE 등의 쿼리에서는 걸리지 않는다.               
InnoDB의 다른 잠근과는 달리 **트랜잭션과 관계없이**                     
INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 AUTO_INCREMENT 락이 걸렸다가 즉시 해제된다.           
AUTO_INCREMENT 락은 테이블에서 단 하나만 존재하기 때문에 두 개의 INSERT 쿼리가 동시에 실행되는 경우          
하나의 쿼리가 AUTO_INCREMENT 락을 걸게 되면 나머지 쿼리는 AUTO_INCREMENT 락을 기다려야 한다.        
AUTO_INCREMENT 칼럼에 명시적으로 값을 설정해주더라도 자동 증가 락을 걸게 된다.   
AUTO_INCREMENT 락은 명시적으로 획득하고 해제하는 방법은 없다. 아주 짧은 시간 동안만 걸렸다가 해제되는 잠금이라 대부분의 경우 문제가 되지 않는다.                   


<br />            
      
#### 인덱스와 잠금    
InnoDB의 잠금과 인덱스는 상당히 중요한 연관 관계가 있다.     
InnoDB의 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다.     
즉 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.      
   
```
-- // 예제 데이터베이스의 employees 테이블에는 아래와 같이 first_name 칼럼만 
-- // 멤버로 담신 ix_firstname이라는 인덱스가 준비돼 있다.   
-- // KEY ix_firstname (first_name)

-- // employees 테이블에서 first_name='Georgi'인 사원은 전체 253명이 있으며, 
-- // first_name='Georgi'이고 last_name='Klassen'인 사원은 딱 1명만 있는 것을 아래 쿼리로 확인할 수 있다. 
mysql> SELECT COUNT(*) FROM employees WHERE first_name='Georgi';
+-------+
|    253|
+-------+

mysql> SELECT COUNT(*) FROM employees WHERE first_name='Georgi' AND last_name='Klassen';
+-------+ 
|      1| 
+-------+ 

-- // employees 테이블에서 first_name='Georgi'이고 last_name='Klassen'인 사원의 입사 일자를 오늘로 변경하는 변경하는 쿼리를 실행해보자.  
mysql> UPDATE employees SET hire_date=NOW()
       WHERE first_name='Georgi' AND last_name='Klassen';       
```

UPDATE 문장이 실행되면 1건의 레코드가 업데이트된다. 이 1건의 업데이트를 위해 몇 개의 레코드에 락을 걸어야 할까?    
이 UPDATE 문장의 조건에서 인덱스를 이용할 수 있는 조건은 `first_name='Georgi'`이며   
last_name 칼럼은 인덱스에 없기 때문에 `first_name='Georgi'`인 레코드 253건의 레코드가 모두 잠긴다.   
UPDATE 문장을 위해 적절히 인덱스가 준비돼 있지 않다면 각 클라이언트 간의 동시성이 상당히 떨어져서      
한 세션에서 UPDATE 작업을 하고 있는 중에는 다른 클라이언트는 그 테이블을 업데이트하지 못하고 기다려야 하는 상황이 발생할 것이다.   

만약 이 테이블에 인덱스가 하나도 없으면 테이블을 **풀 스캔**하면서 UPDATE 작업을 하는데, 이 과정에서 테이블에 있는 N건의 모든 레코드가 잠기게 된다.    
MySQL의 InnoDB에서 인덱스 설계가 중요한 이유이다.   
<br />       


#### 트랜잭션 격리 수준과 잠금   
위 UPDATE 예제에서 살펴본 불필요한 레코드의 잠금 현상은 InnoDB의 **넥스트 키 락** 때문에 발생하는 것이다.   
하지만 InnoDB에서 넥스트 키 락을 필요하게 만드는 주 원인은 바로 **복제를 위한 바이너리 로그 때문이다.**        
아직 많이 사용되지는 않지만 **레코드 기반의 바이너리 로그**(Row based binary log)를 사용하거나 바이너리 로그를 사용하지 않는 경우에는    
InnoDB의 갭 락이나 넥스트 키 락의 사용을 대폭 줄일 수 있다.     
InnoDB의 갭 락이나 넥스트 키 락을 줄일 수 있다는 것은 사용자의 **쿼리 요청을 동시에 더 많이 처리할 수 있음**을 의미한다.   
<br />   

다음 조합을 MySQL 서버가 기동하는 경우에는 InnoDB에서 사용되는 대부분의 갭 락이나 넥스트 키 락을 제거할 수 있다.   

|버전|설정의 조합|
|:---|:---|
|MySQL 5.0|innodb_locks_unsafe_for_binlog=1 <br /> 트랜잭션 격리 수준을 READ-COMMITTED로 설정|
|MySQL 5.1 이상|바이너리 로그를 비활성화 <br /> 트랜잭션 격리 수준을 READ-COMMITTED로 설정 <br /> --- <br /> 레코드 기반의 바이너리 로그 사용 <br />  innodb_locks_unsafe_for_binlog=1 <br /> 트랜잭션 격리 수준을 READ-COMMITTED로 설정|

MySQL 5.1 이상의 버전에서는 바이너리 로그(문장 기반의 바이너리 로그만 해당)가 활성화되면               
최소 REPEATABLE-READ 이상의 격리 수준을 사용하도록 강제되고 있기 때문에 조금 내용이 달라진 것이다.         
여기서 "대부분"의 갭 락이나 넥스트 키 락이 없어진다고 한 것은 이 조합의 설정에서도 **유니크키나 외래키에 대한 갭 락은 없어지지 않기 때문이다.**       

또한 위 조합으로 설정하면 위에서 언급했던 불필요한 잠금도 일부 없어진다.   
UPDATE 문장을 처리하기 위해 일치하는 레코드를 인덱스를 이용해 검색할 때, 우선 인덱스만 비교해서 일치하는 레코드에 대해 배타적 잠금을 걸게 되지만   
그 다음 **나머지 조건을 비교해서 일치하지 않는 레코드는 즉시 잠금을 해제한다.**     
<br />   

#### 레코드 수준의 잠금 학인 및 해제     
InnoDB 스토리지 인젠을 사용하는 테이블의 레코드 수준 잠금은 테이블 수준의 잠금보다는 조금 더 복잡하다.      
MySQL 5.1 부터는(InnoDB 플러그인 버전부터) 레코드 잠금과 잠금 대기에 대한 조회가 가능하므로        
쿼리 하나만 실행해보면 잠금과 잠금대기를 바로 확인할 수 있다.        

***잠금 확인 및 해제 방법 생략**
<br />   

## MySQL의 격리 수준   
트랜잭션의 격리 수준(isolation level)이란 동시에 여러 트랜잭션이 처리될 때          
특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.      

격리 수준은 크게 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 4가지로 나뉘다.    
`DIRTY READ`라고도 하는 `READ UNCOMMITTED`는 일반적인 데이터베이스에서는 거의 사용하지 않고,      
`SERIALIZABLE` 또한 동시성이 중요한 데이터베이스에서는 거의  사용되지 않는다.     

4개의 격리 수준에서 순서대로 뒤로 갈수록 각 트랜잭션 간의 데이터 격리(고립) 정도가 높아지며           
동시에 동시성도 떨어지는 것이 일반적이라고 볼 수 있다.                                            
격리 수준이 높아질수록 MySQL 서버의 처리 성능이 많이 떨어질 것으로 생각할 수 있는데          
`SERIALIZABLE` 격리 수준이 아니라면 크게 성능이 개선이나 저하는 발생하지 않는다.        
                                                                                 
데이터베이스 격리 수준에서 항상 함께 언급되는 3가지 부정합 문제점이 있다.    

| |DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|                                                                                                                                                             
|:---|:---|:---|:---|                                                                                                                                                        
|READ UNCOMMITTED|발생|발생|발생|                                                                                           
|READ COMMITTED|발생하지 않음|발생|발생|    
|REPEATABLE READ|발생하지 않음|발생하지 않음|발생 <br /> (InnoDB는 발생하지 않음)| 
|SERIALIZABLE|발생하지 않음|발생하지 않음|발생하지 않음| 


일반적인 온라인 서비스 용도의 데이터베이스는 `READ COMMITTED`와 `REPEATABLE READ` 둘 중에서 하나를 사용한다.   
MySQL에서는 주로 `REPEATABLE READ` 수준을 많이 사용한다.   
여기서 설명되는 SQL 예제는 모두 AUTO_COMMIT이 OFF 상태에서 테스트할 수 있다.    

<br />   

#### `READ UNCOMMITTED`        
`READ UNCOMMITTED` 격리 수준에서 각 트랜잭션에서의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관 없이 다른 트랜잭션에서 보여진다.     

![스크린샷 2021-01-16 오후 9 15 47](https://user-images.githubusercontent.com/33855307/104811594-0b8eef00-5840-11eb-82b6-d0f14cb2198f.png)    

어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 더티 리드(Dirty read)라 하고,                
더티 리드가 허용되는 격리 수준이 `READ UNCOMMITTED`다.                                     
더티 리드를 유발하는 `READ UNCOMMITTED`는 RDBMS 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.              
MySQL을 사용한다면 최소한 `READ COMMITTED` 이상의 격리 수준을 사용할 것을 권장한다.                                  

<br />    
                                                                                                        
#### `READ COMMITTED`    
* 더티 리드 현상은 발생하지 않는다.   
* 어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다.   

A가 변경한 내용이 사용자 B에게 어떻게 조회되는지 보자.   

![스크린샷 2021-01-18 오후 3 12 59](https://user-images.githubusercontent.com/33855307/104878640-ab16c380-599f-11eb-9ef2-0973a53b2da2.png)      

emp_no=500000인 사원의 first_name을 "Lora"에서 "Toto"로 변경했는데     
이때 새로운 값인 "Toto"는 즉시 테이블에 기록되고 이전 값인 "Lora"는 언두 영역으로 백업된다.      
사용자 A가 커밋을 수행하기 전에 사용자 B가 emp_no=500000인 사원을 조회할 때 first_name은 "Lora"로 조회된다.      
employees 테이블이 아니라 언두 영억에 백업된 레코드를 가져온 것이다.    

`READ COMMITTED` 격리 수준에서도 NON-REPEATABLE READ(`REPEATABLE`가 불가능하다.)라는 부정합 문제가 있다.    

![스크린샷 2021-01-18 오후 3 25 23](https://user-images.githubusercontent.com/33855307/104879534-65f39100-59a1-11eb-9985-6709d25de742.png)    

사용자 B가 하나의 트랜잭션 내에서 똑같은 SELECT 쿼리를 실행했을 때는 항상 같은 결과를 가져와야 한다는 "REPEATABLE READ" 정합성에 어긋난다는 것이다.    
일반적인 웹 프로그램에서는 큰 문제가 되지는 않지만 하나의 트랜잭션에서 동일 데이터를 여러 번 읽고 변경하는 작업이 금전적인 처리와 연결되면 문제가 될 수 있다.    
예를들어, 다른 트랜잭션에서 입금과 출금 처리가 계속 진행되고 있을 때 다른 트랜잭션에서 오늘 입금된 금액의 총합을 조회한다고 가정해보자.       

트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 없이 실행되는 SELECT 문장의 차이를 혼동하는 경우가 있다.    
`READ COMMITTED` 격리 수준에서는 트랜잭션 내에서 실행되는 SELECT 문장과 트랜잭션 외부에서 실행되는 SELECT 문장의 차이가 별로 없다.     
하지만 `REPEATABLE READ` 격리 수준에서는 기본적으로 SELECT 쿼리 문장도 트랜잭션 범위 내에서만 작동하는 것이다.     
즉 "BEGIN TRANSACTION"으로 트랜잭션을 시작한 상태에서 온종일 동일한 쿼리를 반복해서 실행해도 동일한 결과만 보게 된다.   
(그 안에서 아무리 데이터를 변경하고 COMMIT해도 결과는 같다.)   
이런 문제로 데이터의 정합성이 깨지고 그로 인해 애플리케이션의 버그가 발생하면 찾아내기 쉽지 않다.    

<br />          

#### `REPEATABLE READ`         
`REPEATABLE READ`는 MySQL의 InnoDB 스토리지 엔진에서 기본적으로 사용되는 격리 수준이다.   
이 격리 수준에서는 `READ COMMITTED` 격리 수준에서 발생하는 "NON-REPEATABLE READ" 부정합이 발생하지 않는다.       

InnoDB 스토리지 엔진은 트랜잭션이 ROLLBACK될 가능성에 대비해 변경되기 전 레코드를 언두(Undo) 공간에 백업해두고 실제 레코드 값을 변경한다.        
이러한 변경 방식을 MVCC라고 한다. 백업된 이전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.    
`READ COMMITTED`도 MVCC를 이용해 COMMIT되기 전의 데이터를 보여준다.      
`REPEATABLE READ`와 `READ COMMITTED`의 차이는 언두 영역에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하는지에 있다.      

모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션의 번호가 포함돼 있다.       
언두 영역의 백업 데이터는 InnoDB 스토리지 엔진이 불필요하다고 판단하는 시점에 주기적으로 삭제한다.           
`REPEATABLE READ` 격리 수준에서는 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데     
가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수가 없다.       

`REPEATABLE READ` 격리 수준에서도 다음과 같은 부정합이 발생할 수 있다.      
사용자 A가 employees 테이블에 INSERT를 실행하는 도중에      
사용자 B가 `SELECT ... FOR UPDATE` 쿼리로 employees 테이블을 조회했을 때 어떤 결과를 가져올까?    
INSERT 하는 도중의 SELECT 결과와 INSERT 작업 COMMIT 후의 SELECT 결과가 다르다.    
이렇게 **다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 보였다가 안 보였다가 하는 현상**을 `PHANTOM READ`(또는 PHANTOM ROW)라고 한다.    
`SELECT ... FOR UPDATE` 쿼리는 **SELECT하는 레코드에 쓰기 잠금을 걸어야 하는데, 언두 레코드에는 잠금을 걸 수 없다.**                          
그래서 `SELECT ... FOR UPDATE`나 `SELECT ... LOCK IN SHARE MODE`로 조회되는 레코드는      
언두 영역의 변경 전 데이터를 가져오는 것이 아니라 현재 레코드 값을 가져오게 되는 것이다.          


<br />    

#### `SERIALIZABLE`      
가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다.    
또한 처리 성능도 다른 트랜잭션 격리 수준보다 떨어진다.   

InnoDB 테이블에서 기본적으로 순수한 SELECT 작업       
(`INSERT ... SELECT ...` 또는 `CREATE TABLE ... AS SELECT ...`가 아닌)은 아무런 레코드 잠금도 설정하지 않고 실행된다.        
InnoDB 메뉴얼에서 자주 나타나는 "Non-locking consistent read"(잠금이 필요없는 일관된 읽기) 라는 말이 이를 의미하는 것이다.    

하지만 트랜잭션의 격리 수준이 `SERIALIZABLE`로 설정되면 읽기 작업도 공유 잠금(읽기 잠금)을 획득해야만 하며,    
동시에 다른 트랜잭션은 그러한 레코드를 변경하지 못하게 된다.   
즉, 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 절대 접근할 수 없는 것이다.    

`SERIALIZABLE` 격리 수준에서는 일반적인 DBMS에서 일어나는 "PHANTOM READ"라는 문제가 발생하지 않는다.    
하지만 InnoDB 스토리지 엔진에서는 `REPEATABLE READ` 격리 수준에서도 이미 "PHANTOM READ"가 발생하지 않는다.   

<br />

#### `REPEATABLE READ` 격리 수준과 `READ COMMITTED` 격리 수준의 성능 비교     
실제 온라인 서비스 상황에서 발생할 가능성은 거의 없지만 `REPEATABLE READ`가 상당히 성능을 떨어지게 할 수 있다.        
예를 들어, 하나의 트랜잭션을 열어 그 트랜잭션에서 모든 테이블의 데이터를 SELECT한 후,      
그대로 계속 놔두면 InnoDB의 언두(Undo) 영역이 계속 커져서 시스템 테이블스페이스의 I/O가 유발되는 경우가 대표적인 예다.      
하지만 이런 의도적인 경우가 아니라면 `READ COMMITTD`나 `REPEATABLE READ` 격리 수준의 성능 차이는 사실 크지 않다.      

마지막으로 주의해야 할 점은 바이너리 로그(STATEMENT 포맷을 사용하는)가 활성화된 MySQL 서버에서는 `READ COMMITTED` 격리 수준을 사용할 수 없다는 것이다.     
MySQL 5.0 이하 버전에서는 경고 메시지를 출력하지는 않지만 그렇다고 안정적인 것은 아니며,         
MySQL 5.1 부터는 경고 메시지를 출력하는 형태로 변경되었다.          


<br />     

## 정리       
REPEATABLE READ를 만족시키기 위해서 MySQL InnoDB 엔진은 아래 두가지 방식을 사용한다.    
* locking을 이용하지 않는 consistent read 방식을 사용         
* 명시적으로 locking read를 할 수 있도록 `SELECT ... FOR SHARE`, `SELECT ... FOR UPDATE` 구문을 제공    

locking read 구문들과, UPDATE, DELETE이 수행될 때 실제 lock이 적용되는 방식은 SQL statement의 조건과,    
대상 테이블의 컬럼에 index가 걸려있는지, 해당 index가 unique 한지에 따라 달라진다.   

* unique index가 적용된 컬럼을 특정 값으로 검색    
    - 예) `... WHERE pk=8`    
    - 찾아진 하나의 인덱스 레코드에만 lock적용    


* 그 외     
    - unique index 컬럼을 범위로 검색    
      예) `... WHERE pk > 100`      
    - non-unique index 컬럼을 특정 값 또는 범위로으로 검색      
      예) `... WHERE field = 3` or `... WHERE field > 4`    
    - gap lock 또는 next-key lock을 이용해서 스캔한 인덱스 범위에 lock을 적용해서 다른 세션이 해당 범위에 INSERT하는 것을 막는다.    



<br />     


## Consistent Read: 설정된 트랜잭션 격리 수준에 따른 스냅샷 생성 시점   
* REPEATABLE READ인 경우 트랜잭션 시작 후   
첫번째 read operation이 수행되는 시점의 데이터로 스냅샷이 생성된다.   
SQL 표준 트랜잭션 격리 수준에 따르면 REPEATABLE READ인 경우 Phantom read가 발생하는데    
MySQL InnoDB 엔진의 경우 Consistent read를 사용하기 때문에 REPEATABLE READ 레벨에서도 Phantom read가 발생하지 않는다.    
<br />      
* READ COMMITTED    
read operation이 발생하는 시점에 매번 스냅샷이 다시 생성된다.
  
<br />   

#### Consistent Read의 문제점       
* consistent read 제약조건 : 트랜잭션 내에서 SELECT를 실행하면 다른 트랜잭션에서 데이터를 변경했더라도 항상 동일한 결과 리턴    
* 트랜잭션 제약조건 : 현재 트랜잭션 내에서 수행한 변경사항에 대한 결과가 트랜잭션 내에서는 항상 동일해야 한다.   

앞선 두 조건을 결합하면 문제가 발생한다. 

트랜잭션 내에서 특정 ROW를 UPDATE한 후 해당 ROW에 대해 SELECT 문을 실행하면 최신 데이터를 불러온다.   
(UPDATE된 ROW를 제외한 나머지 ROW는 스냅샷에서 불러온다.)    

해당 ROW에 대해서만 최신 데이터를 불러오다보니 이 데이터는 다른 트랜잭션에서 변경한 사항이 포함된 데이터일 가능성이 있다.    
이로인해 REPEATABLE READ가 깨진다.    

> consistent read는 DDL 구문에 대해서는 작동하지 않기 때문에   
> `DROP TABLE`, `ALTER TABLE` 이 실행되고 난 후에는 스냅샷이 더이상 유효하지 않는다.   





# JPA 소개    

### 1. SQL을 직접 다룰 때 발생하는 문제점    

자바와 관계형 데이터베이스를 사용해서 회원 관리 기능을 개발한다고 생각해보자.   

<br />         

#### 반복되는 코드           
(1) JDBC API를 사용해 디비에 Member 저장       
```   
String sql = "INSERT INTO MEMBER( ... ";
pstmt.setString(1, member.getId());
pstmt.executeUpdate(sql);
```   

회원 객체의 값을 꺼내서 SQL을 실행해서 저장해야 한다.     

(2) 자바 컬렉션에 보관    
```
list.add(member);
```

데이터베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수 없다.     
따라서 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 SQL과 JDBC API를 사용해서 변환 작업을 해줘야 한다.   
-> 문제는 객체를 디비에 CRUD하려면 너무 많은 SQL과 JDBC API 코드 작성이 필요하다는 것이다.   

<br />       

#### SQL에 의존적인 개발         
갑자기 회원의 연락처도 함께 저장해달라는 요구사항이 추가되었다고 가정하자.      

* Member 테이블에 TEL 컬럼 추가      
* INSERT SQL 수정     
* UPDATE SQL 수정      

전화번호 추가에 이어서 회원은 어떤 한 팀에 필수로 소속돼야한다는 요구사항이 추가되었다.   

```
Class Member {
    ...

    private Team team;
}

Class Team {
    ...

    private String teamName;
}
```

`member.getTeam()` 코드를 실행해보니 값이 항상 null이다.      
    
`find()` 메소드의 SQL은 다음과 같다.        
  
```  
SELECT MEMBER_ID, NAME, TEL 
FROM MEMBER M
```

회원과 연관된 팀을 다음과 같은 SQL로 함께 조회해야 한다.      

```
SELECT M.MEMBER_ID, M.NAME, T.TEAM_ID, T.TEAM_NAME
FROM MEMBER M
JOIN TEAM T
     ON M.TEAM_ID = T.TEAM_ID 
``` 

Member 객체가 연관된 Team 객체를 사용할 수 있을지 없을지는 전적으로 사용하는 SQL에 달려있다.   
이 방식의 가장 큰 문제점은 데이터 접근 계층을 사용해 SQL을 숨겨도 DAO를 열어서 어떤 SQL이 실행되는지 확인해야 한다는 점이다.   
이것은 진정한 계층 분할이 아니다.   

애플리케이션에서 SQL을 다룰 때 발생하는 문제점은 다음과 같다.     
* 진정한 의미의 계층분할이 어렵다.      
* 엔티티를 신뢰할 수 없다.     
* SQL에 의존적인 개발을 피하기 어렵다.     

<br />       

#### JPA와 문제해결       
JPA를 사용하면 객체를 디비에 저장하고 관리할 때 개발자가 직접 SQL을 작성하는게 아니라 JPA가 제공하는 API를 사용하면 된다.    

특징은 다음과 같다.    
* UPDATE는 트랜잭션 커밋 때 적절하게 SQL을 전달한다.          
* 연관된 객체는 사용하는 시점에 SELECT 조회가 실행된다.       


<br />         


### 2. 패러다임의 불일치   

#### 상속      
객체는 상속이라는 기능을 갖고 있지만 테이블은 상속이라는 기능이 없다.    

![스크린샷 2021-01-08 오후 3 37 13](https://user-images.githubusercontent.com/33855307/103982750-7482c100-51c7-11eb-99e6-3413fd876082.png)    

그나마 DB 모델링에서 이야기하는 슈퍼타입, 서브타입 관계를 사용하면 객체 상속과 유사하게 설계할 수 있다.    

![스크린샷 2021-01-08 오후 3 46 09](https://user-images.githubusercontent.com/33855307/103983482-a9dbde80-51c8-11eb-937e-03b8ed012c1e.png)     

예를들어 DTYPE의 값이 BOOK이면 BOOK 테이블과 연관관계이다.    


JDBC API를 사용해서 ITEM과 BOOK을 INSERT 하려면 부모 객체에서 부모 데이터만 꺼내서 ITEM용 SQL로 저장하고   
BOOK은 자식 객체에서 자식 데이터만 꺼내서 BOOK용 SQL로 저장해야 한다.   
벌써 작성할 코드가 늘었고 자식 타입에 따라 DTYPE도 저장해야 한다.   

조회할 때도 마찬가지로 ITEM과 BOOK 테이블을 조인해서 조회한 다음 그 결과로 BOOK 객체를 생성해야 한다.     

<br />         


#### JPA와 상속    
JPA는 상속과 관련된 패러다임 불일치 문제를 개발자가 대신 해결한다.   
SQL 작성이 아니라 (JPA API) 메소드를 사용해서 저장하고 조회하는 메소드를 호출하면   
JPA가 알아서 조인하고 필요한 데이터를 조회해서 결과를 반환한다.       

<br />         

#### 연관관계          
객체는 참조를 통해서 다른 객체와 연과관계를 가지고 참조에 접근해서 연관된 객체를 조회한다.    
테이블은 외래키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다.    


객체는 참조가 있는 방향으로만 조회할 수 있다.   
```
member.getTeam(); // 가능 
team.getMember(); // 불가능
```


테이블은 외래키 하나로 `MEMBER JOIN TEAM`, `TEAM JOIN MEMBER` 모두 가능하다.     


- 객체를 테이블에 맞춰 모델링     
객체를 단순히 테이블에 맞춰서 모델링하면 Member 클래스는 teamId 이름의 TEAM_ID 외래키 컬럼을 갖게된다.         
외래키로 조인 탐색을 하면 연관된 객체를 찾을 수 있지만,   
객체는 연관된 객체의 참조를 보관해야 getter로 (`Team team = member.getTeam();`) 연관된 객체를 찾을 수 있다.<br />           
외래키까지 RDB가 사용하는 방식에 맞추면 Member 객체와 연관된 Team 객체를 참조를 통해 조회할 수 없다.   
이는 좋은 객체 모델링을 기대하기 어렵고 객체지향 특징을 잃어버리게 한다.     


- 객체지향 모델링      
객체지향 모델링을 참조로 연관관계를 맺는 것은 객체를 저장하거나 조회하기 쉽지 않다.    
테이블은 외래키로 저장하기 때문에 중간에서 개발자가 변환 역할을 해야한다.   

- JPA와 연관관계     
JPA는 연관관계와 관련된 패러다임의 불일치를 해결해준다.        
JPA는 Team 참조를 외래키로 변환해서 적절한 SQL로 DB에 전달한다.      
객체 조회 시, 외래키를 참조해서 Team 객체로 변환하는 것도 JPA가 처리해준다.       


<br />    


#### 객체 그래프 탐색    
객체에서 회원이 소속된 팀을 조회할 때 `member.getTeam()` 참조를 사용해서 연관된 팀을 찾는 것을   
객체 그래프 탐색이라고 한다.   

다음과 같은 연관관계가 설계되었다고 생각해보자.      
```  
Member - Team     Category
  |                  |
Order - OrderItem - Item 
  |
Delivery
```  

<br />      

- 객체 그래프를 탐색하는 코드     
```
membet.getOrder().getOrderItem()...
```
객체 그래프 탐색은 자유롭게 탐색이 가능해야 한다.     
마음껏 객체 그래프를 탐색하는게 가능할까?       

```
SELECT M.*, T.* 
FORM MEMBER M 
     JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID
```  
 
예를들어 MemberDao에서 member 객체를 조회할 때 이런 SQL을 실행해서 회원과 팀에 대한 데이터만 조회했다면    
member.getTeam()은 성공하지만 다음과 같은 다른 객체 그래프는 데이터가 없으므로 탐색할 수 없다.    

```
member.getOrder(); // null
```

SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다.    
비즈니스 로직에 따라 사용하는 객체 그래프가 다른데 언제 어디서 끊어질지 모를 객체 그래프를 함부로 탐색할 수 없기 때문인다.     


```
Member m = memberDao.find(...);
m.getTeam(); // member -> team 가능할까? 
m.getOrder().getDelivery(); // ???
```  

member 객체를 조회했지만 Team, Order, Delivery 방향으로 객체 그래프 탐색이 가능한지 전혀 예측할 수 없다.   
이를 확인하려면 SQL을 직접 확인해야 하는데 이것은 SQL 의존적인 개발에서도 얘기했듯이 엔티티가 SQL에 논리적으로 종속돼서 발생하는 문제다.    

그렇다고 Member와 연관된 모든 객체를 조회해서 애플리케이션 메모리에 올려두는 것은 현실성이 없고   
결국 상황에 따라 다음가 같이 조회하는 메소드를 전부 만들어야 한다.   

```  
getMember()   
getMemberWithTeam()  
getMemberWithOrderWithDelivery()  
```  

- JPA와 객체 그래프 탐색      
JPA를 사용하면 객체 그래프를 마음껏 탐색할 수 있다.     
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다.     
이 기능은 실제 객체를 사용하는 기점까지 DB 조회를 미룬다고 해서 **지연로딩**이라고 한다.     

<br />     


#### 비교    
DB는 PK로 각 로우를 구분한다.   
객체는 동일성(identity) 비교와 동등성(equality) 비교 두 가지 비교 방법이 있다.     

DB의 같은 로우를 조회했지만 객체의 동일성 비교는 실패할 수 있다.       
이런 패러다임 불일치 문제를 해결하려 매번 같은 인스턴스를 반환하도록 구현하는 것은 어렵고        
여러 트랜잭션이 동시에 실행되는 상황이라면 더 어려워진다.   

- JPA와 비교    
JPA는 같은 트랜잭션일 때 같은 객체가 조회되는 것을 보장한다.     


<br />     

### 3. JPA란 무엇인가?       

JPA는 자바 진영의 ORM 기술 표준이다.   
애플리케이션과 JDBC 사이에서 동작한다.       

![스크린샷 2021-01-11 오후 7 33 30](https://user-images.githubusercontent.com/33855307/104170090-eb2bf280-5443-11eb-9710-2b098987ee1a.png)       


ORM이란 무엇일까? Object-Relational Mapping 이름 그대로 객체와 관계형 데이터베이스를 매핑한다는 뜻이다.      
ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임 불일치 문제를 개발자 대신 해결해준다.       

![스크린샷 2021-01-11 오후 7 40 38](https://user-images.githubusercontent.com/33855307/104170699-e61b7300-5444-11eb-9b3d-0b2a5987de18.png)     



<br />        

#### 왜 JPA를 사용해야 하는가?          

**(1) 생산성**            
JPA를 사용하면 다음 코드처럼 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 된다.     
INSERT SQL을 작성하고 JDBC API를 사용하는 반복적인 작업은 JPA가 대신해준다.     

```
jpa.persist(member); // 저장
Member member = jpa.find(memberId); // 조회
```

`CREATE TABLE` 같은 DDL 문을 자동으로 생성해주는 기능도 있어     
데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전시킬 수 있다.             


**(2) 유지보수**       
SQL에 의존적인 개발에서도 이야기했듯이 SQL을 직접 다루면 엔티티에 필드를 하나만 추가해도          
관련된 등록, 수정, 조회 SQL과 결과를 매핑하기 위한 JDBC API 코드를 모두 변경해야 한다.          
개발자가 작성해야 했던 SQL과 JDBC API 코드를 JPA가 대신 처리해주므로 유지보수해야 하는 코드 수가 줄어든다.          

JPA가 패러다임의 불일치 문제를 해결해주기 때문에 객체지향 언어가 가질 장점들을 활용해서      
유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있게 되었다.         


**(3) 패러다임의 불일치 해결**       
JPA는 상속, 연관관계, 객체 그래프 탐색, 비교하기와 같은 패러다임의 불일치 문제를 해결해준다.    


**(4) 성능**    
JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공한다.    
JPA는 애플리케이션과 데이터 베이스 사이에서 동작하는데   
이렇게 애플리케이션과 데이터 베이스 사이에 계층이 하나 더 있으면 최적화 관점에서 시도해 볼 수 있는 것들이 많다.    

```
String id = "helloId";
Member member1 = jpa.find(id);
Member member2 = jpa.find(id);
```

이것은 같은 트랜잭션 안에서 같은 회원을 두 번 조회하는 코드의 일부분이다.   
JDBC API를 사용해서 해당 코드를 직접 작성했다면 회원을 조회할 때마다 SELECT SQL을 사용해서 데이터베이스와 두 번 통신했을 것이다.    
JPA를 사용하면 회원을 조회하는 SELECT SQL을 한 번만 데이터베이스에 전달하고 두 번째는 조회한 회우너 객체를 재사용한다.    


**(5) 데이터 접근 추상화와 벤더 독립성**    
관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많다.   
예를들어 페이칭 처리는 데이터베이스마다 달라서 사용법을 각각 배워야 한다.   
즉 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기 매우 어렵다.    

JPA는 다음 구조처럼 애플리케이션과 데이터베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 한다.      

```
JPA ----- 사용 -----> Dialect
                        ^
                        |
          ------------------------------
          |             |              |
     MySQLDialect  OracleDialect   H2Dialect 

    MySQL SQL 생성  Oracle SQL 생성  H2 SQL 생성 
```



**(6) 표준**    
JPA는 자바 진영의 ORM 기술 표준이다.             
표준을 사용하면 다른 구현 기술로 쉽게 변경할 수 있다.                  

<br />        

## Q&A   

#### Q. 통계 쿼리처럼 매우 복잡한 SQL은 어떻게 하나요?         
JPA는 통계 쿼리 같이 복잡한 쿼리보다는 실시간 처리용 쿼리에 더 최적화되어 있다.     
상황에 따라 다르지만 정말 복잡한 통계 쿼리는 SQL을 직접 작성하는 것이 더 쉬운 경우가 많다.      
따라서 JPA가 제공하는 네이티브 SQL을 사용하거나 마이바티스 스프링의 JdbcTemplate 같은 SQL 매퍼 형태의 프레임워크를 혼용하는 것도 방법이다.            
 

#### Q. 마이바티스와 어떤 차이가 있나요?       
마이바티스나 스프링의 JdbcTemplate을 보통 SQL 매퍼라고 한다. 이름 그대로 객체와 SQL을 매핑한다.     
따라서 SQL과 매핑할 객체만 지정하면 지루하게 반복되는 JDBC API 사용과 응답 결과를 객체로 매핑하는 일은 SQL 매퍼가 대신 처리해준다.    
SQL 매퍼가 편리하긴 하지만 결국 개발자가 SQL을 직접 작성해야 하므로 SQL에 의존하는 개발을 피할 수 없다.    
반면 ORM은 객체와 테이블을 매핑만하면 ORM 프레임워크가 SQL을 만들어서 데이터베이스와 관련된 처리를 해주기 때문에 SQL에 의존하는 개발을 피할 수 있다.    


